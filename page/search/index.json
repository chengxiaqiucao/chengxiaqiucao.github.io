[{"content":"前言 测试人员工作中，发现Bug更多还是依靠对应用的探索式测试。\n而在应用的探索过程中，表单中填入测试数据又是一个非常高频的操作，准备多种等价或边界值的测试数据并快速填入，是测试人员在验证和探索功能时必不可少的动作。但包括大量数据的准备，使其符合表单本身的约束，同时还要快速填入使流程尽快向下运行，在执行中其实占用了不少时间，很影响工作效率。\n其实业界较早就有类似的工具来辅助测试，比如 https://autotestdata.com/ 这个网站就可以根据我们的需要生成相关的 fake 数据，自动化测试中也有相关的fake库，比如python的Faker。\n但这些数据生成，还是存在根据整理需求、生成数据、拷贝数据，再填入表单这样的操作，总归还不够顺手。\n本文介绍一个 Chrome 插件，可以在表单操作的同时，快速呼出相关的数据并根据需要进行填入。\n相信是我们在进行页面测试时的重要帮手。\n插件介绍 这个 Chrome 插件 就是 Auto Data Filter\n从 Chrome 的插件商店中找到这个插件，进行安装即可。\n另外，从插件名称中，其实可以看到，它其实是另一个插件 Bug Magnet 的替代品。只是原插件已经失效，没人维护了\n使用也非常简单，在需要填充数据的表单中，点击右键，就可呼出插件菜单，选择对应的内置数据，即可快速填充。\n用法很简单，但非常实用\n离线安装 如果不能顺利访问插件商店，也可通过离线方式安装。 本公众号回复 AutoData 可获取插件离线包\n获取插件离线包，解压到本地目录 进入chrome插件管理页面 打开开发者模式 加载刚才解压的离线插件包 完成安装 数据定制 这个插件虽然使用比较简单。但有个问题，就是测试数据主要还是英文的，很多内置数据不一定覆盖我们常用的数据\n通过离线包，我们还可以对数据进行定制\n这些数据其实保存在插件包 js 目录下的 jsformat.js 文件中，把我们自定义的数据补充或修改到文件中即可。\n以下是修改后，插件呼出数据的效果\n","date":"2025-08-11T14:25:29+08:00","image":"https://chengxiaqiucao.github.io/post/120-autotestdata/title_hu_23f010d963f824c1.png","permalink":"https://chengxiaqiucao.github.io/post/120-autotestdata/","title":"推荐一个用于页面探索测试的数据辅助工具"},{"content":"\n引言 在UI测试自动化领域，页面对象模型（Page Object Model，POM）几乎已经是行业标准。它被广泛认为是UI自动化测试领域的最佳实践，对于提高可维护性和可扩展性，几乎是不二之选。\n笔者在实际工作中，组织搭建过的UI自动化框架虽然大部分也是遵循了个这个模型，但隐隐也确实觉得这个更多是个开发实践而不是应用实践。是OOP(面向对象)思想在自动化测试实施种的体现。\n现偶然看到一篇国外博主的 Shubham Sharma 的文章 《Beyond the Page Object Model-A Functional Approach to Test Automation》，对POM模型进行了思考，并提出了一个函数化方法模型。（文末阅读原文可跳转原文）\n虽然不知具体实践成效如何，但兼听则明，开拓下思路总是没错的。\n以下基于原博文内容翻译整理而来（help by Gemini）\n关于POM POM的核心思想是将页面元素和浏览器交互封装到整洁、可重用的对象中。\n它的方法很简单：为每个页面或组件创建一个类，包含定位器（locators）和操作这些元素的方法。\n虽然POM相比那些充满硬编码元素的脆弱脚本是一个进步，但它本质上也是一个有缺陷的抽象。它将面向对象原则应用到一个本质上过程化和行为驱动的问题领域，导致测试套件难以理解、与状态紧密耦合且扩展困难。\nPOM问题 以一个典型的登录流程POM实现为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class LoginPage { constructor(driver) { this.driver = driver; this.usernameField = \u0026#39;#username\u0026#39;; this.passwordField = \u0026#39;#password\u0026#39;; this.loginButton = \u0026#39;#login-btn\u0026#39;; } async enterUsername(username) { await this.driver.locator(this.usernameField).fill(username); } async enterPassword(password) { await this.driver.locator(this.passwordField).fill(password); } async clickLogin() { await this.driver.locator(this.loginButton).click(); } async loginAs(username, password) { await this.enterUsername(username); await this.enterPassword(password); await this.clickLogin(); } } 在测试中的使用：\n1 2 3 4 test(\u0026#39;user can log in\u0026#39;, async ({ page }) =\u0026gt; { const loginPage = new LoginPage(page); await loginPage.loginAs(\u0026#39;testuser\u0026#39;, \u0026#39;password123\u0026#39;); }); 乍一看，这看起来很整洁。但在表面之下，它引入了几个严重问题：\n隐藏状态和紧密耦合 对象存储了对驱动程序（page）的引用，创建了隐式依赖。这使得页面类无法独立测试，并将其行为和浏览器的运行时状态进行了锁定。\n分散的用户逻辑 像\u0026quot;登录、进入设置、更改密码\u0026quot; 这样的用户旅程变成了跨多个页面对象的方法调用链。工作流被分割——而不是一个连贯的、可测试的单元。\n僵化和膨胀 一些新的流程（如SSO登录），则被迫添加更多方法（违反单一职责原则）或创建新类（导致重复）。随着时间的推移，你的页面对象要么膨胀，要么分裂。\nPOM将页面作为抽象单位。但页面只是背景。\n真正重要的是用户操作。\n替代方案：函数式模型，可组合的工作流 函数式模型颠覆了这一脚本。它将用户行为，而非UI结构作为主要抽象。\n第一步：分离数据（定位器） 将选择器保持为普通的、不可变的数据——没有方法，没有状态：\n1 2 3 4 5 export const LoginPageLocators = { usernameField: \u0026#39;#username\u0026#39;, passwordField: \u0026#39;#password\u0026#39;, loginButton: \u0026#39;#login-btn\u0026#39;, }; 第二步：编写无状态交互函数 不要将方法绑定到类，而是编写可重用的无状态函数：\n1 2 3 4 5 6 7 export async function fillField(page, locator, text) { await page.locator(locator).fill(text); } export async function clickElement(page, locator) { await page.locator(locator).click(); } 这些可以在整个应用中重用，易于独立测试，并且可以集中改进（例如添加重试、等待、日志记录）。\n第三步：以声明方式组合用户工作流 将真正的用户旅程构建为一等函数：\n1 2 3 4 5 6 7 export function login(page, credentials) { return async () =\u0026gt; { await fillField(page, LoginPageLocators.usernameField, credentials.username); await fillField(page, LoginPageLocators.passwordField, credentials.password); await clickElement(page, LoginPageLocators.loginButton); }; } 现在你的测试读起来就像一个故事：\n1 2 3 4 test(\u0026#39;user can log in\u0026#39;, async ({ page }) =\u0026gt; { const credentials = { username: \u0026#39;admin\u0026#39;, password: \u0026#39;securePassword\u0026#39; }; await login(page, credentials)(); }); 为什么推荐这种方法 真正的可组合性 你不仅仅是在调用方法，而是在构建工作流。login()函数可以组合到changePassword()工作流中，或者与导航步骤结合。函数成为有意义的可测试单元。\n改进的清晰度 测试不再是逐步执行UI操作的命令式脚本。相反，它们成为用户意图的声明式管道，更易于阅读、编写和理解。\n集中化维护 修复不稳定的选择器或改进点击行为发生在一个地方，并传播到所有地方。不再需要在分散在文件中的类方法中寻找。\n测试的范式转变 页面对象模型反映了一个遗留范式：面向对象编程，其中所有事物都被建模为具有状态和行为的\u0026quot;事物\u0026quot;。但UI测试不是关于事物，而是关于流程。\n通过拥抱函数式思维，我们将测试建模为用户行为的可组合管道，而不是僵化的对象。这些工作流具有以下特点：\n无状态 隔离 声明式 易于测试 易于更改 易于组合 核心要点 停止问：\u0026ldquo;我这里需要什么页面对象？\u0026rdquo;\n开始问：\u0026ldquo;我想要描述的用户工作流是什么？\u0026rdquo;\n答案将引导你构建一个更简单、更清洁、更接近真实用户体验的测试套件，它不是建立在继承和隐藏状态之上，而是建立在纯函数和可组合流程之上。这不仅仅是一种编码风格，它是测试的更好心智模型。\n结论：迈向更自然的测试方式 页面对象模型曾经是UI测试自动化的重要进步，但随着测试复杂度的增加和软件开发理念的发展，它的局限性日益明显。函数式方法为我们提供了一个更自然、更灵活的替代方案。\n通过将关注点从页面结构转向用户行为，从对象状态转向工作流程，我们能够创建更贴近真实用户体验的测试。这种方法不仅提高了代码的可维护性和可读性，更重要的是，它改变了我们对测试本质的理解。\n在快速变化的软件开发现代中，我们需要能够适应变化的测试策略。函数式测试方法正是这样一种策略——它灵活、可组合、易于维护，能够随着应用的发展而演进。\n","date":"2025-08-06T21:58:13+08:00","image":"https://chengxiaqiucao.github.io/post/118-pom_replacement/Pasted-20250806_hu_1a5d7fa302a4ca78.png","permalink":"https://chengxiaqiucao.github.io/post/118-pom_replacement/","title":"UI自动化，POM之外的另一模式"},{"content":"\n引言 开发过Python程序或通过Python编写自动化脚本，都知道日志对于一个程序的重要性。 Python语言也内建了一个日志处理的标准库 logging, 但这个库的使用相对比较复杂。\n本文我们介绍一个目前很受欢迎的第三方日志框架 Loguru, 在Github上已有超过22K星标。是一个比 logging更加直观易用的替代方案。开发者可以专注于业务逻辑而不是日志配置的繁琐细节\nLoguru的使用 1. 安装和快速开始 1 pip install loguru 最简单的使用方式：\n1 2 3 from loguru import logger logger.debug(\u0026#34;Happy logging with Loguru!\u0026#34;) 输出：\n1 2025-08-01 14:00:51.069 | DEBUG | __main__:\u0026lt;module\u0026gt;:3 - Happy logging with Loguru! 2. 日志级别 Loguru提供了7个内置日志级别， 并对不同级别设定了不同的默认颜色显示：\n级别 方法 数值 用途 TRACE logger.trace() 5 极其详细的调试信息 DEBUG logger.debug() 10 开发调试信息 INFO logger.info() 20 一般信息 SUCCESS logger.success() 25 成功操作通知 WARNING logger.warning() 30 警告信息 ERROR logger.error() 40 错误信息 CRITICAL logger.critical() 50 严重错误 示例代码：\n1 2 3 4 5 6 7 8 9 from loguru import logger logger.trace(\u0026#34;A trace message.\u0026#34;) logger.debug(\u0026#34;A debug message.\u0026#34;) logger.info(\u0026#34;An info message.\u0026#34;) logger.success(\u0026#34;A success message.\u0026#34;) logger.warning(\u0026#34;A warning message.\u0026#34;) logger.error(\u0026#34;An error message.\u0026#34;) logger.critical(\u0026#34;A critical message.\u0026#34;) 输出： 3. 自定义日志级别 loguru 创建自定义的级别也极为方便，比如创建一个 FATAL 级别的日志\n1 2 3 4 5 from loguru import logger # 创建自定义级别 logger.level(\u0026#34;FATAL\u0026#34;, no=60, color=\u0026#34;\u0026#34;, icon=\u0026#34;!!!\u0026#34;) logger.log(\u0026#34;FATAL\u0026#34;, \u0026#34;A fatal error occurred.\u0026#34;) 进阶用法 1. 日志处理器配置 Loguru使用add()方法添加处理器：\n1 2 3 4 5 6 7 8 9 10 import sys from loguru import logger # 移除默认处理器 logger.remove() # 添加自定义处理器 logger.add(sys.stderr, level=\u0026#34;INFO\u0026#34;, format=\u0026#34;{time:YYYY-MM-DD HH:mm:ss} | {level} | {message}\u0026#34;) logger.log(\u0026#34;INFO\u0026#34;,\u0026#34;配置完成，开始记录日志\u0026#34;) 2. 文件日志 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from loguru import logger # 基本文件日志 logger.add(\u0026#34;app.log\u0026#34;, rotation=\u0026#34;500 MB\u0026#34;, retention=\u0026#34;10 days\u0026#34;, compression=\u0026#34;zip\u0026#34;) # 高级文件日志配置 logger.add( \u0026#34;app_{time:YYYY-MM-DD}.log\u0026#34;, rotation=\u0026#34;00:00\u0026#34;, # 每天午夜轮转 retention=\u0026#34;30 days\u0026#34;, # 保留30天 compression=\u0026#34;gz\u0026#34;, # 压缩格式 level=\u0026#34;INFO\u0026#34; ) logger.info(\u0026#34;测试一下日志\u0026#34;) 执行后，根据代码会得到两个日志文件，app.log, app_2025-08-01.log\n3. 日志格式化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import sys from loguru import logger logger.remove() # 自定义格式 logger.add( sys.stderr, format=\u0026#34;\u0026lt;green\u0026gt;{time:YYYY-MM-DD HH:mm:ss}\u0026lt;/green\u0026gt; | \u0026#34; \u0026#34;\u0026lt;level\u0026gt;{level: \u0026lt;8}\u0026lt;/level\u0026gt; | \u0026#34; \u0026#34;\u0026lt;cyan\u0026gt;{name}\u0026lt;/cyan\u0026gt;:\u0026lt;cyan\u0026gt;{function}\u0026lt;/cyan\u0026gt;:\u0026lt;cyan\u0026gt;{line}\u0026lt;/cyan\u0026gt; | \u0026#34; \u0026#34;\u0026lt;level\u0026gt;{message}\u0026lt;/level\u0026gt;\u0026#34; ) # 也可使用函数进行动态格式化 def custom_formatter(record): if record[\u0026#34;level\u0026#34;].no \u0026gt;= 40: # ERROR及以上 return \u0026#34;{time} | {level} | {thread} | {message}\\n{exception}\u0026#34; else: return \u0026#34;{time} | {level} | {message}\\n{exception}\u0026#34; logger.add(sys.stderr, format=custom_formatter) logger.info(\u0026#34;测试一下日志\u0026#34;) 会得到如下定义的输出结果： 4. 日志过滤 1 2 3 4 5 6 7 8 9 10 11 12 13 from loguru import logger # 基于级别的过滤 def level_filter(level): def is_level(record): return record[\u0026#34;level\u0026#34;].name == level return is_level logger.add(sys.stderr, filter=level_filter(level=\u0026#34;WARNING\u0026#34;)) # 基于模块的过滤 logger.add(\u0026#34;app.log\u0026#34;, filter=\u0026#34;my_module\u0026#34;) # 只记录my_module的日志 logger.add(\u0026#34;error.log\u0026#34;, filter=lambda record: record[\u0026#34;level\u0026#34;].no \u0026gt;= 40) # 只记录错误及以上日志 5. 结构化日志（JSON格式） loguru默认提供支持json格式的序列化输出\n1 2 3 4 5 6 from loguru import logger # JSON格式日志 logger.add(sys.stderr, serialize=True) logger.info(\u0026#34;测试一下日志\u0026#34;) 得到如下输出：\n1 {\u0026#34;text\u0026#34;: \u0026#34;2025-08-01 14:25:44.560 | INFO | __main__:\u0026lt;module\u0026gt;:8 - 测试一下日志\\n\u0026#34;, \u0026#34;record\u0026#34;: {\u0026#34;elapsed\u0026#34;: {\u0026#34;repr\u0026#34;: \u0026#34;0:00:00.00 \u0026#34;seconds\u0026#34;: 0.003698}, \u0026#34;exception\u0026#34;: null, \u0026#34;extra\u0026#34;: {}, \u0026#34;file\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;demo.py\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;E:\\\\qiucao\\\\dev\\\\loguruDemo\\\\demo.py\u0026#34;}, \u0026#34;function\u0026#34;: \u0026#34;\u0026lt;module\u0026gt;\u0026#34;, \u0026#34;level\u0026#34;: {\u0026#34;icon\u0026#34;: \u0026#34;ℹ️\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;INFO\u0026#34;, \u0026#34;no\u0026#34;: 20}, \u0026#34;line\u0026#34;: 8, \u0026#34;message\u0026#34;: \u0026#34;测试一下日志\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34; \u0026#34;name\u0026#34;: \u0026#34;__main__\u0026#34;, \u0026#34;process\u0026#34;: {\u0026#34;id\u0026#34;: 4580, \u0026#34;name\u0026#34;: \u0026#34;MainProcess\u0026#34;}, \u0026#34;thread\u0026#34;: {\u0026#34;id\u0026#34;: 5680, \u0026#34;name\u0026#34;: \u0026#34;MainThread\u0026#34;}, \u0026#34;time\u0026#34;: {\u0026#34;repr\u0026#34;: \u0026#34;2025-08-01 14:25:44.560271+08:00\u0026#34;, \u0026#34;timestamp\u0026#34;: 1754029544.560271}}} 6. 异常处理和调试 1 2 3 4 5 6 7 8 9 10 from loguru import logger # 控制诊断信息（生产环境应设为False） logger.add(\u0026#34;app.log\u0026#34;, diagnose=False) # 自动捕获异常 try: result = 1 / 0 except ZeroDivisionError: logger.exception(\u0026#34;Division by zero occurred\u0026#34;) loguru 可以直接捕获异常，这里的diagnose 参数，还会在捕获异常时，自动记录局部变量的信息，便于我们进行调试（生产环境一般需要设置为False）\n总结 以上就 loguru 这个库的用法总结，无论从配置的简便性，功能丰富程度，还是对自定义扩展、调试支持等多方面，都非常出色。\n那么，写Python处理日志，就快快用起来吧~~\npytest中使用loguru的问题及解决 引语 上一篇文章，我们向大家推荐了python语言的一个第三方日志库loguru，使用非常简单且功能完备。文章参见【】\n但对于我们做自动化测试，经常使用 pytest 框架的小伙伴来说，却有点小问题。就是 Pytest 内建的日志捕获机制是在标准库 logging 的基础上进行优化过的。 这样我们在使用 pytest 框架时，如果牵涉到 pytest 自身的日志机制，也就是pytest的内建fixture caplog实际使用的还是logging标准模块, 这里loguru 库定义的日志就难以发生作用。\n当然，问题也不大，本文我们简单探讨下这个问题，并介绍下兼容方案。\nPytest 中的caplog 首先我们还是先来介绍下 Pytest 的日志\ncaplog是pytest提供的一个内置fixture，用于捕获和测试日志输出。\n因为这个内置插件的作用，我们在执行pytest测试时，默认只会在用例存在失败时才会显示标准输出和logging模块及记录的日志信息。\n比如下面这段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # test_cap.py import logging def test_fail(): print(\u0026#34;这条信息将在失败时显示\u0026#34;) assert False def test_pass(): print(\u0026#34;这条信息成功时不显示\u0026#34;) assert True def test_exception(): try: result = 1 / 0 except ZeroDivisionError: logging.error(\u0026#34;除零错误发生\u0026#34;, exc_info=True) result = None assert False 我们正常通过 pytest 执行的话，会看到下面这样的输出\n而如果我们将上面记录日志的部分修改为loguru库的日志写法的话\n1 2 3 4 5 6 7 8 def test_exception(): try: result = 1 / 0 except ZeroDivisionError: # logging.error(\u0026#34;除零错误发生\u0026#34;, exc_info=True) logger.error(\u0026#34;除零错误发生\u0026#34;) result = None assert False 运行时能看到区别：\n也就是 loguru 记录的日志，不能被 Pytest 的 caplog 获取。\n这样自然也就不能使用 caplog 提供的一些api如 caplog.text, caplog.records， 为我们灵活利用 pytest 造成了一些阻碍\n解决兼容问题 那要解决这个兼容问题，有多个方案，这里分享下我的验证\n方案1：pytest-loguru 存在问题，当然可以先查一下社区有没有现成的解决方案， 然后发现有人已经提供了解决方案。就是 pytest-loguru 这个插件\n通过下面命令安装即可：\npip install pytest-loguru\n但我进行实测，发现windows系统上会报句柄错误\n所以这里建议使用方案二解决。\n方案二：loguru日志输出重定向到logging标准输出 可以利用 pytest 的 conftest.py 配置脚本，用下面的代码将 loguru 日志重定向到 logging\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 # conftest.py import pytest import logging from loguru import logger class SafePropagateHandler(logging.Handler): def __init__(self): super().__init__() # 确保有一个基本的格式化器 self.setFormatter(logging.Formatter(\u0026#39;%(levelname)s - %(message)s\u0026#39;)) def emit(self, record): try: # 获取标准logging的logger std_logger = logging.getLogger(record.name) # 确保logger有处理器 if not std_logger.handlers: # 添加一个空处理器，避免\u0026#34;No handlers\u0026#34;警告 std_logger.addHandler(logging.NullHandler()) # 安全地处理记录 std_logger.handle(record) except Exception: # 如果传播失败，静默忽略，避免影响测试 pass @pytest.fixture(scope=\u0026#34;session\u0026#34;, autouse=True) def setup_safe_loguru_integration(): # 移除Loguru的默认处理器 logger.remove() safe_handler = SafePropagateHandler() # 添加传播处理器到Loguru handler_id = logger.add( safe_handler, format=\u0026#34;{message}\u0026#34;, # 简化格式，避免重复 level=\u0026#34;DEBUG\u0026#34;, backtrace=False, diagnose=False, catch=True # 捕获处理器中的异常 ) # 配置标准logging以避免冲突 logging.basicConfig( level=logging.INFO, format=\u0026#39;%(levelname)s - %(message)s\u0026#39;, handlers=[logging.NullHandler()] ) yield # 清理 logger.remove(handler_id) 再次执行，可以看到caplog已经可以正常捕捉loguru记录的日志了\nloguru和logging模块对比 2. Loguru vs Python标准logging库对比 在深入了解Loguru之前，让我们先将其与Python标准库中的logging模块进行对比，这将帮助您更好地理解为什么越来越多的开发者选择Loguru作为他们的日志解决方案。\n2.1 配置复杂度对比 Python标准logging的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import logging # 标准logging需要多个步骤的配置 logger = logging.getLogger(__name__) logger.setLevel(logging.DEBUG) # 创建控制台处理器 console_handler = logging.StreamHandler() console_handler.setLevel(logging.INFO) # 创建文件处理器 file_handler = logging.FileHandler(\u0026#39;app.log\u0026#39;) file_handler.setLevel(logging.DEBUG) # 创建格式化器 console_formatter = logging.Formatter(\u0026#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#39;) file_formatter = logging.Formatter(\u0026#39;%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s\u0026#39;) # 设置格式化器 console_handler.setFormatter(console_formatter) file_handler.setFormatter(file_formatter) # 添加处理器 logger.addHandler(console_handler) logger.addHandler(file_handler) # 现在才能开始使用 logger.info(\u0026#34;配置完成，开始记录日志\u0026#34;) Loguru的配置：\n1 2 3 4 5 6 7 from loguru import logger # Loguru一行代码即可完成相同功能 logger.add(sys.stdout, level=\u0026#34;INFO\u0026#34;, format=\u0026#34;{time} - {name} - {level} - {message}\u0026#34;) logger.add(\u0026#34;app.log\u0026#34;, level=\u0026#34;DEBUG\u0026#34;, format=\u0026#34;{time} - {name} - {level} - {file}:{line} - {message}\u0026#34;) logger.info(\u0026#34;配置完成，开始记录日志\u0026#34;) 优势对比：\n标准logging：需要创建logger、handler、formatter等多个对象，并进行多层配置 Loguru：通过简单的add()方法即可完成所有配置，代码量减少70%以上 2.2 API简洁性对比 Python标准logging的API：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import logging # 需要导入多个模块和类 import logging.handlers import logging.config # 不同级别需要不同的方法调用 logger.debug(\u0026#34;Debug message\u0026#34;) logger.info(\u0026#34;Info message\u0026#34;) logger.warning(\u0026#34;Warning message\u0026#34;) logger.error(\u0026#34;Error message\u0026#34;) logger.critical(\u0026#34;Critical message\u0026#34;) # 异常记录需要单独处理 try: 1 / 0 except Exception as e: logger.error(\u0026#34;An error occurred\u0026#34;, exc_info=True) Loguru的API：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from loguru import logger # 统一的API，更直观的方法名 logger.trace(\u0026#34;Trace message\u0026#34;) # 比debug更详细 logger.debug(\u0026#34;Debug message\u0026#34;) logger.info(\u0026#34;Info message\u0026#34;) logger.success(\u0026#34;Success message\u0026#34;) # 独有的成功级别 logger.warning(\u0026#34;Warning message\u0026#34;) logger.error(\u0026#34;Error message\u0026#34;) logger.critical(\u0026#34;Critical message\u0026#34;) # 异常记录极其简单 try: 1 / 0 except Exception: logger.exception(\u0026#34;An error occurred\u0026#34;) # 自动包含异常信息 优势对比：\n标准logging：API相对繁琐，异常处理需要额外参数 Loguru：API设计更加人性化，提供SUCCESS级别，异常处理更简洁 2.3 功能特性对比 功能特性 Python标准logging Loguru 优势说明 日志轮转 需要TimedRotatingFileHandler或RotatingFileHandler 内置支持，一行代码配置 Loguru配置简单，支持更多轮转策略 日志压缩 不支持，需要手动实现 内置支持多种压缩格式 Loguru自动处理，节省存储空间 日志过滤 需要创建Filter类 支持函数、字符串、字典等多种过滤方式 Loguru更灵活，代码更少 结构化日志 不支持原生JSON格式 内置JSON序列化支持 Loguru更适合现代日志分析系统 颜色支持 需要第三方库如colorama 内置终端颜色支持 Loguru开箱即用，视觉效果更好 上下文信息 需要手动使用LoggerAdapter 通过bind()方法轻松实现 Loguru更直观，功能更强大 异常诊断 基本的异常信息 详细的变量值显示和调用栈 Loguru调试效率更高 代码示例对比：\n标准logging实现日志轮转：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import logging import logging.handlers import os # 创建轮转文件处理器 rotating_handler = logging.handlers.RotatingFileHandler( \u0026#39;app.log\u0026#39;, maxBytes=10*1024*1024, # 10MB backupCount=5 ) # 需要手动处理压缩 def compress_old_logs(): # 复杂的压缩逻辑... pass logger.addHandler(rotating_handler) Loguru实现日志轮转：\n1 2 3 4 5 6 7 8 9 from loguru import logger # 一行代码搞定轮转和压缩 logger.add( \u0026#34;app.log\u0026#34;, rotation=\u0026#34;10 MB\u0026#34;, # 文件大小轮转 retention=\u0026#34;10 days\u0026#34;, # 保留10天 compression=\u0026#34;zip\u0026#34; # 自动压缩 ) 2.4 使用体验对比 Python标准logging的痛点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import logging # 痛点1：全局配置影响所有模块 logging.basicConfig(level=logging.DEBUG) # 会影响整个程序 # 痛点2：重复日志问题 logger1 = logging.getLogger(\u0026#39;app\u0026#39;) logger2 = logging.getLogger(\u0026#39;app.module\u0026#39;) # 如果配置不当，容易出现重复日志 # 痛点3：格式化字符串需要使用% logger.info(\u0026#34;User %s logged in from %s\u0026#34;, username, ip_address) # 不如f-string直观 # 痛点4：难以获取调用者信息 # 需要复杂的格式化字符串才能显示文件名和行号 Loguru的解决方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from loguru import logger # 优势1：单例模式，避免配置混乱 # 无需担心多个logger实例的配置问题 # 优势2：自动避免重复日志 # 智能的处理器管理，不会出现重复输出 # 优势3：支持现代字符串格式化 logger.info(f\u0026#34;User {username} logged in from {ip_address}\u0026#34;) # 也支持{}格式化 logger.info(\u0026#34;User {} logged in from {}\u0026#34;, username, ip_address) # 优势4：自动包含丰富的上下文信息 # 默认显示时间、级别、模块、函数、行号等 2.5 性能和内存使用对比 性能测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import time import logging from loguru import logger # 测试标准logging性能 def test_standard_logging(): std_logger = logging.getLogger(\u0026#39;test\u0026#39;) std_logger.setLevel(logging.DEBUG) handler = logging.StreamHandler() handler.setLevel(logging.DEBUG) std_logger.addHandler(handler) start = time.time() for i in range(10000): std_logger.debug(f\u0026#34;Test message {i}\u0026#34;) end = time.time() return end - start # 测试Loguru性能 def test_loguru(): logger.remove() handler_id = logger.add(sys.stderr, level=\u0026#34;DEBUG\u0026#34;) start = time.time() for i in range(10000): logger.debug(f\u0026#34;Test message {i}\u0026#34;) end = time.time() logger.remove(handler_id) return end - start 性能对比结果：\n标准logging：在简单场景下性能略好，但功能有限 Loguru：在启用高级功能（如异步、格式化）时性能接近标准logging，但功能更强大 内存使用对比：\n标准logging：每个logger实例占用较多内存 Loguru：单例模式，内存使用更高效 2.6 迁移成本对比 从标准logging迁移到Loguru：\n1 2 3 4 5 6 7 8 9 10 # 原有代码 import logging logger = logging.getLogger(__name__) logger.info(\u0026#34;This is a log message\u0026#34;) # 迁移后代码 from loguru import logger logger.info(\u0026#34;This is a log message\u0026#34;) # API几乎完全兼容 迁移优势：\nAPI兼容性：Loguru的API设计与标准logging相似，学习成本低 渐进式迁移：可以在项目中同时使用两者，逐步迁移 向后兼容：Loguru提供了与标准logging的集成方案 2.7 总结对比 对比维度 Python标准logging Loguru 推荐选择 学习曲线 陡峭，需要理解多个概念 平缓，直观易用 Loguru 配置复杂度 高，需要多个步骤 低，一行代码搞定 Loguru 功能完整性 基础功能，需要扩展 开箱即用的高级功能 Loguru 代码简洁性 冗长，模板代码多 简洁，表达力强 Loguru 调试友好性 一般 优秀，详细信息丰富 Loguru 性能 略好（简单场景） 接近，功能更强大 Loguru 社区支持 官方支持，历史悠久 活跃社区，快速迭代 Loguru 结论： Loguru在几乎所有的对比维度上都优于Python标准logging库。它不仅大大简化了日志配置的复杂性，还提供了更丰富的功能和更好的用户体验。对于新项目，强烈推荐直接使用Loguru；对于现有项目，也可以考虑逐步迁移到Loguru以提升开发效率和日志管理能力。\n","date":"2025-07-31T17:09:06+08:00","image":"https://chengxiaqiucao.github.io/post/117-loguru/Pasted-20250801-2_hu_cc9f438a91f08027.png","permalink":"https://chengxiaqiucao.github.io/post/117-loguru/","title":"python日志的新姿势，Loguru库的应用"},{"content":"\n引子 回到十四年前，2011年10月，在Google的GTAC(Google Test Automation Conference)大会上，Alberto Savoia 身着死神装扮走上讲台，以一种戏剧性地方式宣称 \u0026ldquo;软件测试已死\u0026rdquo;。\n不久以后，测试界大牛Jame Whittaker 在另一个测试大会 EuroSTAR 上也以同样的主题，宣布Test is Dead.\n这些言论的重点，在于认为软件测试不再需要作为软件开发过程中一个独立的角色。在软件流程和工具已经成熟的情况下，宏观的质量问题不再需要一个相对大型、专职的团队来进行保证。相反，测试应该演变成一系列微观的活动，分散给其他角色，例如项目经理、开发人员，甚至最终用户。 把测试活动分散到研发的其他环节。\n而随着这个宣言的广泛流传，包括google、微软在内的大量科技巨头开始裁撤专职测试岗位，测试转型为测试开发或软件效能部门。\n但十多年过去，测试这个职业真的消亡了吗？相反，包括 Wittaker 本人也于去年(2024)发表了一篇 《软件测试业的复兴》重新审视测试行业的演变 (原文参见 https://medium.com/@docjamesw/the-resurrection-of-software-testing-634423cd8411)\n这篇文章，我们就再来深入探讨一下这个话题\n\u0026ldquo;测试已死\u0026quot;论调的反复出现 从\u0026quot;测试已死\u0026quot;的论调提出，到如今其实已经被多次提及。这种说法至少在三个时期反复出现：\nSelenium开源时代：当自动化测试工具逐渐走进企业的日常应用，机器代替人工似乎近在眼前 自动化测试框架和平台泛滥时期：市场上涌现出大量的自动化测试解决方案，都宣称可以极大减少测试工作 现今AI时代：现今AI大行其道，老调重弹，认为AI已经可以替代测试人员的工作 为什么？ 其实仔细思考一下，这种周期性出现也并非偶然，它反映的是技术变革与行业认知之间的常见错位。每当有新技术出现，人们就倾向于过度乐观地认为它可以完全替代人类的判断和创造力。\n除此之外，测试行业本身对测试的认知，也很大程度上在为这种论调提供论据。\n大量培训机构，包括很多测试人员自己也并不将测试视作一门技术 0基础入行 小白也可做测试 测试不过是“点点点” 学会写自动化脚本就是高级测试 企业混淆了自动化和测试 很多企业，大力推广自动化，设立测试开发岗。\n但并没有真正认识到，所谓自动化测试，更多做得其实只是检查，和真正的测试 相距甚远。\n测试开发花费了大量的时间去搭建框架、建设平台，想方设法用工具提升效率，但鲜有真正在测试思维拓展和挖掘深层质量问题上拿出成果的案例。\n对测试目标不清晰 如先前所说，认为测试就是为了验证需求的大有人在。测试人员更像是拿着检查表的“质检员”，以是否满足规格说明而非产品能否提供价值为标准。\n正是这些流行于整个测试行业的错误认知，恰恰对测试行业本身带来巨大伤害。\n但即便是削减了测试岗位以后呢？TDD，BDD，以终为始，开发其实承担了测试职责；或者让终端客户，在不知情的情况充当测试者，在客户发现问题后想办法去快速修复。\n所以并不是测试已死，只是执行测试的责任方和职责划分出现转移。\n什么样的“测试”才真的应该消亡？ 正如我之前多篇文章都强调过软件测试的真正目的。【】\n测试真正的目的既不是简单地去验证需求，也不仅只是为了发现Bug。\n测试和检查 也应该有着明确的区分。随着技术的进步，那些测试中的 检查 才是应该逐渐从测试职责中逐渐弱化的部分。\n而自动化测试，那些测试用例清单和CI仪表盘上的绿色进度条，其实并不能算是真正地在面向质量进行测试，带来的只有虚假的安全感。\n这些按照既有脚本进行逐项Check的\u0026quot;勾选框活动\u0026rdquo;，才是真正应该区分于测试，应该消亡的那部分。\n把大量的时间用于编写、维护这些形式化的测试用例、测试脚本，反而减少去探索产品、洞察风险的真正测试时间，实际上，正是在伤害测试的真正价值。\n自动化测试 vs 真正的测试 我们必须澄清如下核心认知：\n自动化测试：通常只用于检查已知的部分，即我们预期系统完成的行为。 真正的测试？是关于未知的。它是需要调查、探索、设问、推理、试验、求证的技术。没有脚本或AI能够完全替代。\n真正的测试价值永远应在于探索未知，是去发现那些通过自动化无法预见的问题\n测试价值的重新定义 测试不仅仅是关于发现bug，也不仅仅是关于工具。它的价值应该包括：\n理解产品风险：识别可能影响用户或业务的潜在问题 沟通不确定性：清晰传达关于产品质量和风险的发现 建模用户行为：预测真实用户如何与系统互动 发现他人遗漏的问题：提供独特的视角和洞察 这些价值在任何软件开发生命周期中都是不可或缺的。当组织真正理解这些价值时，测试就必然会在软件研发过程中承担重要角色，即便不是由专职测试人员，也会由开发人员或其他角色来完成。\n结论 测试从未消亡，只会不断重生!\n\u0026ldquo;测试已死\u0026quot;的论调每隔几年就会出现一次，但测试从未真正消亡。 它只是在不断演变——从手工测试到自动化，从独立角色到分布式责任，从验证已知到探索未知。每一次演变都是测试适应新环境、新技术的结果。\n今天，当我们面对AI的浪潮时，同样的故事正在重演。有些人预言AI将取代测试人员，但历史告诉我们，技术会改变测试的方式，但不会消除测试的需求。AI可以自动化更多任务，但人类测试者的批判性思维、创造力和系统思维仍然不可替代。\n测试的未来不在于抵抗变化，而在于拥抱进化。测试人员需要发展新技能，采用新工具，但更重要的是，要坚守测试的核心价值——探索未知，评估风险，保障质量。\n","date":"2025-07-30T18:00:11+08:00","image":"https://chengxiaqiucao.github.io/post/116-%E6%B5%8B%E8%AF%95%E5%B7%B2%E6%AD%BB10%E5%B9%B4/Pasted-20250730-1_hu_d2a42991931bea71.png","permalink":"https://chengxiaqiucao.github.io/post/116-%E6%B5%8B%E8%AF%95%E5%B7%B2%E6%AD%BB10%E5%B9%B4/","title":"十四年后，再谈“测试已死”"},{"content":"\n之前的文章，我们曾经分析过热门AI测试工具 Midscene.js 的源码，重点了解了它驱动AI执行的主要提示词是如何设定的。文章参见 【】\n而近日，我又发现了一个AI神器，由智谱AI 推出的源码解析服务，通过网址\nhttps://zread.ai/\n即可访问。作为一个中国公司的产品，对中文有着良好的支持。\n工具使用 访问首页以后，就是一个典型的AI应用界面。\n我们只需要将需要分析的源码项目Github地址输入检索框，如果项目已经被索引，那么回车后就会显示该项目的概要卡片。\n或者更直接的，我们可以直接将源码地址中的github.com 替换为 zread.ai，比如针对 Playwright这个项目的分析，直接访问下面的地址就可以\nhttps://zread.ai/microsoft/playwright\n而分析的信息页面，内容非常全面，包括安装部署、架构分析、核心模块等待。下图就是 Playwright 的架构分析页面\n通过索引生成的分析内容，我们可以快速了解这个开源项目的全貌和最核心的用法和关键所在。\n通过AI的继续加持 出来工具本身针对源码的索引分析解结果，借助它内置的大模型集成，我们还可以继续针对性地对项目进行深入分析和了解具体内容。\n可以通过它 Ask AI这个功能，和AI深度沟通\n比如下面就是我请它整理出的 Playwright 最近4个版本中的重点更新和应用\nPlaywright最新4个版本（1.53、1.52、1.51和1.50）的重要功能更新如下：\n1.53版本 Trace Viewer和HTML Reporter更新\n新增了测试步骤显示功能，使测试执行过程更加清晰可见 HTML报告工具新增自定义测试运行标题选项，方便区分不同的测试运行批次 1 reporter: [[\u0026#39;html\u0026#39;, { title: \u0026#39;Custom test run #1028\u0026#39; }]] 新增Locator.describe方法\n允许为定位器添加描述信息，在追踪查看器和报告中显示，提高测试可读性 1 const button = page.getByTestId(\u0026#39;btn-sub\u0026#39;).describe(\u0026#39;Subscribe button\u0026#39;);await button.click(); 浏览器版本升级\nChromium 138.0.7204.4 Firefox 139.0 WebKit 18.5 1.52版本 新增断言方法toContainClass\n简化了对元素类名的断言操作 1 await expect(page.getByRole(\u0026#39;listitem\u0026#39;)).toContainClass(\u0026#39;done\u0026#39;); Aria快照增强\n新增/children属性用于严格匹配 新增/url属性用于链接验证 测试工程配置改进\n新增workers属性控制测试项目的并发工作进程数 新增failOnFlakyTests选项用于CI/CD环境中确保所有测试稳定运行 重要变更\nGlob URL模式不再支持?和[]，推荐使用正则表达式 Route.continue不再允许覆盖Cookie头，需要使用BrowserContext.addCookies 1.51版本 IndexedDB存储状态管理\n新增对IndexedDB内容的保存和恢复支持，对使用Firebase Authentication等服务的应用很有用 1 await page.context().storageState({ path: authFile, indexedDB: true }); 错误提示增强 - \u0026ldquo;Copy as prompt\u0026rdquo;\nHTML报告、追踪查看器和UI模式中的错误新增\u0026quot;Copy prompt\u0026quot;按钮 一键复制预填充的LLM提示，包含错误信息和有用的上下文 可见元素过滤\nLocator.filter方法新增visible选项，只匹配可见元素 1 const todoItems = page.getByTestId(\u0026#39;todo-item\u0026#39;).filter({ visible: true }); Git信息集成\n新增captureGitInfo配置，可在HTML报告中显示Git提交和差异信息 1.50版本 测试步骤改进\n新增test.step超时选项，允许单独设置步骤的最大运行时间 新增test.step.skip方法，可禁用特定测试步骤的执行 1 await test.step(\u0026#39;a step\u0026#39;, async () =\u0026gt; { // 这个步骤可以独立于测试超时}, { timeout: 1000 }); 无障碍测试增强\n扩展了toMatchAriaSnapshot方法，允许在单独的YAML文件中存储快照 新增toHaveAccessibleErrorMessage断言，用于验证元素的aria错误消息 快照更新策略改进\n新增updateSnapshots的changed选项，只更新已更改的快照 新增updateSourceMethod选项，定义源代码更新方式，增加了overwrite和3-way模式 UI更新\n改进HTML报告中的附件显示 Codegen添加生成aria快照的元素选择按钮 追踪显示中增加了操作API调用的详细信息 这些更新共同提升了Playwright的测试能力、调试体验和报告功能，使自动化测试更加可靠和高效。\n主动索引和私有仓库 除了比较热门的开源项目，Zread 已经提前完成索引，一些新的项目或个人项目，如果没有完成所以，输入项目地址后也可以主动发起索引，稍待片刻也即完成分析\n比如下面就是我前段时间开源的测试练习项目，主动发起索引\n很快就得到了针对这个项目的完整介绍和核心代码分析\n对于一些非公开的私有仓库，也可以通过授权的方式，将代码读取权限开放给 Zread.ai, 同样可以实现以上目的。\n总结 总之，这个工具对于我们快速了解一个开源项目，绝对是一个强力的助手，强烈安利一下~~\n","date":"2025-07-28T16:50:34+08:00","image":"https://chengxiaqiucao.github.io/post/115-zread_ai/title_hu_c767d5046278ab2d.png","permalink":"https://chengxiaqiucao.github.io/post/115-zread_ai/","title":" 快速理清开源项目源码的神器，这款AI工具不可不知！"},{"content":"\n当AI编写应用程序，是质量的福音还是挑战？ 随着 AI 模型的能力越来越强，以Copilot、Cursor、Claude Code、Gemini Cli等为代表的AI编程工具开始逐渐进入软件开发的日常使用，“vibe coding”越来越成为应用开发的趋势。\n那么当AI越来越多地参与进实际应用程序的开发，对于基于这种方式完成的应用程序质量来说，到底是好是坏呢？\n本篇就结合笔者近期使用多款氛围编程工具的体会，谈谈看法。\nAI编程，看上去很美好 从接触AI编程开始，很多人都会惊叹于它极速、高效的强大能力，而且通常结合良好的提示词工程，能在极短时间内完成原型设计，得到的成品也往往能超出预期地功能完备。\n只要我们对软件应用开发有所了解，结合提示词工程，从前端、后端到数据库，AI 都能帮我们完成从设计到代码的全部工作。工程师需要做的，似乎就是不断地和AI完成沟通，对输出的结果进行不断地优化和调整。\n可以说，AI编程工具的出现，让很多非程序员也能完成很多创意应用的开发，大大降低了软件开发的门槛。\n在各大软件开发企业中，开发工程师借助AI工具辅助完成越来越多的代码，也逐渐成为常态。\nAI编程的未来，这么近，那么美~\n但是，如果不是验证原型目的，要按一个生产级应用的标准来要求AI开发的应用程序，那么复杂、痛苦的调试过程却必然不会缺席。\n“开发十分钟，调试两整天” 其实更是结合AI编程的常态。\n让人无语的 AI 脑补 虽然“提示词工程”总结和强调了和AI合作的一些最佳方式，但实际工作中，很多时候，工程师还是会倾向用简洁的指令和AI交流。\n而在这种指令信息不充分和精确的时候，AI 自然会脑补出很多它认为必要、但实际却似是而非的代码。这时，工程师必然需要花费大量的时间去检查和调整AI的行为。\n通过AI来进行编码实现的同学，应该都有因为部分基本的逻辑或前端界面调整，结果耗费了大量时间的经验。\n比如笔者就遇到过，仅仅是希望在页面表单中增加一个字段，同时后端数据库也同步进行调整的改动，AI却总是会错义，不是没同步就是去改动不相干的其他表单，反复拉锯，耗费大量时间。\n本来就是两行代码的事，却因为自己不熟悉AI生成的代码结构，依赖AI反复修改，虽然最后也达到了效果，却又无谓插入了大量的“屎山”代码。\n集成和解耦性上的不足 AI生成代码，一般会首先根据初始需求确定好项目代码结构，然后再根据具体的拆分任务完成代码的填充。\n但随着项目进行和需求的不断优化，通常会将主要逻辑集中在部分主文件之中，很容易导致一些主文件过于臃肿。而AI依赖大模型的能力，通常又存在上下文窗口的限制，臃肿的文件对于代码的生成效率和成果又有很大制约。\n所有随着需求的不断细化和调整，代码越来越臃肿，也越来越混乱。很少会像实际工程中那样进行适当的解耦和重构，AI本身对代码的理解往往变得越来越困难，很难再有初始时的惊艳感。\n这时，工程师的干预就必不可少，否则，AI编码更像是在“屎上雕花”。\n所见未必所得 AI生成的代码，为了及时呈现成果，有时还会“作弊”，对一些数据效果的呈现进行硬编码。\n也许初期为了展示成果，必要的模拟数据必不可少。但区分硬编码和正确处理逻辑却并不能完全相信AI。\n笔者曾在一个AI辅助编写的工具中，向它指出当我录入某条特定数据后，实际效果和预期不符。结果AI在假模假式分析半天以后，告诉我找到原因。但我实际检查代码，竟发现它在这部分的处理，居然是针对这条特定数据做了个if判断，强制特殊处理拉倒。\n对质量的挑战 所以通过以上的说明（吐槽），虽然AI在辅助编码上成效惊人，而且不乏和工程师配合良好的案例。但很多基于AI辅助生成的应用，并不能消除质量堪忧的疑虑。\n或许AI本身还会帮你生成单元测试，但就像智能驾驶依然不能代替人类决策，在质量这个领域，人类测试工程师的作用，依然不可替代，甚至在AI应用越来越多的情况下，人工测试的重要性还越来越凸显。\n代码本身的质量 复杂应用的整体规划和大范围上下文理解 可扩展性、性能、安全性等方面的不足 模拟数据、硬编码 测试工程师如何应对 那么针对AI生成应用的质量挑战，测试工程师也应该针对性地进行对它的输出进行测试和验证\n可以从如下几方面重点考虑：\n传统标准的系统验证 作为一个产品，测试首先自然还是应该从需求和产品目标、用户使用角度去测试AI应用的成品，确保符合产品需求和质量标准\n产品集成度、可扩展性、性能、安全 针对AI代码的薄弱环节，从产品集成度、可扩展性、性能、安全等场景重点考虑，针对性测试\n从黑盒到白盒 AI错觉的存在，要求测试工程师，不仅从黑盒角度去验证应用，也应该关心AI生成应用的过程，特别是工程师开发过程中，相关的提示词、上下文以及AI的响应记录，都是了解潜在质量问题的来源。很多如硬编码问题，可能就隐藏在一些误导的交互中。\n拥抱AI，用魔法打败魔法 AI虽然还存在很多问题，错误的使用可能得到糟糕质量的产品。但使用AI得当，却也能切实提供很好的帮助。\n利用AI，我们可以分析产品代码、梳理项目架构，帮助我们更好去理解项目的实现，包括基于AI去辅助完成包括自动化测试在内的很多测试工作。\n总结 总而言之，良好质量的产品，离不开成熟的团队和规范的流程。对于测试人员来说，AI时代也在重新定义我们角色的机会。拥抱AI驱动开发的挑战，测试人员也会是不可或缺的参与者和合作者，拥抱AI，也拥抱未来！\n","date":"2025-07-24T16:49:36+08:00","image":"https://chengxiaqiucao.github.io/post/114-test_ai_coded_app/AI_check_hu_5871fb0d7155c2c1.png","permalink":"https://chengxiaqiucao.github.io/post/114-test_ai_coded_app/","title":"当AI编写应用程序，是质量的福音还是挑战？"},{"content":"前言 PyTest 是目前自动化测试领域使用非常广泛的一个测试框架，基于Python脚本的自动化，通常都会结合该框架完成测试脚本的管理和运行调度。\n而Pytest之所以强大，除了前面我们介绍过它的Fixture夹具功能，还有一个很重要的方面就是它强大的生态，也就是它非常强大的插件支持。仅官方显示的插件清单已有1600多个\n而实际工作中，除了通过Pytest丰富的插件生态完成增强外，对于我们的一些个性化需求，我们要自行完成插件开发其实也非常方便，当然这也是Pytest 插件生态能如此繁荣的基础。\n本文我们就结合一个基本案例介绍下如何完成Pytest的本地插件开发。\nPytest 插件的实现原理 Pytest的插件机制，其实主要是通过它提供的钩子函数(hook)和命令行扩展来实现的。\n钩子函数 钩子函数是 Pytest 提供的一类特殊函数，允许插件在特定的测试事件发生时执行自定义代码。常用的钩子函数包括如：\npytest_addoption: 用于添加命令行选项。 pytest_configure: 在测试运行之前进行配置。 pytest_runtest_setup: 在每个测试用例执行之前调用。 pytest_runtest_teardown: 在每个测试用例执行之后调用。 pytest_sessionfinish: 在测试会话结束时调用。 命令行选项 通过 pytest_addoption 钩子，插件可以定义自定义的命令行选项。这使得用户在运行测试时可以控制插件的行为。例如，可以添加一个选项来启用或禁用某些功能。\n配置对象 在钩子函数中，插件可以访问 Pytest 的配置对象（config），该对象包含命令行选项、测试上下文和其他配置信息。通过配置对象，插件可以获取用户输入的选项并相应地调整其行为。\n数据存储 插件可以在钩子函数中使用配置对象来存储和管理数据。例如，可以在 pytest_configure 中初始化一个列表，在每个测试用例执行后将数据存储到这个列表中，最终在 pytest_sessionfinish 中输出结果。\nhookimpl 装饰器 Pytest中，钩子函数可以使用 @pytest.hookimpl 装饰器来控制钩子的执行顺序和行为。主要参数包括：\ntryfirst: 如果设置为 True，该钩子将在其他同类钩子之前运行。通常在需要优先处理特定逻辑时使用。 trylast: 与 tryfirst 相反，设置为 True 则该钩子将在其他同类钩子之后运行。 通过这种方式，插件可以精确控制在测试执行过程中的各个阶段插入自定义逻辑。\n实操案例 本文我们将开发一个本地的Pytest 插件，用来记录每个测试用例的执行时间，并在测试结束后提供汇总统计信息。\n环境准备 创建一个新的目录用于你的插件：\n1 2 mkdir pytest_timing_plugin cd pytest_timing_plugin 插件实现代码 在插件目录中，创建一个名为 pytest_timing_plugin.py 的文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # pytest_timing_plugin.py import pytest import time def pytest_addoption(parser): parser.addoption(\u0026#34;--timing\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;Enable timing report\u0026#34;) @pytest.hookimpl(tryfirst=True) def pytest_configure(config): if config.getoption(\u0026#34;timing\u0026#34;): config._timing_data = [] config._total_duration = 0.0 @pytest.hookimpl(tryfirst=True) def pytest_runtest_setup(item): if item.config.getoption(\u0026#34;timing\u0026#34;): item.start_time = time.time() @pytest.hookimpl(tryfirst=True) def pytest_runtest_teardown(item): if item.config.getoption(\u0026#34;timing\u0026#34;): duration = time.time() - item.start_time item.config._timing_data.append((item.nodeid, duration)) item.config._total_duration += duration @pytest.hookimpl(tryfirst=True) def pytest_sessionfinish(session, exitstatus): if session.config.getoption(\u0026#34;timing\u0026#34;): print(\u0026#34;\\nTiming Report:\u0026#34;) for test_id, duration in session.config._timing_data: print(f\u0026#34;{test_id}: {duration:.4f} seconds\u0026#34;) print(f\u0026#34;Total Duration: {session.config._total_duration:.4f} seconds\u0026#34;) pytest_addoption: 添加 --timing 选项来启用时间记录。 pytest_runtest_setup: 在每个测试开始时记录开始时间。 pytest_runtest_teardown: 在每个测试结束时计算并记录持续时间，并累加到总持续时间。 pytest_sessionfinish: 在测试会话结束时打印每个测试的执行时间报告以及总执行时间。 准备测试文件 在相同目录下，创建一个测试文件 test_sample.py：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # test_sample.py import time def test_example_1(): time.sleep(1) assert True def test_example_2(): time.sleep(2) assert True def test_example_3(): time.sleep(1.5) assert True 打包插件 如果我们希望将插件分享给其他人，可以将其进行打包。创建一个 setup.py 文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # setup.py from setuptools import setup setup( name=\u0026#39;pytest-timing-plugin\u0026#39;, version=\u0026#39;0.1\u0026#39;, description=\u0026#39;A pytest plugin to measure and report test execution time\u0026#39;, py_modules=[\u0026#39;pytest_timing_plugin\u0026#39;], entry_points={ \u0026#39;pytest11\u0026#39;: [ \u0026#39;timing_plugin = pytest_timing_plugin\u0026#39;, ], }, ) 在插件目录下，运行：\n1 pip install . 即在本地Pytest环境中包含了我们刚才开发的插件了。\n运行测试 使用 pytest 命令运行测试，同时传递自定义选项：\n1 pytest --timing 运行结果：\n发布插件 而如果我们希望在更大范围，公开发布我们开发的插件，可以发布到 PyPI 上，得到更广泛传播和应用。\n发布准备 安装相关发布工具：\n1 pip install setuptools twine setuptools: 用于打包 Python 项目 twine: 用于上传包到 PyPI 并将代码上传到开源平台如Github\n准备setup.py 补充内容如下，包含源码项目：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # setup.py from setuptools import setup setup( name=\u0026#39;pytest-timing-plugin\u0026#39;, version=\u0026#39;0.5\u0026#39;, # 更新版本号 description=\u0026#39;A pytest plugin to measure and report test execution time\u0026#39;, py_modules=[\u0026#39;pytest_timing_plugin\u0026#39;], entry_points={ \u0026#39;pytest11\u0026#39;: [ \u0026#39;timing_plugin = pytest_timing_plugin\u0026#39;, ], }, author=\u0026#39;城下秋草\u0026#39;, author_email=\u0026#39;your.email@example.com\u0026#39;, url=\u0026#39;https://github.com/chengxiaqiucao/pytest-timing-plugin\u0026#39;, classifiers=[ \u0026#39;Programming Language :: Python :: 3\u0026#39;, \u0026#39;Framework :: Pytest\u0026#39;, \u0026#39;License :: OSI Approved :: MIT License\u0026#39;, ], ) 创建 README 创建一个 README.md 文件，描述插件的功能和用法。\n构建分发包 在插件目录下，运行以下命令以生成分发包：\n1 python setup.py sdist bdist_wheel 这会在 dist 目录中生成 .tar.gz 和 .whl 文件。\n发布到 PyPI 使用 twine 上传包到 PyPI。首先，当然我们首先需要在 PyPI 拥有一个账户。\n然后，运行以下命令：\n1 python -m twine upload dist/* 按要求输入PyPI 的API Token，完成上传\n完成后 PyPI 官网即可查询到该插件\n验证安装 上传成功后，可以通过以下命令在其他环境中安装插件：\n1 pip install pytest-timing-plugin 更新插件 如果需要更新插件，只需在 setup.py 中更新版本号，重新生成分发包，然后再次使用 twine 上传即可。\n以上就是关于 Pytest 插件开发的实际案例分享\n","date":"2025-07-22T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/022-pytest%E7%9A%84hook%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%94%A8%E9%80%94/Pasted-20250721-2_hu_5e359476e282c453.png","permalink":"https://chengxiaqiucao.github.io/post/022-pytest%E7%9A%84hook%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%94%A8%E9%80%94/","title":"本地定制Pytest插件及发布指南"},{"content":" 初入职场，总感觉自己被领导边缘化了，心态有点崩，该如何调整自己呢？\n所谓人生不如意十有八九，很多同学初入职场，空怀满腔抱负，但不得施展，很容易觉得自己不受重视甚至被刻意边缘化，导致心态失衡，苦闷不已。\n本篇我们简单聊聊这个话题。\n是否真的被边缘化了？ 大部分人从小到大，在求学阶段，多数情况下行为路径都是清晰的，努力学习就可以拿到成绩，做什么事拿到什么结果，多半能符合预期。\n而走向职场，踏入社会，情况却不那么一样。努力付出，积极做事，可结果却未必符合自己的期望。不但没有收获领导的肯定，甚至被泼冷水，很容易感到自己被针对，被边缘化。\n那么，这种真的是被边缘化了吗？\n首先还是要相信，所谓边缘化，在一个团队中，并不是常见的现象。\n人很多时候是习惯以自我为中心的，会习惯以第一视角来看待周边事物，关注周围对自己行为的反馈；也习惯按自己的固有思维和理解去做事，一腔热情，却未必会有喝彩。\n其实，转换视角来思考，站在领导或团队的视角来看，往往很容易发现问题。你的“努力付出、积极作为”是否真的是对团队有价值的？\n华为曾经有一个刚入职的北大研究生，甫一入职，就给任正非写了一份洋洋洒洒的万言书，大谈公司未来发展建议。\n任正非批复：此人如果有精神病，建议送医院治疗，如果没病，建议辞退\n还是以团队角度来看，其实任何团队，资源永远都是紧张的，而人力资源其实尤为宝贵。实际上也没有哪个领导喜欢将能用之人放到冷板凳。\n所以，很多情况下，所谓“被边缘化”很可能只是自己心理落差下造成的错觉，更多时候找到症结，完成调整就可走出。\n如何调整？ 那么如何让自己更好适应团队，找到位置呢?\n其实就是前面说到的，让自己的个人价值和团队价值统一到一个方向上\n如果所谓的边缘化，更多是因为自己还没有发挥出应有的价值，那么就找到对应的原因进行针对性改进。\n没发挥出价值，可能原因有多方面：\n业务能力问题：努力提升自己的业务水平，虚心学习 协作性方面：团队工作，不能特立独行，保持和队友的顺畅合作。 个人原因：简单来说，就是自视过高，眼高手低了。自以为自己应该在某个位置，但实际才干和号召力还达不到。 而要确定症结所在，除了自己的观察和尝试，更有效的方式，其实是和领导的直接沟通。\n了解领导（团队）对自己的预期，搞清楚自己岗位、承担的工作定位和有效产出是什么，再针对性做出改变。\n真的是被边缘化 当然，有人的地方就有江湖，也不排除自己确实被领导认为不堪栽培，真的被边缘化的情况。\n但即便这样，其实也不要太过灰心，还有余地。\n因为就团队中成员的不同情况来看，被边缘化可能还不算最坏的情况\n一个团队中，成员的区分大概可以分下面几种：\n高价值的员工，可以负责关键工作，核心业务。会有各种激励上的倾斜 普通价值的员工，主要负责常规工作，辅助核心业务的完成，拿团队的正常激励。 低价值员工，也就是“被边缘化”员工，通常会做些无关紧要，不影响团队发展的工作。很少获得激励 负面价值员工，这是待淘汰的员工，需要尽早被清理出团队。 而被边缘化，虽然在团队中比较危险，但还不至于淘汰，可以说处在观察期。\n这时通过和领导的直接沟通，找到自己和团队预期的偏差所在，针对性完成改变，就有机会回归正确位置。\n自然，另一种情况是通过沟通，发现结果并不能改变：\n团队对自己的定位，并不是自己想要的，也不愿意去匹配团队的期望 个人的价值观和团队(领导)的价值观本身就差别较大，简言之，三观不合。 对个人的局限性过高，影响自己进一步发展。 这时，要么自己调整心态，安于被边缘化，无欲则刚；要么悄悄生长，等待机会，厚积薄发，另寻良栖之所。\n结语 总而言之，职场中感到“被边缘化”，勿焦虑，很多时候其实并非自己以为的情况。和上级好好谈一谈，搞清症结所在，转机或许就在眼前。\n","date":"2025-07-20T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/113-%E8%A2%AB%E8%BE%B9%E7%BC%98%E5%8C%96/Pasted-20250720-1_hu_33b5ade927b0f5ff.png","permalink":"https://chengxiaqiucao.github.io/post/113-%E8%A2%AB%E8%BE%B9%E7%BC%98%E5%8C%96/","title":"职场中被领导边缘化？要怎么调整"},{"content":"前言 随着 AI 大模型的爆发，提示词工程（prompt engineering ） 一度是用户应用 AI ，发挥 AI 能力最重要、也最应该掌握的技术。 但现在，在 “提示词工程”的基础上，一个更宽泛也更强力的演化概念被提出，也就是本文我们要介绍的 “上下文工程（Context Engineering）”\n特别是今年以来，随着 AI Agent的爆发，在应用 AI 时，将哪些信息有效传递给 AI “有限的记忆空间”变得越来越重要。很多时候，调用 AI Agent 效果不佳，并不是大模型本身的能力不佳，更多是上下文的质量有所欠缺。\n提示词工程的局限性 提示词工程 通过优化输入给模型的文本，可以优化模型的输出质量。\n但随着越来越多Agent的加入，以及应用场景的复杂化，仅依靠提示词，已经很难让大模型有效完成 越来越复杂的任务。\n比如要完成一个AI智能测试用例系统，在利用大模型的过程中，还需要如下信息：\n原始的需求文档、接口文档信息 系统的架构设计、数据库、系统框架 各种应用接口的状态 和用例管理、文档管理、自动化测试等外部工具的调用。 这些要求，仅仅通过向大模型和对应的Agent传递提示词，已经很难完成。\n这也就是提示词工程最大的局限性：缺乏上下文理解与状态管理能力。\n何为上下文工程？ 要理解“上下文工程”，先要明确，何为上下文？\n相比提示词（prompt），上下文（context） 并不仅仅是我们传递给大模型的单一的提示词，可以认为是大模型在返回结果前，它所看到的一切信息\n总结来说，上下文 包含如下一些内容：\n背景介绍/系统提示词(**Instructions / System Prompt) 这是用户和大模型在整个会话期间的初始约定。包括约定背景、大模型充当的角色、它的期望行为等。可以通过一些示例和规则定义进行约束。\n比如我们之前介绍过的通过AI来编写测试用例生成工具，系统提示词可以约定\n1 2 3 4 5 6 7 8 你是一个资深测试开发专家，负责根据用户提供的接口文档，调用本地配置的AI大模型，生成一组详细的测试用例。 你需要确保每个测试用例都具有明确的目标、输入参数、预期结果。 请按照指定格式输出JSON数组，每个条目包括： - test_case_id: 测试用例编号 - description: 测试描述 - input_params: 输入参数 - expected_output: 预期输出 - priority: 优先级（1-5） 用户提示词(User Prompt) 用户提示词，相对系统提示词是作用于整个会话来说，是用户当前告知AI大模型的指令或提出的问题。\n它其实就是之前说到提示词工程的主要应用，通过优化用户提示词的编写，可以和AI完成更有效的沟通。\n如上例，在AI辅助开发的过程中，我们向AI提交的具体开发任务。\n1 根据之前生成的项目代码结构，完成数据库创建部分的脚本，并注入部分调试数据。 状态及对话历史（短期记忆） 主要指在当前会话过程中，产生的对话历史和生成的中间结果。\n比如在脚本开发过程中，完成的代码文件，程序运行出现的错误等信息。\n长期记忆 这里包含更持久的背景知识，包括之前多次的对话信息收集，如已学习到的用户偏好、过去项目的总结，或者由用户告知、以备将来使用的信息。\n如上述开发过程，包括项目的需求文档、架构设计、数据库结构、测试数据等信息。\nRAG(检索增强生成，Retrieval-augmented generation ) RAG是通过向量数据库、知识库检索等方式，为模型提供额外的相关信息。它让模型能够在回答问题时参考最新的、相关的上下文，而不是依赖于训练时的知识。\n结构化输出 为了让模型输出更加可控和可解析，并便于 Agent 的处理，我们通常需要定义输出格式，例如 JSON Schema 或特定字段结构，提高结果一致性。\n例如之前的系统提示词，明确要求模型输出一个包含相关字段的 JSON 对象。\n可用工具 通过 Agent 或 MCP， 大模型可以调用工具能力，比如自动化测试工具（Playwright）、CI/CD持续集成系统等等\n使用上下文工程的关键 ✅ 上下文不是一个字符串，而是一个系统\n上下文是运行在 LLM 调用之前的系统逻辑，它动态组装所有相关信息，而不是一个静态模板。\n✅ 上下文是动态的\n每次调用 LLM 之前，都要根据当前任务动态准备上下文，例如注入当前日期、用户偏好、项目配置等。\n✅ 上下文强调信息与工具的精准匹配\n不能简单堆砌信息，而是要在合适的时间提供最相关的知识和能力。例如，只在需要时注入数据库连接工具。\n✅ 格式决定输出质量\n如何呈现信息很重要。简洁的摘要比原始数据更好，清晰的工具 schema 比模糊的说明更有用。\n结语 科技行业，每隔一段时间就会产生新名词、新概念，大家已经见怪不怪。“上下文工程” 虽然概念上和 ”提示词工程“ 有所区别，但它们的出发点和目标其实是一致的，就是让用户和AI实现更有效的沟通。本质上跟我们前文 【】中的解释是一脉相承的。\n它其实并不是一个新兴的技术，我们把它理解成使用AI的技巧就好！\n","date":"2025-07-14T15:58:57+08:00","permalink":"https://chengxiaqiucao.github.io/post/112-context_engineering/","title":"用好AI的新风向，从提示词工程到上下文工程"},{"content":" 有小伙伴问，做测试的，是不是真的比不上开发？\n虽说各有各的看法，但我们思考下提出这个问题背后代表的主流观点，还是值得探讨一下的。\n下面就谈谈秋草的看法。\n测试技术和开发技术并非同一赛道 首先，要真正做好测试这个岗位，技能要求其实是挺高的。但测试技术和开发技术不是一个维度的技术，开发者拿软件开发技能比对吐槽测试者，就好比篮球运动员吐槽游泳运动员跑得慢。\n测试技术包含很多和开发技术并不相同的要求，具体可以参看我之前另一篇文章【】， 这里不再赘述。\n对测试评价不高的现实原因 但我们也要看到这样的客观事实：在大部分企业，测试岗位的话语权、薪资等等，相比同级别的开发者，通常是低一档的。\n而导致这种情况的形成，其实有多方面原因，主要还是对岗位的普遍认知，以及比较恶劣的行业环境。具体说来：\n工作要求和预期产出的不匹配 首先，目前大多的测试岗位要求，其实是围绕验证需求，包括测试用例设计、自动化测试实现，都是基于对已有需求的验证。\n但验证需求，其实更多是检查工作，而非测试工作。\n检查作为测试的子集， 其实要求较低，技术含量要求也不高。相应地，围绕需求验证的岗位要求，其实是一个低技术含量要求的岗位。\n但矛盾点在于，对于测试岗位的预期，是保障产品发布后的全面质量。而产品质量的覆盖要求，仅仅通过需求验证是完全无法达到的。\n需求的验证，主要是功能覆盖，而且通常还只包含基本场景，缺乏各种异常场景以及各种非功能场景。要达到质量覆盖，必须要靠研发阶段全流程的质量控制，包括在测试阶段的测试工作。 这里的测试，不仅仅是基本的检查， 还要包含更多不同测试技术去加持的主动发现。 而工作要求和预期产出的不匹配，也导致对测试岗位的工作效果的质疑。\n较低的工作要求导致较低的行业门槛 当工作要求本身主要针对较低技术含量的检查工作，那么当然也会降低从业门槛，很多没什么经验和技术的小白也可以入行来完成相关的检查工作。\n早些年甚至还有测试设计工程师和测试执行工程师的区分，这里的测试执行，更是只需要参照用例完成操作，记录结果即可。这种最基本的检查工作，确实谈不上需要多少测试技术。\n较低的技术水平和岗位要求，自然会影响对这个岗位的整体评价。\n行业本身的误导 IT行业前些年的快速发展和较好的待遇水平，让IT成为热门就业选择。而因为上面说到的原因，当较低技术含量的检查工作被披上测试工作的外衣，这样的测试岗位，就成为非IT人员进入这个行业最好的入门渠道。\n大量希望进入这个行业的非IT专业人员，又引出了很多培训需求。\n于是经过各类培训机构的推波助澜，包括鼓吹0基础入行，小白也能高薪。也确实输送了大量人员进入行业，而这些短期速成的“人才”，在工作中的表现，也当然影响了对行业的整体评价。\n行业寒冬下的重灾区 随着IT寒冬的到来，企业在成本压力的情况下，压缩开支，削减人员，前述种种因素的叠加，又让 测试成为重灾区，恶性循环，大家对于测试这个岗位的普遍看法还在进一步背离它应有的价值。\n写在最后 就客观事实来说，确实现在国内所谓的“测试行业”大量从业者普遍难称合格， 说比不上开发岗位也没错。\n但这里的“测试”岗位是打了引号的，检查和测试，混为一谈。\n总而言之，当前整个测试行业的整体环境比较恶劣，误解较深，秋草也深感无力。\n不过也毋庸灰心，围绕岗位真正的目标去打造自身能力，为全面质量提供真正的价值，自然会是大潮褪下时，能依然站立的那个。\n","date":"2025-07-13T11:26:50+08:00","permalink":"https://chengxiaqiucao.github.io/post/111-%E6%B5%8B%E8%AF%95%E5%92%8C%E5%BC%80%E5%8F%91%E7%9A%84%E6%AF%94%E8%BE%83/","title":"做测试真的比不上开发吗？"},{"content":"\n虽然随着敏捷的推广和测试左移的实行，很多测试人员已经更多和开发人员融合到一个团队，但大部分的软件企业，通常还是会独立设立一个专门的测试部门或软件质量部门。\n那么管理这样一个独立的软件测试团队，我们通常要从哪些方面着手？当然团队管理，各种类型团队其实有很大共性，但针对测试这个职能，也会反映出一些自身的特点。本文将从以下几个方面进行探讨。\n建立规范 任何团队，要形成战斗力，必要的规章制度和流程是必不可少的。\n这其中既包含一些管理规范和制度，如：\n奖惩规范 考勤规范 培训规范 工作汇报制度 等等\u0026hellip; 也包括制定一些和测试职能本身相关的技术规范和模板要求，如：\n测试计划 测试方案 测试用例 测试执行 测试报告 故障管理 环境管理 对外测试 资产管理 质量分析 等等\u0026hellip; 当然也包括和测试相关的流程梳理，如：\n缺陷处理流程 测试准入准出（提测、发布流程） 质量分析流程 等等\u0026hellip; 规范和流程的梳理、制定，是部门工作的基础。但规范的形成和完善不是一朝一夕达成的，而是在日常管理和团队协作中逐渐沉淀形成的团队共识，是有形的行为指导。\n打造能力 一个团队是否成功，战斗力如何，是由团队能力决定的。\n而针对测试团队，如何建设这种能力呢？\n测试行业参照 CMMI 模型，提出过 TMMI 模型: 初始级 默认起始级别，组织还没有相关的测试能力，测试工作粗放随意，没有单独的测试环节。\n已管理 测试工作是专门职能，有了基本的测试规范如方针、策略、计划、方案、设计、执行等等 还有像测试环境，会有单独的测试环境完成测试工作而不是在开发环境中进行相关的验证。\n已定义 到这个级别一般才代表组织在测试工作中达到了基本的成熟度。 它典型的特点就是有了专门的测试组织、通过测试团队来负责测试工作的组织和实施。 除了基本的功能测试外，这个级别下会针对各种非功能测试建立相关能力，包括性能测试、兼容性测试、易用性测试、可靠性测试、无障碍测试等等丰富的测试类型。还有会重点进行面向质量的同行评审\n已度量 可以对测试工作的成效从多个维度通过相关的度量指标和数据进行量化，能比较准确反映测试工作做得如何。\n已优化 可以做到不断地自我更新和持续优化。通过全流程的质量控制和前期分析手段，做到缺陷预防。\n除了这种业界标准，针对测试团队的能力建设，我总结下来，还可以从以下四方面重点打造：\n业务测试能力： 团队立身之本，发现问题的能力 快速测试能力： 提升效率，建立成本优势，及时建立质量信心 质量评估能力： 对质量的准确度量和监控 快速响应能力： 对质量问题和风险的快速反应 做好团队的能力建设，是建立团队护城河的根本。\n绩效度量 人在职场，努力工作说到底还是为了个人的更好发展，获取当下或长期的长远利益。趋利避害，人之常情。\n而团队管理，针对绩效的度量，其实本质就是以绩效为锚，管理好利益的分配，驱动团队整体目标的达成。\n现在企业中比较常用的绩效管理框架，主要有两种：\nKPI： 关键绩效指标 OKR：目标与关键结果 KPI 属于结果导向，重点关注一些可量化的关键定量指标 OKR 则是目标驱动，围绕目标展开，虽然它的关键结果通常也是定量的，但关注的更多还是达成目标的路径。\n而不管是 KPI 还是 OKR，团队针对绩效的管理，离不开各种绩效量化指标的制定。\n以一个测试团队来说，相关的指标主要又可以从三个不同维度来看：\n质量维度 测试团队面向质量，所以衡量绩效离不开对质量的评估。常用的一些关键指标比如：\n需求覆盖率 故障泄露率 提测打回率 发布成功率\u0026hellip;. 等等 效率维度 测试部门作为成本部门，完成质量评估的效率直接影响发布节奏，也是产品成本中的重要构成。 因此测试部门的管理，必然会包含对工作效率的相关指标，常用指标如：\n测试周期 自动化覆盖率 CI 成功率 发布效率 响应效率 \u0026hellip; 等等 成长维度 除了上面反映部门本身目标的维度之外，任何团队离不开团队成员的逐渐成长和成熟，因此面向个人和团队成长的指标也是团队管理的重要维度，常用指标如：\n知识分享、培训 技术创新、流程改进、工具开发 学习总结、活动组织 \u0026hellip; 等等 从以上不同维度，我们在团队管理时，可以结合团队现状，细分出多种更详细的细分指标，并结合绩效数据的采集和分析技术，完成科学的度量。并进而和如加薪、奖金、职级等直接利益挂钩。\n团队协作 测试团队作为一个以测试职能为主的集体，同时也是和软件产品研发其他职能如开发、运维等需要充分合作的团队，测试团队管理中另一个重要的部分就是面向团队协作的管理。\n协作离不开沟通，这里可以充分利用我前面文章如【】中介绍的乔哈里窗沟通模型，或者【】中的冲突模型作为沟通协作的辅助工具。\n而站在测试团队这个视角，其实团队协作我们也可以从四个维度来考虑：\n内部协作 这里主要是要根据不同成员的能力和性格特质，合理地做好工作安排，人尽其才，互利互赢。\n平级部门协作 平级部门间的协作，包括和开发团队、运维团队、产品团队等的合作。重在以双赢互利思想处理和平级团队的合作，尽可能做到求同存异，完善流程，安排好接口，并在产生争议冲突时维护好团队利益。\n向上协作 和上级领导或上级部门的沟通协作，是任何中层必须做好的功课。同样，不同性格特质的领导会有不同的沟通技巧和沟通方式。做好向上管理，为团队良性发展赢得空间。\n总之，在企业中，一个优秀的中层，应该是一个 “上能承压、下能服众、平级能协(si)作(bi)”的Leader。\n对外协作 除了企业内部的这些协作，测试团队其实也是一个比较会经常面向外部关系的部门，比如外包、售后支持、对外测试等等场景。\n这类协作中，团队管理要明确职权和责任范围，作为企业的代表还应维护好企业形象和利益，并维系好和外部组织的关系和建立信任。\n团队文化 最后，任何团队，如果要长期稳定和良性发展，离不开团队文化的加持。\n流程、规范、制度是有形的，重在告诉大家如何正确地做事，行为是被动的。\n而团队文化形成后，大家会自觉地按共同的价值观去做事，行为是主动的。\n文化的形成是长期的，团队管理者是文化形成的关键，一以贯之，“念念不忘，必有回响”。\n以上，就是本人关于测试团队管理五个重点维度的总体说明。 对于相关细节感兴趣的朋友，也可以关注我的测试技能系统提升课程中的管理部分，有关于这五个维度和实施的详细分析。回复 大纲 可查看课程详细目录。\n","date":"2025-07-09T15:32:15+08:00","image":"https://chengxiaqiucao.github.io/post/110-%E6%B5%8B%E8%AF%95%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/team_hu_b041110f15a258f0.png","permalink":"https://chengxiaqiucao.github.io/post/110-%E6%B5%8B%E8%AF%95%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/","title":"软件测试团队应如何做好管理？"},{"content":"背景 收到不少小伙伴的咨询，作为一个测试，是否应该在开发人员自测时提供测试用例或者测试数据？\n这是实际工作中大家经常遇到的实际困扰，特别是现在很多团队强调测试左移，要求测试提供用例、准备测试数据很常见。但同时一些团队依然在将缺陷作为KPI考核指标，而因此还引发诸多后遗症：\n开发阶段利用测试提供的用例发现了问题，势必影响测试阶段发现问题的产出 测试提供用例，后续出现问题，算开发遗漏还是测试遗漏？ 测试将用例提供给了开发，在测试阶段还有没有必要再跑一遍相同的用例？ 测试人员的价值何在？就是尽可能充分地去编写用例吗？ 测试的职责和用例的作用 之前的文章【】我们详细讨论过测试的真正目的。\n所以我们应该明确：测试的职责其实不是为了去发现bug，是为了去反映出产品质量状态。\n而在测试工作中，测试用例的主要作用，其实是帮助我们在进行测试前梳理、归纳好各种测试路径，预先根据产品需求整理好需要进行测试的要点，避免实际执行时产生遗漏。\n以上是我们谈到测试左移时，探讨用例移交的基础。\n是否应该移交用例给开发？ 从团队角度，最终必然是面向产品质量。而根据著名的缺陷和成本的关系曲线，越早发现缺陷，成本越低，交付质量信心就越强。\n所以从这个角度，测试左移，包括向开发提供测试用例，都是符合质量目标的。\n但实际操作中，团队的KPI考核导向，会影响实际执行效果。\n也就是如果像很多团队以Bug数量作为KPI，那么必然导致移交用例的效果大打折扣。\n这个KPI，其实人为割裂了开发团队和测试团队的产出：开发需要尽可能少地产生Bug，测试却要尽可能多地发现Bug。\n而测试用例、测试数据其实反映的是测试发现Bug的测试思维。将用例移交开发，会帮助开发减少Bug，但却会影响自己发现Bug的产出。\n所以在这种导向下，测试即便提供用例，也很难保证用例的覆盖。只会流于形式。\n所以从产品质量来看，作为测试角色，开发阶段提供测试用例，协助开发团队完成充分自测是岗位的义务，但要想真的落实产生效果，前提是必须取消这种按Bug数量进行考核的度量模式。\n用例未覆盖的遗漏如何界定？ 首先，必须认清一个事实：测试是不可能做到100%全覆盖的。在项目早期阶段，仅依靠需求和尚未完全完成的开发版本编写的测试用例，能覆盖到的测试场景就更为有限。\n实际工作中，即便在系统测试中，按测试用例执行发现的Bug和实际测试中探索发现的Bug相比，占比也极为有限。这也是 探索式测试 推行的出发点。\n也就是说，开发阶段，按照用例测试后，后续系统测试阶段继续发现未覆盖的问题，是一个100%的确定事件。\n那么如何保证这个阶段用例的覆盖充分呢?\n首先，还是要强调，质量是团队目标。不用纠结与界定是开发遗漏还是测试遗漏，共同目标都是减少遗漏。\n其次，测试用例应该看作是思维工具的产出，是测试思路的体现。测试提供的用例本身并不一定是全部，开发也一样应该考虑覆盖场景。\n用例的需求覆盖率和代码覆盖率是比较适合的量化指标，用来衡量这个阶段的用例覆盖情况。\n开发阶段完成自测的原则，是保证产品的需求被完整实现，不出现严重的阻塞问题，产品的主要逻辑和架构得到验证。\n达到以上目标就可以认为开发自测阶段顺利完成。而不应纠结于具体的某一个Bug在自测阶段是否覆盖。\n测试阶段是否还应使用同一套用例测试？ 经过充分自测的产品，已经执行过的测试用例，提交测试后原则上其实无需再次重新测试。也就是默认已验证过的场景，不会产生问题。\n但实际工作中，开发的自测是否充分？用例执行是否严格？包括用例本身的覆盖是否有模糊地带？ 这些其实都是未知数。\n而测试的工作职责，是需要在产品发布前，准备评估产品的质量状态。很难说经过开发自测的部分，就无需再次进行评估。\n所以，即便是用例本身没有发生变化，同一套用例也依然是需要进行复验的。当然，这里非常适合通过自动化测试来覆盖已有用例，而让测试人员的精力更多放到探索式测试上。\n测试人员的价值是否主要是输出用例？ 其实从上面的描述，我们也知道，测试在测试阶段，更重要的职责是还要完成探索式测试。测试用例本身更多是测试思维的体现，是测试思路的一种表现形式，它只是一个辅助产出。并不是测试的核心。\n对于测试来说，我之前文章中也多次提及，James Bach有个著名的论文，讨论了测试和检查的区别。按用例执行只是检查，不能算测试。真正的测试，除检查外还包含试验、研究、探索、设问、观察、推理等多方面能力，这些才是帮助我们发现更深层次产品缺陷，暴露产品质量问题的真正能力。\n所以，测试人员的价值，当然不仅仅是产生用例。而更多是揭示未知，去评估除对团队来说，还是黑盒的产品质量状态。\n","date":"2025-07-05T23:57:54+08:00","image":"https://chengxiaqiucao.github.io/post/109-dev_test_cases/dev-tester_hu_1bff02eb740923fd.png","permalink":"https://chengxiaqiucao.github.io/post/109-dev_test_cases/","title":"测试是否应该给开发自测提供用例？"},{"content":"前言 在我之前的文章 【】，我们探讨过团队协作中沟通的核心作用。现如今AI的应用越来越广泛，特别是生成式AI的强大能力，让很多工作我们其实都可以借助AI得以完成，从AI浏览器、编程助手、工作流引擎到各种MCP的接入，AI已经越来越多地参与到我们的日常工作。\n而借助AI完成工作，本质上也是一种团队协作，只是这里的协作对象变成了AI。所以在和AI协作中，核心也依然是沟通。\n所以从这个角度，本文我们来思考如何与AI更有效地完成沟通和协作\n乔哈里沟通视窗 在团队协作中，有一个重要的模型工具，就是我们之前介绍过的乔哈里沟通视窗\n在这个视窗中，我们按照沟通对象和自己对事物的认知水平，划分出四个象限。了解沟通时双方处于哪一个象限，才能更好地去完成沟通。\n而我们在和AI进行协作时，同样也可以划分出这样一个沟通视窗模型：\n开放区：这个区间对应的是我们和AI都已经具备和理解的信息，可以认为是双方的共识。比如我们和AI沟通时，往往要预设AI的角色身份，这类指令就属于开放区信息。 又或者我们已经完成的文章，请AI在文章基础上进行润色。都属于比较典型的在开放区沟通\n盲点区：这里的信息是我们本身不具备，但AI通过丰富的知识储备，可以提供给我们并不掌握的知识。这里AI就像是一个老师，但是这个老师是被动的，要靠我们主动的提问来获取知识。提问能力是这个区间沟通的要点。\n未知区：这个区间的信息是我们不清楚，同时AI也还没掌握的一些信息或知识。在这个区间的沟通，更像是和AI一起共创，通过和AI一起头脑风暴，探索出未知领域的信息。\n隐藏区：在这个区间，更多是我们私域的一些信息，AI本身无法触及，比如我们直接给AI下达指令 请帮我输出本周工作汇报，那AI自然无从下手。因此在这个区域的沟通，其实就是我们要充分提供给AI需要的上下文信息，将私域信息投喂给AI。比如我们工作中的一些项目背景、内部流程、本地数据，只有AI学习掌握了这些信息，才能进一步完成后续的辅助工作。\n和不同象限AI的沟通技巧 那么基于以上视窗模型划分出的四个不同区间，我们可以思考和AI协作时的沟通要点，也就是如何更好地应用提示词让AI给出更贴合我们需要的结果。\n开放区的沟通 这个区间，因为双方都掌握了相关的信息，更多是让AI明确这个开放区间的边界，指定信息越明确、越具体，AI的结果便越能贴合我们的需求。所以在这个区间，我们更重要的是比较明确地 下达任务。而且应避免画蛇添足，反而因为提示词指令不够明确而导致结果发散。\n比如：\n你是一名资深软件测试工程师，精通自动化测试，熟悉Python语言，熟悉各种测试工具。\n精确翻译附件中的英文文档，并用Markdown格式返回翻译后的内容，不用包含任何非目标内容的信息 就比 用诙谐、生动，贴合互联网热点的文风翻译附件英文文档 更能保留原文的内容要点而不会额外添加很多并不一定合适的补充素材，且返回的内容可以直接生成为我们需要的格式。。\n盲点区的沟通 在盲点区，是借助AI能力，最容易让我们自己得到提升的区域。通过AI，补充我们的知识不足，消除我们的知识盲点。\n这个区域，和AI高效沟通的要点，其实是提问能力。对于比较复杂的信息，我们可以通过逐步推进，递进提问的方式，让AI逐步完整地构建出知识体系，识别出我们的盲点，并加以补强。对应提示词工程中，有一个专门的技术术语 COT思维链（Chain-Of-Thought），就是可以引导AI逐步思考递进来得到我们真正需要的知识。\n这一点，也可以参考我们之前介绍过的 5Why提问法，逐步聚焦问题的根本原因。\n比如我们希望掌握自动化测试中的POM模型，并能过实际解决实施中的具体问题，就可以逐步提问聚焦解决实际问题\n什么是POM模型 POM模型更适合应用在哪些场景的自动化测试中？ 针对一个web门户站点，比如www.saucedemo.com的登录场景，给出基于Python语言来实现POM的案例并说明其中的关键 在上述案例中，还有哪些通用的方案适合用来进行统一的封装，比如元素的识别，驱动的定义？ 未知区的沟通 未知区是我们和AI都不掌握的内容，这个更多是一些创新的场景，通过和AI的不断磨合，头脑风暴，来逐步发现我们真正的需要。\n比如借助AI编程助手帮助我们开发一个应用，我们可能只构思了基本的功能，AI会根据提供的信息帮助我们生成应用界面，而我们基于它的界面还会有更进一步的改进想法，如此不断沟通和磨合，最终完成一个具备易用性的软件产品。\n所以这里的沟通，重点在共同创新、不断磨合\n隐藏区的沟通 隐藏区则是AI当前能力不能触及，很多时候是要基于内部信息、本地数据完成。这时要善用AI，就需要我们构建充分信息的上下文，把我们的本地信息、数据投喂给AI，让AI消化，弥补它不了解的那部分信息，让沟通从隐藏区走向公开区后，就可以明确下达任务来进行处理了。\n那这部分的沟通重点，其实是可以通过类似RAG、模型微调，或构建本地知识库、包括通过MCP暴露本地能力调用等方式，让AI具备触及知识盲区的能力。\n这个区域的沟通重点，就是向AI充分提供它尚未了解的背景和关联信息，在投喂并消化信息后达到正常协作的的目的。\n总结 当我们希望把AI当作一个切实能帮助到我们的协作对象时，那么我们就应该建立和协作对象良好的沟通，乔哈里窗提供了一个良好的沟通模型，可以为我们善用AI提供这方面的良好指引。\n","date":"2025-07-02T21:46:47+08:00","image":"https://chengxiaqiucao.github.io/post/107-%E5%92%8Cai%E6%B2%9F%E9%80%9A/logo_hu_747212b4de458bbe.png","permalink":"https://chengxiaqiucao.github.io/post/107-%E5%92%8Cai%E6%B2%9F%E9%80%9A/","title":"和AI的协作，重点依然是沟通，细说如何与AI更有效沟通"},{"content":"前言 大话网络协议这个系列，之前我们介绍过OSI七层模型和TCP/IP四层模型【】，也详细介绍过HTTPS协议及其实现加密通信的基本原理 【】。而现今互联网的运行，离不开HTTP协议这个基石，但HTTP协议我们目前能看到多个不同版本，如http/1.1， http/2，http/3等，那这些不同版本有何区别，具体应用场景如何？本篇我们就重点来聊聊HTTP协议中这些不同版本的异同。\nHTTP协议简介 概述 HTTP（超文本传输协议 Hypertext Transfer Protocol）位于 OSI七层网络模型中的应用层，它的核心使命是实现分布式系统间的资源传输。它和 TCP/UDP这样的传输层协议间更多是一种协作关系。\nHTTP协议，从设计之初， 就包含如下一些核心特性：\n无状态设计：服务器不保存客户端上下文信息 请求/响应模型：基于标准的请求方法和状态码 可扩展头部：通过Header字段实现元数据传输 跨平台兼容：文本协议设计确保多系统互操作性 HTTP协议负责在客户端与服务器之间传输超文本资源。作为无状态协议，HTTP不保留客户端交互记录，每个请求独立处理。通过这个协议规范，统一了Web资源访问方式，可以兼容各类操作系统和设备，并可通过头部字段实现功能扩展。 是当今互联网世界的基础协议。\n协议构成 HTTP通信基于请求/响应模型，通过TCP/IP协议栈传输：\n请求报文结构： 如：\n1 2 3 4 5 6 7 POST /api/v1/users HTTP/1.1 Host: api.example.com Content-Type: application/json Authorization: Bearer xyz123 Content-Length: 48 {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;john@example.com\u0026#34;} 响应报文结构：\n如：\n1 2 3 4 5 6 7 HTTP/1.1 201 Created Location: /api/v1/users/789 Content-Type: application/json Date: Mon, 15 Jul 2024 09:28:53 GMT Content-Length: 35 {\u0026#34;id\u0026#34;:789,\u0026#34;status\u0026#34;:\u0026#34;created\u0026#34;} HTTP方法 HTTP方法定义了对网络资源的操作语义，可以用下表总结不同http方法的应用场景\n方法 幂等性 安全性 应用场景 RESTful实践案例 GET 是 是 获取资源 查询用户信息 POST 否 否 创建资源/执行操作 新建订单 PUT 是 否 全量更新资源 更新用户资料 DELETE 是 否 删除资源 取消订单 PATCH 否 否 部分更新资源 修改订单地址 HEAD 是 是 获取头部元数据 检查资源是否存在 OPTIONS 是 是 获取服务器支持的方法 CORS预检请求 HTTP状态码 状态码是响应消息中，以三位数字表示的请求处理结果。\n类别 常用状态码 技术含义 应用场景 1xx 101 协议切换 WebSocket升级 2xx 200/201/204 成功处理 资源创建成功 3xx 301/302/304 重定向/缓存有效 永久迁移/临时跳转 4xx 400/401/404 客户端错误 参数错误/未授权/资源不存在 5xx 500/502/503 服务器错误 服务崩溃/网关错误/过载 HTTP的不同版本和演进 演进路线：\n1 2 3 4 5 6 7 timeline title HTTP协议演进 1991 ： HTTP 0.9 1996 ： HTTP 1.0 1997 ： HTTP 1.1 2015 ： HTTP 2 2020 ： HTTP 3 HTTP/0.9 (1991) 最初版本的 HTTP 协议并没有版本号，只是后来为了和后续版本区分，定义为了0.9版本。它基于Tim Berners-Lee博士为 CERN 内部文档传输设计的初始协议，也被称为单行协议（one-line）\n这个协议极为简单：\n请求：\n1 GET /mypage.html 响应只包含页面文档本身， 也不存在消息头：\n1 2 3 \u0026lt;html\u0026gt; 这是一个非常简单的 HTML 页面 \u0026lt;/html\u0026gt; 局限性也显而易见：\n这个协议无法支持复杂Web应用，仅可以传输纯HTML文档，也没有状态码反映通信状态。\nHTTP/1.0 (1996) 随着网络的发展，浏览器和服务器的应用快速增长，http协议也得到更多的应用。基于原协议增加了很多的特性，并在1996 整合到了标准文档 RFC 1945 中进行了标准化，并定义为了HTTP/1.0，但这个协议并非官方标准，是个狭义的标准化版本。\nHTTP/1.0 的核心改进：\n引入版本标识（HTTP/1.0） 新增状态码（200/404等） 支持头部字段（Content-Type/Cache-Control） 扩展方法（POST/HEAD） 通信过程如：\n1 2 3 4 5 sequenceDiagram Client-\u0026gt;\u0026gt;Server: GET /index.html (连接1) Server-\u0026gt;\u0026gt;Client: 200 OK + 关闭 Client-\u0026gt;\u0026gt;Server: GET /style.css (连接2) Server-\u0026gt;\u0026gt;Client: 200 OK + 关闭 但这个标准存在极为关键的性能开销问题：\n短连接机制，且每个资源使用独立连接，TCP握手开销大 无压缩/缓存机制 HTTP/1.1 (1997) 为了解决Web页面资源加载效率问题，从 HTTP/1.0发布之前，其实就已经在着手HTTP协议的官方标准化工作，并在1997年发布了RFC 2068（也有将 1999 年的修订版本 RFC 2616 看作HTTP/1,1标准），2014年还发布了修订版本RFC 7235\nHTTP/1.1版本非常成功，直到今天依然广为应用。它实现如下一些主要的特性：\n特性 实现机制 性能提升 持久连接 Connection: keep-alive 减少60% TCP握手 管道化 请求批量发送 理论吞吐量增加30% 分块传输 Transfer-Encoding 支持大文件流式传输 内容协商 Accept头系列 多格式资源支持 HTTP/1.1 协议为提升效率，提供了管道化机制，也就是可以让客户端向服务端同时发出多个请求来提升效率。但是这里存在的问题，就是虽然客户端效率得到提升，但是服务端依然只能一次一条来返回响应。也就是 队头阻塞(Head-of-Line Blocking) 问题\n1 2 3 4 5 6 7 sequenceDiagram Client-\u0026gt;\u0026gt;Server: 请求A (大文件下载) Client-\u0026gt;\u0026gt;Server: 请求B (小文件) Server-\u0026gt;\u0026gt;Client: 响应A处理中...（阻塞） Note over Server: 请求B已完成但必须等待 Server-\u0026gt;\u0026gt;Client: 响应A Server-\u0026gt;\u0026gt;Client: 响应B 其他局限：\n除此之外，虽然这个版本引入了压缩机制，但是对于消息头并没有提供压缩支持，依然存在较大的性能浪费。\n而且 HTTP/1.1 无状态的特性，服务端依然只能被动等待客户端提交状态信息。\nHTTP/2 (2015) 随着互联网上Web应用的丰富化和网络带宽的提升，传输内容要求也越来越高。为了进一步提升 HTTP协议的传输效率及其遗留问题，2015年基于谷歌的 SPDY 协议基础上改进发布了 RFC 7540 。\n在HTTP/2中，主要进行了以下改进：\n二进制帧：采用二进制而不是文本协议，不再可读，也不可无障碍地手动创建。 多路复用：单连接并发传输 头部压缩：通过HPACK算法对消息头进行压缩，可减少70-85%开销 服务器推送：主动发送关联资源，允许服务器在客户端缓存中填充数据 局限性：\n虽然 HTTP/2.0 提出了通过多路复用的方法来解决 队头堵塞，但实际效果并不理想，根本原因是HTTP协议是基于TCP协议之上的应用层协议，也就是即便在应用层可以通过多路复用，但在传输层，因为TCP的重传机制，依然要等待传输层的消息逐一返回，也就是在TCP层，依然存在队头堵塞。\nHTTP/3 (2020) 为了彻底解决队头堵塞问题，2020推出了HTTP/3协议，该协议最大的变化就是对协议栈进行了彻底重构，传输层不再基于TCP协议，而是基于UDP的QUIC协议\nUDP协议因为设计上没有TCP的丢包重传机制，且通信效率较TCP协议有很大提升，而QUIC重新设计的通信方式，在几乎等同于TCP连接可靠性的同时，延迟大大减少。\n目前超过95%以上的浏览器均已支持了HTTP/3协议，且30%以上的网站也已开始支持HTTP/3。\n总结 通过上述HTTP不同版本的主要区别介绍，可以概括如下：\n版本 核心贡献 主要局限 采用率(2024 ) 0.9 建立请求/响应模型 仅支持GET 0% 1.0 引入头部/状态码 短连接效率低 \u0026lt;1% 1.1 持久连接/管道化 队头阻塞 52% 2 二进制分帧/头部压缩 TCP层阻塞 96% 3 QUIC协议/连接迁移 基础设施支持待完善 39% 据Cloudflare 2024报告：全球HTTP流量中HTTP/3占比已达35%，预计2026年将成为主导协议。HTTP协议的持续演进体现了互联网基础设施对性能、安全、移动性需求的技术响应，开发者需深入理解各版本特性，构建适应未来网络环境的高性能应用。\n","date":"2025-07-01T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/040-%E5%A4%A7%E8%AF%9D%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-http%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC/Pasted-20250702_hu_bda418acac12dc32.png","permalink":"https://chengxiaqiucao.github.io/post/040-%E5%A4%A7%E8%AF%9D%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-http%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC/","title":"大话网络协议之HTTP不同版本的演进和区别"},{"content":" 模型上下文协议（Model-Context Protocol, MCP 从推出以来，备受关注并得到了快速的应用。目前大量的AI工具均已集成了对MCP的支持。（关于MCP的具体介绍，可以参见我之前的文章【】） 但随着MCP的崛起，对于他的质疑声也逐渐开始出现，比如对于它在安全方面的局限性的担忧（参见我之前的文章【】），近期 Edgenesis 创始人 Yongli,Chen 也发文认为MCP必将失败。这里将他的主要观点梳理为本文（原文参见文后链接），大家可以做个参考和判断\n导语 模型上下文协议（Model-Context Protocol, MCP） 从问世之初就备受瞩目，它被誉为一种通用标准，旨在实现人工智能（AI）模型与各类软件工具之间的无缝集成。从表面上看，该协议确实解决了一个真实的行业痛点：用一套简单、标准的解决方案，取代当前由各种定制化应用程序接口（API）和专有插件构成的混乱局面。MCP的支持者们描绘了这样一幅未来图景：AI代理能够毫不费力地连接无数应用程序，无需再进行繁琐的定制化集成。\n然而，尽管MCP在技术上尽显优雅，早期也收获了极大的关注，但它注定会步履维艰。这并非源于技术上的缺陷，而是因为它从根本上误解了一个关键的经济现实：在数字商业版图中，最终用户的关注度才是商业取胜的关键。 各大公司都会不遗余力地守护用户的注意力，因为这才是他们最主要的变现来源。所以，工具供应商们实际上根本无法承受因全面采纳MCP而将自身降级为单纯后端功能的代价。\n真正的战场：注意力的所有权 要理解MCP为何会面临阻力，我们必须先思考一个基本事实：谁控制了用户界面，谁就掌握了用户关系。拥有界面的企业，就意味着拥有了用户的参与度、数据以及由此产生的收入机会。反之，那些被降级到后端的服务，则会变成可以被随意替换的商品，不仅容易被取代，还会被剥夺与客户的直接联系。\n历史一再证明了这一定律。例如，Facebook正是通过将第三方应用程序转变为纯粹的内容提供者，才建立起自己的商业帝国。早期的社交游戏巨头Zynga就曾惨痛地吸取过这一教训。当年，Facebook更改平台规则、收紧限制，导致Zynga游戏的曝光度大减。Zynga的命运就此被注定，因为Facebook牢牢控制着用户的注意力，从而主宰了Zynga的收入和客户互动。\n同样，Twitter之所以封锁第三方客户端，也是因为这些客户端允许用户绕过Twitter的广告系统，这无异于“窃取”了平台的用户注意力。苹果公司对待网页应用的态度是另一个极具说服力的例子：多年来，苹果一直有意限制iOS系统上网页应用的功能，以此确保App Store中的原生应用占据主导地位，从而维护苹果与用户的直接关系及其收入流。\nMCP的天真提议 而MCP实际上是在要求软件供应商们自愿接受一种新的模式：将他们的核心功能变为简单的后端服务，主要通过AI驱动的界面来被访问。\n想象一下，未来预订旅行完全通过一个AI助手完成，该助手在幕后通过MCP与航空公司、酒店和旅行社进行着无形的互动。在这种模式下，作为用户接触点和决策点的界面将完全属于AI助手，使得各大供应商无法直接触及用户的注意力。\n这实际上是将供应商们从拥有差异化品牌和客户忠诚度的“目的地”，降格为了标准化的“公用设施”。这种转变会严重威胁到供应商们捕获价值的核心能力。\n软件即服务（SaaS）和工具类供应商在很大程度上依赖于与用户的直接互动来实现其商业变现，例如向上销售增值功能、打造品牌体验以及收集宝贵的用户数据。\n一旦全面拥抱MCP，这些供应商就等于将用户界面拱手让给了外部的AI聚合平台，其结果将不可避免地导致客户关系和直接变现渠道的丧失。\n来自当前AI生态的证据 现实中，各大软件公司在处理与 OpenAI 的 ChatGPT、Anthropic 的 Claude 等AI驱动平台的关系时，已经表现得十分谨慎。\n无论是Salesforce、微软还是谷歌，它们都在寻求将AI能力深度嵌入到自己的专有界面中，而不是允许自己的工具被外部AI代理完全调用。\n例如，Salesforce推出的Einstein GPT，就将AI直接集成到了其客户关系管理（CRM）系统中，从而将用户牢牢地锁定在自己的生态系统内。同样，微软也优先将Copilot AI深度嵌入到Office和Windows环境中。当工具供应商确实尝试进行外部AI集成时，它们通常也只提供有限的功能——这些功能足以吸引用户，但又不足以完全替代它们自己的界面。例如，一个旅游应用或许会允许AI助手浏览航班信息，但最终一定会将用户引导回自己的平台去完成预订，以此来保留关键的客户互动和向上销售的机会。\nMCP必将面临困境 过往的经验清晰地揭示了 MCP 为何难以获得广泛采用，尤其是那些主导着市场注意力的大型软件供应商，必然不可能全面转向 MCP。\n如果这些供应商真的认为，放弃用户注意力来实现开放集成是有价值的，那么他们早就免费提供功能全面的公共API了。然而事实恰恰相反，他们通常会构建受到严格控制的生态系统，通过选择性的集成来吸引新用户，绝不会主动放弃对用户体验或营收的控制权。\n这种小心翼翼的平衡之举，恰恰凸显了 MCP 的根本性缺陷：无论一项协议在技术上多么优雅或优越，软件供应商们其实没有任何动机会将自己宝贵的客户关系和变现能力拱手让给外部的聚合者。\n平台经济学才是技术的基础 归根结底，决定MCP命运的，并非其技术上的优劣，而是商业激励机制和平台经济的动态。平台的所有者必然会想方设法保护他们的核心资产——即与用户的直接联系。MCP所提出的方法从根本上颠覆了这一动态，使其与根深蒂固的经济激励背道而驰。\n在实践中，MCP或许能在一些小型供应商或那些开放本身就具有内在价值的小众社区中获得有限的采用。然而，在主导当今数字经济的主流 SaaS 供应商和大型平台中，MCP的采用充其量更多是扩展自身而非外放能力的。\n本质上，虽然MCP试图成为通用标准，但正面临一个残酷的经济现实：没有哪家公司愿意自甘沦为一个隐形的背景板。各大公司必然会拼尽全力捍卫自己对用户界面（即用户关系的控制权)，并限制任何可能威胁其战略地位的集成。\n结论 MCP所描绘的无缝、通用AI集成的愿景固然引人入胜，但在商业世界，单凭引人注目的技术很少能决定成败。 关于标准的争夺，最终是关于经济话语权的争夺。而MCP的设计，恰恰挑战了数十年来驱动数字经济发展的基本激励结构。也正因如此，MCP在走向广泛应用的道路上面临着巨大的障碍。\n在它能够更好地契合平台经济学和供应商的内在动力之前，MCP想要成为AI与工具集成的通用标准，恐怕也只能是一个遥远的梦想。\n原文链接： https://www.forbes.com/councils/forbestechcouncil/2025/06/12/mcp-will-fail-and-heres-why/\n","date":"2025-06-29T21:25:34+08:00","image":"https://chengxiaqiucao.github.io/post/106-mcp_must_fail/Pasted-20250629_hu_ccd9fdadcad3bd41.png","permalink":"https://chengxiaqiucao.github.io/post/106-mcp_must_fail/","title":"MCP必将失败？关于MCP的质疑声"},{"content":"史上最难就业季 “史上最难就业季”的口号年年都在喊，但对于2025届的同学来说，这似乎不再只是一句口号。\n根据百度预测数据，在高校逐年扩招的背景下，2025年高校毕业生规模已达惊人的 1222万（对比2024年新生儿总数 954万\u0026lt;2024年政府经济与社会发展统计公报\u0026gt;， 大学生光环早已不在），就业供给压力达到历史峰值！\n而根据智联的最新报告显示，目前高校毕业生整体就业率（含灵活就业）仅为 55.5%。 对很多毕业生来说，“毕业即失业” 似乎已是苦涩的现实！\nIT行业就业的冰火两重天 随着AI、智能驾驶等行业的爆发，IT行业虽然需求依然旺盛，但也明显体现出分化趋势！一方面人工智能、网络安全等新兴领域人才紧缺；另一方面传统互联网岗位收缩，部分岗位竞争比例超过100：1\nIT行业依然是薪资保证 根据国家2024统计年鉴的数据，IT行业以平均 23.18万 的年薪，连续9年蝉联行业待遇榜首\n就业率下滑与学历门槛提升 2024届计算机本科整体就业率降至68.65%，部分高校出现“600人中仅200人就业”的极端案例。大厂核心岗位（算法、研发等）则超 60% 要求硕士学历，985/211院校学生凭借校企合作资源更易获得高薪机会。（ 数据来源）\n薪资分化加剧 顶尖群体：大厂算法岗年薪达40-50万，AI顶尖人才年薪可达80-150万 普通群体：普通院校本科生月薪普遍在7K-10K，部分被迫转行或“降维”至二线城市 行业对比：IT行业以年均工资23.18万元连续九年位居各行业首位，但2023届计算机本科平均月薪6771元，首次被电子信息类专业（6802元）反超 传统岗位饱和 Java后端、基础开发岗因竞争激烈成为“红海”，中小型企业简历投递比达8：127。初级开发岗位薪资回落至8-12K，很多企业开始出现“降薪招聘”现象。\n高端人才缺口爆发 人工智能：人才缺口超500万，供需比1：10 网络安全：年培养量仅3万人，但岗位缺口高达70万，缺口率95%，预计2027年缺口将扩大至327万 硬科技领域：芯片设计、工业软件等国产信创岗位需求年增15%+ 自救策略 那么在这样的就业现状下，应届或即将面向就业市场的同学们要如何突围呢？\n锚定高增长领域，寻找蓝海机会 网络安全：考取NISP二级证书（可免试换CISP），持证者享受企业优先录用、地方政府补贴 AI应用层：聚焦自动驾驶、医疗影像、金融量化等落地场景 硬科技：嵌入式开发（物联网）、工业软件国产化替代 构建复合能力 “计算机+X”复合人才薪资会高出纯技术岗20%， 如：\n金融科技（量化模型） 生物信息（基因测序） 智慧农业（传感器技术） 实战经历背书 大厂实习：转正率超50%，暑期实习成核心跳板 项目经验：GitHub高星项目、Kaggle竞赛名次、校企合作项目经历 证书加持：云原生（Kubernetes）、渗透测试（CISP-PTE）等认证 理性区域选择 新一线城市性价比凸显：苏州、西安等地的IT岗位薪资达一线60%-80%，生活成本降低30%-50%。\n结语 2025年的IT就业市场，对于躺在舒适区、技能单一的毕业生来说，无疑是寒冬；但如果积极拥抱变化、主动学习前沿技术、具备了解决复杂问题能力，却也是一个充满无限机遇的黄金时代。\n挑战是客观存在的，未来，永远掌握在主动出击的人手中！\n","date":"2025-06-28T14:25:06+08:00","image":"https://chengxiaqiucao.github.io/post/104-%E9%AB%98%E6%A0%A1it%E5%B0%B1%E4%B8%9A/title_hu_68ab64b60990ce93.png","permalink":"https://chengxiaqiucao.github.io/post/104-%E9%AB%98%E6%A0%A1it%E5%B0%B1%E4%B8%9A/","title":"2025应届IT就业行情怎么样？"},{"content":"前言 昨天（2025-6-25），Google重磅开源了一个基于命令行的AI编程Agent Gemini-Cli，让AI辅助编程深度集成到开发人员最熟悉的Terminal命令行界面，而且直接集成了Google最新的Gemini 2.5 Pro能力，开发者免费使用（有上限，但额度大方）。短短1天，Github上已冲到20K star，可见开发者对这款工具的热情之高！！\n开源项目地址： https://github.com/google-gemini/gemini-cli\nstar记录，恐怖的垂直上升 😂😂\n下面我们带来开箱试用体验！\n安装 Gemini-Cli的安装，非常便捷，它依赖 node.js, 确保本机安装 node.js 18以上版本，然后直接运行：\n1 npx https://github.com/google-gemini/gemini-cli 或者用npm安装后，执行 gemini\n1 2 npm install -g @google/gemini-cli gemini 就会进入命令行启动界面：\n选择一个自己喜欢的编程主题，然后会提示你鉴权，通常可以选择用google账号登录即可，授权显示如下信息即可继续使用。\n授权以后，默认就拥有了Gemini 25 pro 等多个AI大模型的能力，并且非常 “壕” 地提供了 每分钟60次，每天1000次 的AI调用，相比很多其他大模型还在以token数量进行限制，确实大气！ 对比 Cursor 收费版每月500次的数量限制，估计Cursor要在厕所哭晕了~~\n试用效果 废话不多说，作为一个测试业者，先请它帮忙做一个基于AI的用例生成工具。\n给出指令如下\n1 2 编写一个web程序，支持上传需求文档并调用ai能力转换为测试用例，用例以表格形式显示在页面上，包含用例ID、用例名称、描述、测试步骤、优 先级、通过标准、关联需求ID（可选）等字段 很快，经过短暂的分析，就给出了实现方案。\n开始具体操作过程中，会自动创建相关代码文件，并指引你逐步配合它完成从数据模拟到真正的AI能力集成等步骤。\n经过半个多小时的配合工作（主要是出现报错后把报错信息贴给它），最终我们成功实现了一个基本的AI用例生成工具。\n比如将我之前开源的测试练习站点的需求 req-sprint0.md 上传：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 ### 个人图书管理系统 - 迭代1 需求文档 **版本**：v1.0 **目标**：实现个人图书的基础增删改查功能 --- #### **用户故事1：添加图书** **As a** 图书收藏者 **I want to** 添加新图书到我的书库 **So that** 我可以记录拥有的书籍 **验收标准 (Given-When-Then):** 1. **成功添加** - *Given* 用户在“添加图书”页面 - *When* 填写必填字段（图书名称、作者）并点击提交 - *Then* 系统保存图书，显示“添加成功”提示，并跳转至图书列表页 2. **添加失败（校验缺失）** - *Given* 用户未填写“图书名称”或“作者” - *When* 点击提交按钮 - *Then* 系统在对应字段下方显示红色错误提示 --- #### **用户故事2：查看图书列表** **As a** 图书收藏者 **I want to** 查看所有图书列表 **So that** 我可以快速浏览藏书 **验收标准:** 1. **基础列表展示** - *Given* 存在至少一本图书 - *When* 用户访问首页 - *Then* 以表格形式展示所有图书（至少包含名称、作者、阅读状态） 2. **空状态处理** - *Given* 无任何图书 - *When* 用户访问首页 - *Then* 显示“暂无图书，点击添加”的提示和跳转链接 --- #### **用户故事3：编辑图书信息** **As a** 图书收藏者 **I want to** 修改图书信息 **So that** 我可以更新书籍状态或备注 **验收标准:** 1. **成功编辑** - *Given* 用户从列表页进入某图书的“编辑”页面 - *When* 修改字段（如更新阅读状态为“已读”）并提交 - *Then* 系统保存修改，返回列表页并显示更新后的数据 2. **非法数据拦截** - *Given* 用户在价格字段输入字母 - *When* 点击提交 - *Then* 系统阻止提交并提示“请输入有效数字” --- #### **用户故事4：删除图书** **As a** 图书收藏者 **I want to** 删除不再需要的图书 **So that** 保持书库整洁 **验收标准:** 1. **删除操作** - *Given* 用户在图书列表页 - *When* 点击某图书的“删除”按钮 - *Then* 系统移除该图书，列表实时刷新 --- #### **用户故事5：搜索图书** **As a** 图书收藏者 **I want to** 通过名称或作者搜索图书 **So that** 快速定位目标书籍 **验收标准:** 1. **基础搜索** - *Given* 用户在列表页顶部的搜索框输入关键词 - *When* 点击“搜索”按钮 - *Then* 系统展示名称或作者匹配的图书（不区分大小写） --- ### 字段定义（图书属性） | 字段 | 类型 | 必填 | 说明 | 示例 | |--------------|----------|------|-------------------------------|----------------------| | 图书名称 | 文本 | ✓ | 书名（长度≤100字符） | 《三体》 | | 作者 | 文本 | ✓ | 作者名（长度≤50字符） | 刘慈欣 | | 简介 | 长文本 | ✗ | 图书描述（长度≤500字符） | 科幻巨著... | | 发行时间 | 日期 | ✗ | YYYY-MM-DD格式 | 2008-01-01 | | 发行价格 | 小数 | ✗ | 正数（≥0） | 68.5 | | 用户购买价格 | 小数 | ✗ | 正数（≥0） | 52.0 | | 用户备注 | 长文本 | ✗ | 读后感（长度≤1000字符） | 震撼的宇宙观... | | 阅读状态 | 枚举 | ✗ | 待读/已读/正在读（默认待读） | 待读 | | 在库状态 | 枚举 | ✗ | 在库/借入/借出/归档（默认在库）| 借出 | | 自评星级 | 整数 | ✗ | 1-5星（默认3星） | 5 | --- ### 技术栈说明 | 模块 | 技术选择 | |--------|-----------------------| | 后端 | Python + FastAPI | | 数据库 | SQLite | | 前端 | HTML/CSS + Bootstrap | | API交互| AJAX (Fetch API) | 开发的程序会调用本地的Ollama部署的deepseek，然后生成测试用例！ 界面如下：\n确实太香了！小伙伴们快安利起来~~\n回复 进群 加入秋草的技术交流群，和小伙伴们分享技术，互换资讯~~ 回复 大纲 可查看秋草测试技术高级体系化课程详细目录 😉😉😉\n","date":"2025-06-26T13:21:59+08:00","image":"https://chengxiaqiucao.github.io/post/103-gemini-cli/Pasted-20250626_hu_3650a61f68fde198.png","permalink":"https://chengxiaqiucao.github.io/post/103-gemini-cli/","title":"Cursor天塌了，Google开源Gemini-cli，编程助手卷王来了"},{"content":"前言 日常工作、编写文档、和他人的线上沟通交流过程中，一图胜千言。所以有一个非常高频的动作，就是从当前屏幕上截图，再经过一些进一步的标注，达到信息传递的目的。\n我们的电脑也都自带截屏功能，通过键盘上的 PrtSc 按键就可以呼出系统自带的截屏工具，但自带工具功能相对还是比较简单，而且还是有不少后续步骤，对于滚动的长页面截长图或者重现操作的动态图也不支持。\n所以就有了很多专门的效率工具用于截图处理，这类工具非常多，这里仅仅把笔者自用的几个常用工具分享给大家，如有其他更优秀的工具，大家也可留言分享哦~~\n强大易用的 Snipaste Snipaste 是一个国产强大截图工具，有专业版和免费版之分，但免费版功能已足够强大，应付日常工作需要不在话下。\n官网： https://www.snipaste.com\n正如软件的名称，这是一款专注在 截图 + 贴图 功能的工具。和传统截图工具相比，这个工具最大的优势就是它丰富的截图方式、极为方便的二次编辑以及高效的贴图演示能力\n丰富的截图功能 Snipaste的截图， 默认快捷键 F1 呼出截图工具，经过多年优化，在截图易用性上已极为出色。\n自动检测界面元素区域 可以根据鼠标指向自动识别界面元素，框定截图范围\n像素级的鼠标移动控制、截图范围控制 （WASD等快捷键） 精细化截图时可以通过快捷键，按像素级别进行范围调整\n便捷的取色器 （F1截图, C取色, F3贴图） 对于一些图像编辑，需要精确控制颜色场景时，通过快捷键可以便捷取色，且可很方便提取不同格式的颜色取值 支持跨多屏幕的图像捕获 对于有多个显示屏的情况，可以实现跨屏幕的截图\n自动保存及截图历史回溯 可以在工具设置中配置截图自动保存，也可在截图工具界面上选择保存到剪贴板\n而它还有一个非常实用的截图历史回溯功能，可以将成功保存的截图，在进入截图界面后通过快捷键 ,和 . 进行回溯。\n这里成功保存图片的定义包括：\n保存到剪贴板 ( / Ctrl + C / Enter / 鼠标左键双击 截屏区域) 保存到文件 ( / Ctrl + S) 保存到贴图 ( / Ctrl + T / 鼠标中键单击 截屏区域) 快捷保存 (Shift + / Ctrl + Shift + S) 图片标注功能 截图工具选定区域后，就莫默认进入标注编辑界面，在这里可以在图片中添加必要的说明文章，通过箭头、画笔、马赛克等工具进行丰富的标注功能。\n另外，这里还有一个技巧，标注时选中标注工具如矩形、椭圆、或者 记号笔/马赛克/高斯模糊/橡皮擦 的矩形填充画笔，再 鼠标右键 点击对应元素即可快速完成对应标注\n贴图 贴图是 Snipaste 的亮点功能，快捷键 F3，可以将当前剪贴板中的图片置顶显示在当前屏幕上\n主要应用场景是我们可以通过截图后贴图暂时保存当前界面，在后续操作后在和前面的贴图进行便捷的比对查看。\n功能也很丰富且实用：\n贴图后，滚轮可以调整缩放大小 ctrl + 滚轮 可以调整图片透明度 根据 首选项 - 控制 - 开关鼠标穿透 中的快捷键，可以让鼠标穿过截图继续操作图片下的屏幕 快捷键 1或 2 ，3, 4可以旋转图片 总之， Snipaste 是一款能让你在截图时体会随心所欲感觉的强力工具，强烈推荐！\n截长图 除了普通的截图外，还有一个常见的需求是截取长图，特别是网页或软件界面中需要滚动的情况。\n其实比较早的 Snipaste 版本中也支持长截图功能，但新版本似乎已移除。\n这里我比较常用的是 QQ 自带的截图功能，使用比较简单，开启QQ以后，通过快捷键 ctrl + alt + A 呼出截图功能，选择长截图即可，如下图所示，不再赘述。\n如果不想登录QQ，Github上也有一个 QQ截图独立版 的开源工具，效果相关。地址如下：\nhttps://github.com/insoxin/QQScreenShot\n动态操作截图 还有一个场景，就是我们很多时候希望将自己的操作记录下来，录制视频相对比较麻烦而且文件较大，比较简单的就是把操作保存为一个动态的GIF图片，这里我常用的工具是 LICEcap\n这也是一个开源工具，官网： https://www.cockos.com/licecap/\n打开软件，根据需要调整需要录制的区域大小，点击 record，配置相关录制参数 比如下面就是根据上述配置得到一个GIF操作图\n以上就是本次关于截图实用工具的分享，也欢迎小伙伴们积极留言，还有哪些我们日常能用到的宝藏工具软件呢？\n回复 进群 加入秋草的技术交流群，和小伙伴们分享技术，互换资讯~~ 回复 大纲 可查看秋草测试技术高级体系化课程详细目录 😉😉😉\n","date":"2025-06-24T12:27:48+08:00","image":"https://chengxiaqiucao.github.io/post/102-%E5%B8%B8%E7%94%A8%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/title_hu_be75d5860d6937d1.png","permalink":"https://chengxiaqiucao.github.io/post/102-%E5%B8%B8%E7%94%A8%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/","title":"提升工作效率的秘密！自用截图工具分享，长图\u0026动态图轻松搞定"},{"content":"前言 在之前的文章 【】我们了解了字节跳动推出的AI测试工具 Midscene.js， 不管是智能解析项目，测试执行还是最后的报告生成都颇为亮眼，而且除了基于浏览器的web应用，还支持了Android应用的自动化。\n那么这个项目具体是如何利用 AI 智能完成测试执行任务的呢？ 本文我们就结合 Midscene.js 的开源项目源码，对该项目的实现，以及对大模型的应用进行深入分析。\n项目整体架构 通过项目源码的分析，该项目的总体架构可以用下图概括： 用户: 用户是Midscene的起点，通过自然语言描述、JavaScript SDK 或 YAML 脚本来定义自动化任务和目标。\nMCP 客户端 (MCP Clients): Midscene还支持其他MCP客户端直接使用其能力，这表明它可能有一个API或集成点供其他系统调用。\nMidscene Core: 这是Midscene的核心逻辑层。它负责解析用户的指令，与AI模型交互，并协调自动化代理来执行操作。它也管理报告生成和缓存。\nAI 模型: Midscene支持多种AI模型，包括：\n多模态 LLM (Multimodal LLM)：如 GPT-4o, Gemini-2.5-Pro，用于理解更复杂的指令和上下文。\n视觉语言模型 (Visual-Language Models)：如 Qwen2.5-VL, Doubao-1.5-thinking-vision-pro, UI-TARS，特别推荐用于UI自动化，因为它们能更好地理解视觉信息。 AI模型接收来自Midscene Core的请求，并返回执行动作或获取信息的指令。\n自动化代理: 这是一个关键的执行层，负责根据Midscene Core的指令，实际操作目标应用程序或UI。它能获取UI状态和截图，并将其反馈给Midscene Core。\n目标应用程序/UI: 这是自动化操作的实际对象，可以是：\n浏览器 (Browser)：通过Playwright或Puppeteer等工具进行Web自动化。 Android 应用 (Android App)：进行Android自动化。 可视化报告 (Visual Reports): Midscene提供可视化报告，方便用户理解、回放和调试整个自动化过程。\nPlayground: 内置的Playground环境，允许用户通过自然语言指令进行调试。\n缓存机制 (Caching Mechanism): Midscene利用缓存机制来提高效率，允许脚本更快地重放以获得结果。\n主要的内置系统提示词 MidScene 的智能解析能力主要依托 LLM 大模型来实现，因此在调用 LLM 的时候，其设定的系统提示词就尤为关键。通过分析源码，可以看到 MidScene 针对不同类型的任务，设定了不同的系统提示词。总结如下：\n1. 任务规划类 System Prompts 该项目包含三种不同的任务规划提示词：\n传统LLM模型的任务规划提示词 - 用于指导传统语言模型将用户指令分解为一系列可执行的UI操作动作。\npackages/core/src/ai-model/prompt/llm-planning.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 const llmLocateParam = `locate: {{\u0026#34;id\u0026#34;: string, \u0026#34;prompt\u0026#34;: string}} | null`; const systemTemplateOfLLM = ({ pageType }: { pageType: PageType }) =\u0026gt; ` ## Role You are a versatile professional in software UI automation. Your outstanding contributions will impact the user experience of billions of users. ## Objective - Decompose the instruction user asked into a series of actions - Locate the target element if possible - If the instruction cannot be accomplished, give a further plan. ## Workflow 1. Receive the screenshot, element description of screenshot(if any), user\u0026#39;s instruction and previous logs. 2. Decompose the user\u0026#39;s task into a sequence of actions, and place it in the \\`actions\\` field. There are different types of actions (Tap / Hover / Input / KeyboardPress / Scroll / FalsyConditionStatement / Sleep ${pageType === \u0026#39;android\u0026#39; ? \u0026#39;/ AndroidBackButton / AndroidHomeButton / AndroidRecentAppsButton\u0026#39; : \u0026#39;\u0026#39;}). The \u0026#34;About the action\u0026#34; section below will give you more details. 3. Precisely locate the target element if it\u0026#39;s already shown in the screenshot, put the location info in the \\`locate\\` field of the action. 4. If some target elements is not shown in the screenshot, consider the user\u0026#39;s instruction is not feasible on this page. Follow the next steps. 5. Consider whether the user\u0026#39;s instruction will be accomplished after all the actions - If yes, set \\`taskWillBeAccomplished\\` to true - If no, don\u0026#39;t plan more actions by closing the array. Get ready to reevaluate the task. Some talent people like you will handle this. Give him a clear description of what have been done and what to do next. Put your new plan in the \\`furtherPlan\\` field. The \u0026#34;How to compose the \\`taskWillBeAccomplished\\` and \\`furtherPlan\\` fields\u0026#34; section will give you more details. ## Constraints - All the actions you composed MUST be based on the page context information you get. - Trust the \u0026#34;What have been done\u0026#34; field about the task (if any), don\u0026#39;t repeat actions in it. - Respond only with valid JSON. Do not write an introduction or summary or markdown prefix like \\`\\`\\`json\\`\\`\\`. - If the screenshot and the instruction are totally irrelevant, set reason in the \\`error\\` field. ## About the \\`actions\\` field The \\`locate\\` param is commonly used in the \\`param\\` field of the action, means to locate the target element to perform the action, it conforms to the following scheme: type LocateParam = {{ \u0026#34;id\u0026#34;: string, // the id of the element found. It should either be the id marked with a rectangle in the screenshot or the id described in the description. \u0026#34;prompt\u0026#34;?: string // the description of the element to find. It can only be omitted when locate is null. }} | null // If it\u0026#39;s not on the page, the LocateParam should be null ## Supported actions Each action has a \\`type\\` and corresponding \\`param\\`. To be detailed: - type: \u0026#39;Tap\u0026#39; * {{ ${llmLocateParam} }} - type: \u0026#39;RightClick\u0026#39; * {{ ${llmLocateParam} }} - type: \u0026#39;Hover\u0026#39; * {{ ${llmLocateParam} }} - type: \u0026#39;Input\u0026#39;, replace the value in the input field * {{ ${llmLocateParam}, param: {{ value: string }} }} * \\`value\\` is the final value that should be filled in the input field. No matter what modifications are required, just provide the final value user should see after the action is done. - type: \u0026#39;KeyboardPress\u0026#39;, press a key * {{ param: {{ value: string }} }} - type: \u0026#39;Scroll\u0026#39;, scroll up or down. * {{ ${llmLocateParam}, param: {{ direction: \u0026#39;down\u0026#39;(default) | \u0026#39;up\u0026#39; | \u0026#39;right\u0026#39; | \u0026#39;left\u0026#39;, scrollType: \u0026#39;once\u0026#39; (default) | \u0026#39;untilBottom\u0026#39; | \u0026#39;untilTop\u0026#39; | \u0026#39;untilRight\u0026#39; | \u0026#39;untilLeft\u0026#39;, distance: null | number }} }} * To scroll some specific element, put the element at the center of the region in the \\`locate\\` field. If it\u0026#39;s a page scroll, put \\`null\\` in the \\`locate\\` field. * \\`param\\` is required in this action. If some fields are not specified, use direction \\`down\\`, \\`once\\` scroll type, and \\`null\\` distance. * {{ param: {{ button: \u0026#39;Back\u0026#39; | \u0026#39;Home\u0026#39; | \u0026#39;RecentApp\u0026#39; }} }} - type: \u0026#39;ExpectedFalsyCondition\u0026#39; * {{ param: {{ reason: string }} }} * use this action when the conditional statement talked about in the instruction is falsy. - type: \u0026#39;Sleep\u0026#39; * {{ param: {{ timeMs: number }} }} ${ pageType === \u0026#39;android\u0026#39; ? `- type: \u0026#39;AndroidBackButton\u0026#39;, trigger the system \u0026#34;back\u0026#34; operation on Android devices * {{ param: {{}} }} - type: \u0026#39;AndroidHomeButton\u0026#39;, trigger the system \u0026#34;home\u0026#34; operation on Android devices * {{ param: {{}} }} - type: \u0026#39;AndroidRecentAppsButton\u0026#39;, trigger the system \u0026#34;recent apps\u0026#34; operation on Android devices * {{ param: {{}} }}` : \u0026#39;\u0026#39; } `; 视觉-语言模型的任务规划提示词 - 专门针对具有视觉能力的AI模型（如Qwen-VL、Gemini）设计，能够直接处理截图并规划下一步动作。\nUI-Tars模型的任务规划提示词 - 为UI-Tars专门设计的GUI智能体提示词，采用思考-行动的格式。\n2. 元素定位类 System Prompts 元素定位提示词 - 用于在页面截图和元素描述中精确定位目标元素，支持传统LLM和视觉-语言模型两种模式。 区域定位提示词 - 用于定位包含目标元素的页面区域，通常不超过300x300像素的区域。\n3. 数据提取类 System Prompts 数据提取提示词 - 指导AI从UI界面中提取结构化数据，支持多种数据类型和格式要求。\n4. 断言验证类 System Prompts 断言验证提示词 - 用于验证页面状态是否符合预期的断言条件，支持UI-Tars和普通模型两种格式。\n1 2 3 4 5 6 7 8 const defaultAssertionPrompt = \u0026#39;You are a senior testing engineer. User will give an assertion and a screenshot of a page. By carefully viewing the screenshot, please tell whether the assertion is truthy.\u0026#39;; const defaultAssertionResponseJsonFormat = `Return in the following JSON format: { pass: boolean, // whether the assertion is truthy thought: string | null, // string, if the result is falsy, give the reason why it is falsy. Otherwise, put null. }`; 5. 元素描述类 System Prompts 元素描述提示词 - 用于生成精确的元素描述，帮助识别页面中的特定UI元素（给定元素）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 export const elementDescriberInstruction = () =\u0026gt; { return `Describe the element in the red rectangle for precise identification. Use ${getPreferredLanguage()}. Rules: 1. Start with element type (button, input, link, etc.) 2. Include key identifiers: - Text content: \u0026#34;with text \u0026#39;Submit\u0026#39;\u0026#34; - Visual features: \u0026#34;blue background\u0026#34;, \u0026#34;icon only\u0026#34; - Position: \u0026#34;top-right\u0026#34;, \u0026#34;below search bar\u0026#34; 3. Keep description under 20 words 4. Don\u0026#39;t mention the red rectangle Return JSON: { \u0026#34;description\u0026#34;: \u0026#34;brief element type with key identifiers\u0026#34;, \u0026#34;error\u0026#34;?: \u0026#34;error message if any\u0026#34; }`; }; 6. 代码生成类 System Prompts Playwright测试代码生成提示词 - 基于录制的浏览器会话事件生成可执行的Playwright测试代码。\n1 2 3 // Create system prompt const systemPrompt = `You are an expert test automation engineer specializing in Playwright and Midscene. Your task is to generate a complete, executable Playwright test using @midscene/web/playwright that reproduces a recorded browser session. 通过对这些 system prompts 采用模块化设计，根据不同的AI模型类型（传统LLM vs 视觉-语言模型）和页面类型（web vs Android）来动态调整。项目还包含了完整的JSON schema定义来确保AI输出的结构化和一致性，并且支持多语言环境 ${getPreferredLanguage()}\n对用户提示词的补充和约束 除了通过这些系统提示词的设定，让LLM可以更好理解当前任务。对于用户的输入指令，即用户提示词，在实际处理时，必然还需要进行一定的扩展和约束补充。\n这里我们再分析关于用户提示词的处理：\n1. 背景上下文的智能生成 项目通过generateTaskBackgroundContext函数为用户指令添加结构化的背景上下文，包括高优先级知识和历史执行日志，防止重复执行相同的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 export const generateTaskBackgroundContext = ( userInstruction: string, log?: string, userActionContext?: string, ) =\u0026gt; { if (log) { return ` Here is the user\u0026#39;s instruction: \u0026lt;instruction\u0026gt; \u0026lt;high_priority_knowledge\u0026gt; ${userActionContext} \u0026lt;/high_priority_knowledge\u0026gt; ${userInstruction} \u0026lt;/instruction\u0026gt; These are the logs from previous executions, which indicate what was done in the previous actions. Do NOT repeat these actions. \u0026lt;previous_logs\u0026gt; ${log} \u0026lt;/previous_logs\u0026gt; `; } return ` Here is the user\u0026#39;s instruction: \u0026lt;instruction\u0026gt; \u0026lt;high_priority_knowledge\u0026gt; ${userActionContext} \u0026lt;/high_priority_knowledge\u0026gt; ${userInstruction} \u0026lt;/instruction\u0026gt; `; }; 2. 多模态适配的用户提示 根据AI模型的能力，用户提示会采用不同的格式。对于视觉语言模型，直接传递任务背景；对于传统LLM，则结合页面描述信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 export const automationUserPrompt = ( vlMode: ReturnType\u0026lt;typeof vlLocateMode\u0026gt;, ) =\u0026gt; { if (vlMode) { return new PromptTemplate({ template: \u0026#39;{taskBackgroundContext}\u0026#39;, inputVariables: [\u0026#39;taskBackgroundContext\u0026#39;], }); } return new PromptTemplate({ template: ` pageDescription: ===================================== {pageDescription} ===================================== {taskBackgroundContext}`, inputVariables: [\u0026#39;pageDescription\u0026#39;, \u0026#39;taskBackgroundContext\u0026#39;], }); }; 3. 结构化JSON Schema验证 项目使用OpenAI的结构化输出schema来严格约束AI的响应格式，确保返回的数据符合预定义的结构，包括actions、log、error等必要字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 export const planSchema: ResponseFormatJSONSchema = { type: \u0026#39;json_schema\u0026#39;, json_schema: { name: \u0026#39;action_items\u0026#39;, strict: true, schema: { type: \u0026#39;object\u0026#39;, strict: true, properties: { actions: { // TODO type: \u0026#39;array\u0026#39;, items: { type: \u0026#39;object\u0026#39;, strict: true, properties: { thought: { type: \u0026#39;string\u0026#39;, description: \u0026#39;Reasons for generating this task, and why this task is feasible on this page\u0026#39;, }, type: { type: \u0026#39;string\u0026#39;, description: \u0026#39;Type of action, one of \u0026#34;Tap\u0026#34;, \u0026#34;RightClick\u0026#34;, \u0026#34;Hover\u0026#34; , \u0026#34;Input\u0026#34;, \u0026#34;KeyboardPress\u0026#34;, \u0026#34;Scroll\u0026#34;, \u0026#34;ExpectedFalsyCondition\u0026#34;, \u0026#34;Sleep\u0026#34;, \u0026#34;AndroidBackButton\u0026#34;, \u0026#34;AndroidHomeButton\u0026#34;, \u0026#34;AndroidRecentAppsButton\u0026#34;\u0026#39;, }, param: { anyOf: [ { type: \u0026#39;null\u0026#39; }, { type: \u0026#39;object\u0026#39;, properties: { value: { type: [\u0026#39;string\u0026#39;, \u0026#39;number\u0026#39;] } }, required: [\u0026#39;value\u0026#39;], additionalProperties: false, }, { type: \u0026#39;object\u0026#39;, properties: { timeMs: { type: [\u0026#39;number\u0026#39;, \u0026#39;string\u0026#39;] } }, required: [\u0026#39;timeMs\u0026#39;], additionalProperties: false, }, { type: \u0026#39;object\u0026#39;, properties: { direction: { type: \u0026#39;string\u0026#39; }, scrollType: { type: \u0026#39;string\u0026#39; }, distance: { type: [\u0026#39;number\u0026#39;, \u0026#39;string\u0026#39;, \u0026#39;null\u0026#39;] }, }, required: [\u0026#39;direction\u0026#39;, \u0026#39;scrollType\u0026#39;, \u0026#39;distance\u0026#39;], additionalProperties: false, }, { type: \u0026#39;object\u0026#39;, properties: { reason: { type: \u0026#39;string\u0026#39; } }, required: [\u0026#39;reason\u0026#39;], additionalProperties: false, }, { type: \u0026#39;object\u0026#39;, properties: { button: { type: \u0026#39;string\u0026#39; } }, required: [\u0026#39;button\u0026#39;], additionalProperties: false, }, ], description: \u0026#39;Parameter of the action, can be null ONLY when the type field is Tap or Hover\u0026#39;, }, locate: { type: [\u0026#39;object\u0026#39;, \u0026#39;null\u0026#39;], properties: { id: { type: \u0026#39;string\u0026#39; }, prompt: { type: \u0026#39;string\u0026#39; }, }, required: [\u0026#39;id\u0026#39;, \u0026#39;prompt\u0026#39;], additionalProperties: false, description: \u0026#39;Location information for the target element\u0026#39;, }, }, required: [\u0026#39;thought\u0026#39;, \u0026#39;type\u0026#39;, \u0026#39;param\u0026#39;, \u0026#39;locate\u0026#39;], additionalProperties: false, }, description: \u0026#39;List of actions to be performed\u0026#39;, }, more_actions_needed_by_instruction: { type: \u0026#39;boolean\u0026#39;, description: \u0026#39;If all the actions described in the instruction have been covered by this action and logs, set this field to false.\u0026#39;, }, log: { type: \u0026#39;string\u0026#39;, description: \u0026#39;Log what these planned actions do. Do not include further actions that have not been planned.\u0026#39;, }, error: { type: [\u0026#39;string\u0026#39;, \u0026#39;null\u0026#39;], description: \u0026#39;Error messages about unexpected situations\u0026#39;, }, }, required: [ \u0026#39;actions\u0026#39;, \u0026#39;more_actions_needed_by_instruction\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;error\u0026#39;, ], additionalProperties: false, }, }, }; 通过这些多层次的增强和约束机制，确保了AI模型能够准确理解用户意图，同时严格控制AI的行为边界。从提示词的定义来看，项目很注重防止AI产生幻觉或执行超出用户指令范围的操作，这对于UI自动化这种需要高精度操作的场景至关重要。\n大模型上下文窗口限制 在利用各种AI大模型完成智能任务时，一个非常重要的约束，就是大模型通常是有着上下文窗口大小限制的，超过这个限制的历史信息会被丢弃，以节约大模型的资源，提升性能。\n而对于一个自动化测试任务来说，分解拆分后的运行链路往往较长，通常都会超出LLM的上下文限制。\n所以这里我们再分析一下这个项目对于上下文窗口限制的处理是如何实现的\n1. Token数量限制控制 项目通过OPENAI_MAX_TOKENS环境变量来设置响应的最大token数量\n2. 图像尺寸限制和自动调整 项目针对不同模型实施图像尺寸限制，特别是对GPT-4o模型实施严格的尺寸控制。当检测到图像尺寸超过GPT-4o的最大输入限制（2000x768或768x2000像素）时，系统会发出警告 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 let warned = false; export function warnGPT4oSizeLimit(size: Size) { if (warned) return; if (getModelName()?.toLowerCase().includes(\u0026#39;gpt-4o\u0026#39;)) { const warningMsg = `GPT-4o has a maximum image input size of 2000x768 or 768x2000, but got ${size.width}x${size.height}. Please set your page to a smaller resolution. Otherwise, the result may be inaccurate.`; if ( Math.max(size.width, size.height) \u0026gt; 2000 || Math.min(size.width, size.height) \u0026gt; 768 ) { console.warn(warningMsg); warned = true; } } else if (size.width \u0026gt; 1800 || size.height \u0026gt; 1800) { console.warn( `The image size seems too large (${size.width}x${size.height}). It may lead to more token usage, slower response, and inaccurate result.`, ); warned = true; } } 3. 图像压缩和优化 系统通过图像压缩来减少数据传输量(packages/shared/src/img/transform.ts) ，包括：\n设置图像质量为90%来平衡质量和文件大小 提供图像调整大小功能 支持base64格式的图像处理和转换 4. 选择合适的模型架构 项目支持两种不同类型的AI模型来优化token使用：\n通用多模态LLM（如GPT-4o）：需要同时发送截图和DOM树，导致token消耗较高 。\n视觉定位VL模型（如Qwen-2.5-VL）：支持视觉定位功能，不需要发送DOM树，可以节省30%到50%的token数量。\n参见 apps/site/docs/zh/choose-a-model.mdx 文档中的说明\n5. Token使用情况监控 项目还提供了详细的token使用情况跟踪和调试功能，记录prompt tokens、completion tokens和总token数量 。\n总结来说，该项目的上下文窗口限制处理策略主要集中在三个方面：\n控制输入数据量（通过图像压缩和尺寸限制） 选择合适的模型架构（VL模型vs通用LLM） 监控和优化token使用 这种多层次的处理方式有效地减少了对大型上下文窗口的需求，同时也保持了功能的完整性。\n长链路任务的记忆管理 对于大模型来说，已完成步骤和历史任务的记忆对于保证结果的准确，避免无谓重复和节约成本意义重大，像我们之前文章介绍的如 Browser-Use这样的工具，会引入 mem0 这样的记忆框架来实现 AI 的记忆能力，那么Midscene在这方面是如何处理的呢？\n基于对 Midscene 代码的分析，长链路任务的记忆管理主要通过以下几个核心机制实现：\n任务缓存机制 Midscene 实现了一个智能的任务缓存系统来管理 AI 操作的记忆。该系统缓存规划结果和元素定位信息，避免重复的 AI 调用，从而减少内存消耗和提高执行效率。\npackages/web-integration/src/common/task-cache.ts\n缓存系统支持两种类型的缓存：\n规划缓存 (PlanningCache) 用于存储 AI 规划的 YAML 工作流 定位缓存 (LocateCache) 用于存储元素的 XPath 信息。 对话历史管理 为了防止长链路任务中对话历史无限增长导致内存溢出，Midscene 实现了智能的对话历史管理策略。系统限制用户图像消息最多保留 4 条，采用先进先出 (FIFO) 策略自动清理旧的对话记录。\npackages/web-integration/src/common/tasks.ts\n重规划限制机制 为了防止 AI 在长链路任务中陷入无限重规划的死循环，系统设置了重规划次数限制。当重规划次数超过限制时，任务会主动终止并返回错误信息。\n1 2 3 4 5 6 7 while (planningTask) { if (replanCount \u0026gt; replanningCountLimit) { const errorMsg = \u0026#39;Replanning too many times, please split the task into multiple steps\u0026#39;; return this.appendErrorPlan(taskExecutor, errorMsg); } 资源清理机制 Midscene 使用 FreeFn 模式确保长链路任务完成后能够正确清理所有资源，包括网络连接、临时文件、定时器等。即使在异常情况下，资源清理机制也能保证系统资源得到释放。\npackages/web-integration/src/yaml/player.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 freeFn = [ ...(newFreeFn || []), { name: \u0026#39;restore-agent-onTaskStartTip\u0026#39;, fn: () =\u0026gt; { if (agent) { agent.onTaskStartTip = originalOnTaskStartTip; } }, }, ]; .... // free the resources for (const fn of freeFn) { try { // console.log(\u0026#39;freeing\u0026#39;, fn.name); await fn.fn(); // console.log(\u0026#39;freed\u0026#39;, fn.name); } catch (e) { // console.error(\u0026#39;error freeing\u0026#39;, fn.name, e); } } 上下文优化 为了减少内存占用，Midscene 还实现了多项上下文优化策略：\n可见元素过滤：只提取页面中可见的元素，减少 DOM 树的大小 图像压缩：对截图进行智能压缩，减少内存和传输开销 视口裁剪：根据视口范围裁剪上下文数据 可以看到，虽然Mdscene没有引入专门的记忆框架来处理历史记忆，但还是建立了记忆管理机制来协同处理，使 Midscene 能够在处理复杂的长链路任务时保持高效的内存使用，通过对话历史管理控制记忆增长，重规划限制防止无限循环，通过资源清理确保系统稳定性，最终实现了一个可靠的长链路任务执行系统。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 graph TD A[用户] --\u0026gt;|提供自然语言描述/JS SDK/YAML脚本| B(Midscene Core) B --\u0026gt;|调用| C{AI 模型} C --\u0026gt;|返回动作/信息| B B --\u0026gt;|控制| D[自动化代理] D --\u0026gt;|操作| E[目标应用程序/UI] E --\u0026gt;|返回UI状态/截图| D D --\u0026gt;|发送| B B --\u0026gt;|生成| F[可视化报告] B --\u0026gt;|提供| G[Playground\u0026lt;调试\u0026gt; ] B --\u0026gt;|利用| H[缓存机制] subgraph 目标平台 E -- Web --\u0026gt; E1[浏览器\u0026lt;Playwright/Puppeteer\u0026gt;] E -- Android --\u0026gt; E2[Android 应用] end subgraph AI 模型类型 C -- 多模态 LLM --\u0026gt; C1[GPT-4o, Gemini-2.5-Pro] C -- 视觉语言模型 --\u0026gt; C2[Qwen2.5-VL, Doubao-1.5-thinking-vision-pro, UI-TARS] end subgraph 辅助工具 F --\u0026gt; F1[报告文件] G --\u0026gt; G1[内置调试环境] H --\u0026gt; H1[提高效率/重放] end I[MCP 客户端] --\u0026gt;|直接使用能力| B ","date":"2025-06-22T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/081-midscene%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/snap_20250621-5_hu_ac2dbe7ca199e358.png","permalink":"https://chengxiaqiucao.github.io/post/081-midscene%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","title":"AI自动化工具Midscene.js源码解析"},{"content":"之前曾经收集过一些用于测试练习的项目，清单详见（），但这些项目更多还是基于自动化测试练习目的，却很少有真正用于练习软件测试和故障发现能力的项目，所以便萌生了自己做一个这种项目的目的。\n设计思路 以一个真实需求的的项目开发为例，参照模拟敏捷研发的流程，按Sprint来进行迭代。每个迭代根据指定的需求来进行实现，但同时包含一些注入的已知Bug。\n练习者可以将每个迭代对应的分支（如sprint0，sprint1）看作提测版本进行测试和练习。同时也可以\n诚邀共建 个人力量有限，现邀请各位测试小伙伴一起共同完善该Demo项目，包括完善测试用例，补充存在的Bug清单和其他关联文档等，争取可以为测试初学者提供一个贴合实际软件研发、有实际学习价值的Demo。\n回复 进群 进入测试交流群，和群友交流测试技术，共同完善和进步~\n项目地址和介绍 https://github.com/chengxiaqiucao/TestMyBookshelf\nsprint 首页 sprint1 首页 欢迎多提Issue~~\nReadMe文档如下：\n个人图书管理 \u0026ndash; 我的书架 测试练习项目 | 包含注入缺陷的图书管理系统 | FastAPI + SQLite 实现 | 适合 QA 培训使用\n这是一个用于测试练习作用的个人图书管理系统。该项目故意注入了一些典型的 Bug，用于测试人员练习 Bug 发现和验证。\n项目特点 基础功能完整：实现了图书的增删改查等基本功能\n典型 Bug 注入：包含多个常见的问题场景\n技术栈简单：使用主流但轻量级的技术组合\n适合测试练习：Bug 类型多样，重现步骤清晰\n使用 切换到不同sprint分支，针对分支需求进行测试\n注意事项 本项目主要用于测试练习，不建议用于生产环境\n所有 Bug 都是故意注入的，用于测试练习\n项目代码中不会标注 Bug 的位置，需要测试人员自行发现\n测试目标 验证所有注入的 Bug 是否可重现\n练习 Bug 报告编写\n熟悉常见 Web 应用问题\n提高测试用例设计能力\n","date":"2025-06-19T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/101-testmybookshelf/snap_20250611_hu_1b912e81f896c124.png","permalink":"https://chengxiaqiucao.github.io/post/101-testmybookshelf/","title":"开源一个测试练习项目，邀请大家共建"},{"content":"上一篇，我们介绍了通过腾讯的智能编程助手开发了一款微信小程序，动态获取过去一个月新出现的最热门开源工具。\n初版虽然很快就搭建出来了，奈何bug不少，又经过数小时的不断调教，功能总算基本正常了。 项目的Readme介绍文档：\n以下就是上一个月最受欢迎的几个开源项目，我们也一起了解下，现在最受关注的项目都是哪些？\n1. bytedance/deer-flow 字节跳动的深度研究框架，基于LangChain/LangGraph构建多智能体（Multi-Agent）系统，支持复杂任务如自动生成研究报告、PPT及双人播客（借助火山引擎TTS）。其创新点包括：\nReplay模式：可视化多轮Agent协作流程，便于调试与学习。 人机协同：用户可通过自然语言实时修改AI生成内容，动态调整研究方向和细节。 高效架构：通过\u0026quot;Handoffs\u0026quot;机制减少Token消耗，优化任务执行流程。\n适用场景：自动化内容生成、学术研究助手。需Python 3.12+和Node.js 22+环境部署。 总之，把AI打造成一个小团队，协作完成一些复杂任务。而且随时插手实时改变它的工作方向，不至于看AI在错误的方向上一路狂奔！\nGitHub：https://github.com/bytedance/deer-flow\n2. agentcodee/cursor-free-everyday 破解Cursor Pro版限制的工具，解决官方14天试用期后的功能封锁问题（如GPT-4调用次数限制）。特点包括：\n自动账号管理：一键获取临时账号，绕过设备绑定限制。 全平台支持：兼容Windows/macOS/Linux，提供图形化激活程序。 免费开源：社区驱动，持续更新适配新版本。 一句话：绕过Cursor IDE的14天试用限制，白嫖GPT-4写代码。\nGitHub：https://github.com/agentcodee/cursor-free-everyday\n3. ngxson/smolvlm-realtime-webcam 基于轻量视觉模型SmolVLM（20亿参数）的实时摄像头处理工具，专为边缘计算设计。核心优势：\n低资源需求：预加载模型+多线程优化，低配设备可流畅运行。 即插即用：提供Python/Node.js脚手架，快速实现物体识别、人流统计等功能。 端侧适配：图像Token压缩率提升9倍，推理速度较同类模型快3-16倍。 用2B参数小模型就可以在普通电脑跑实时图像识别。\nGitHub：https://github.com/ngxson/smolvlm-realtime-webcam\n4. enescingoz/awesome-n8n-templates（生态项目） n8n自动化工具的模板库，提供开箱即用的工作流示例（如滴答清单同步Notion）。技术亮点：\n事件驱动架构：通过HTTP节点、Shell脚本节点灵活集成第三方API。 低成本自托管：支持Docker部署，替代Zapier等高成本方案。 扩展性：可结合OpenAI API增强自动化逻辑（如邮件自动分类）。 n8n是智能工作流的主流方案，这个库其实就是提供大量抄作业模板\nGitHub：https://github.com/enescingoz/awesome-n8n-templates\n5. ag-ui-protocol/ag-ui AI Agent与前端交互协议，标准化多智能体协作的通信流程。核心特性：\n事件驱动：定义16种标准事件（如状态同步、流式消息），支持SSE/WebSocket传输。 框架兼容：无缝接入LangGraph、CrewAI等Agent框架。 安全路由：通过Secure Proxy中间件保障通信安全。 通过这个库，规范化了AI和前端界面的交互标准，突破长时间等待AI出结果以及在任务执行中随时干预的优点。\nGitHub：https://github.com/ag-ui-protocol/ag-ui\n","date":"2025-06-05T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/100-temp/snap_20250604_hu_b00e48a76dcb3279.png","permalink":"https://chengxiaqiucao.github.io/post/100-temp/","title":"Github月度新锐热门工具 - 202506"},{"content":"前言 AI已经越来越深入地走入我们的实际工作，在软件测试领域，和AI相关的新测试工具、方法也层出不穷。在之前我们介绍过结合 mcp server 实现 AI 驱动测试的案例，本文我们将介绍一个近期崭露头角的国产AI测试工具 Midscene.js\nMidscene.js简介 MidScene.js 是由字节跳动 web-infra 团队推出的一个开源 ai 自动化测试工具，基于多模态大模型，通过针对页面的智能视觉解析来理解我们的自然语言指令，并进一步完成自动化操作。可以显著降低编写自动化测试脚本的复杂性，并更好适应页面结构和元素的变化，使自动化测试脚本的稳定性也有较大提升。\n官网地址： https://midscenejs.com/\nMidscene工作原理 和之前我们介绍 mcp server 时，利用通用大模型来理解页面并调用本地工具能力进行扩展不同，Midscene使用多模态大模型如 ChatGPT-4o，qwen-vl, 字节的 UI-TARS等，也就是能支持视觉输入的大模型来理解页面，更接近我们进行实际功能测试的场景。\nMidScene会首先获取页面当前截图和具体的页面结构信息，再和用户指令一起提交给大模型，由大模型判断出需要操作的页面控件位置，并进行下一步动作。\n以在待办页面任务框中输入 “今天学习Playwright”为例：\nMidScene的内部操作大致如下：\n获取用户指令 “在任务框输入 学习Playwright，按回车键” MidScene截图，获取页面整体元素结构 提交大模型完成页面特征提取 获取大模型分析结果，确定下一步操作类型(Tap)和控件的具体位置(坐标) 规划下一步操作 完成执行 大模型的选择 从以上Midscene的原理分析，MidScene 主要依赖多模态大模型的如下能力\n理解截图和 规划 操作步骤的能力。 给出指定元素的坐标信息（Visual Grounding）的能力。 支持以上能力的大模型，目前官网提供的支持包括如下几种：\nOPENAI GPT-4o 阿里 Qwen-2.5-VL 字节 UI-TARS 字节火山引擎 Doubao-1.5-thinking-vision-pro Google Gemini-2.5-Pro 从工作原理上，需要提供给大模型包括截图和页面结构等信息，对大模型的Token消耗还是比较可观。从官方的评估，每个操作通常都要至少数千Token的消耗。而其中性价比较好的大模型，官方推荐的QWen-VL。\nChrome插件方式使用 零代码的Chrome插件方式，可以帮助我们快速理解MidScene的应用。\n通过Chrome的插件商店可以直接安装 Midscene插件\n配置大模型 启用插件后，需要配置使用的大模型。这里我们使用对token消耗比较少的阿里千问多模态模型qwen-vl-max-latest, 通过阿里云百炼平台申请对应的API Key即可，现在申请还赠送100W Token额度。\n完成申请后，在插件的模型配置界面中配置对应的大模型参数，qwen模型需要配置以下四个参数\n1 2 3 4 OPENAI_BASE_URL=\u0026#34;https://dashscope.aliyuncs.com/compatible-mode/v1\u0026#34; OPENAI_API_KEY=\u0026#34;sk- your API KEY\u0026#34; MIDSCENE_MODEL_NAME=\u0026#34;qwen-vl-max-latest\u0026#34; MIDSCENE_USE_QWEN_VL=1 操作浏览器 接下来就可以在插件界面中体验Midscene对浏览器的操控了，这里主要支持四种行为：\nAction：对应AI自动规划操作，Midscene会自动规划操作步骤并执行。更智能，但速度较慢，效果依赖大模型的质量。 Query：直接从 UI 提取数据，并借助多模态 AI 的推理能力，实现智能提取 Assert：通过自然语言描述一个断言条件，让 AI 判断该条件是否为真 Tap：对应页面点击的即时操作，Midscene会直接执行，大模型只负责底层如元素定位等任务。效率更高，适合已确定要执行的操作时使用 我们可以用接近自然语言的AI提示词输入提示词指令，针对不同的行为模式，插件会驱动浏览器完成不同的操作，并反馈操作结果。\n具体执行过程也可参见下方视频演示。\n脚本集成 除了通过浏览器插件调用Midscene，更推荐的方法是通过测试框架的脚本集成Midscene能力。\n通过脚本集成，同样需要配置相关模型调用参数，和插件中配置的相关变量值一样，只是需要将相关变量配置为系统环境变量\n因为 Midscene 是基于JS的工具，这里的和测试框架集成，也是需要支持JS。这里以 Playwright 为例\n安装 首先自然需要具备 Playwright 框架，进入项目目录，初始化并安装Playwright，然后安装Midscene\n1 2 3 npm init playwright@latest npm install @midscene/web --save-dev playwright框架配置 在 playwright.config.ts 文件中配置框架本身的测试发现目录和测试脚本，加载环境变量以及浏览器类型，执行策略等基础配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import { defineConfig, devices } from \u0026#34;@playwright/test\u0026#34;; import dotenv from \u0026#34;dotenv\u0026#34;; /* 通过dotenv从.env文件中加载环境变量 */ dotenv.config(); export default defineConfig({ testDir: \u0026#34;./e2e\u0026#34;, testMatch: \u0026#34;**/*.spec.ts\u0026#34;, timeout: 10 * 60 * 1000, /* Run tests in files in parallel */ fullyParallel: false, /* Fail the build on CI if you accidentally left test.only in the source code. */ forbidOnly: Boolean(process.env.CI), /* Retry on CI only */ retries: process.env.CI ? 2 : 0, /* Opt out of parallel tests on CI. */ workers: process.env.CI ? 1 : undefined, /* Reporter to use. See https://playwright.dev/docs/test-reporters */ reporter: [[\u0026#34;line\u0026#34;], [\u0026#34;@midscene/web/playwright-report\u0026#34;]], /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */ use: { /* Base URL to use in actions like `await page.goto(\u0026#39;/\u0026#39;)`. */ // baseURL: \u0026#39;http://127.0.0.1:3000\u0026#39;, /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */ trace: \u0026#34;on-first-retry\u0026#34;, }, /* Configure projects for major browsers */ projects: [ { name: \u0026#34;chromium\u0026#34;, use: { ...devices[\u0026#34;Desktop Chrome\u0026#34;] }, }, ], }); 测试脚本 通过单独的fixture脚本引入Midscene库\nfixture.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { test as base } from \u0026#39;@playwright/test\u0026#39;; import type { PlayWrightAiFixtureType } from \u0026#39;@midscene/web/playwright\u0026#39;; import { PlaywrightAiFixture } from \u0026#39;@midscene/web/playwright\u0026#39;; export const test = base.extend\u0026lt;PlayWrightAiFixtureType\u0026gt;(PlaywrightAiFixture({ waitForNetworkIdleTimeout: 10000, // 可选, 交互过程中等待网络空闲的超时时间, 默认值为 2000ms, 设置为 0 则禁用超时 })); 编写脚本测试 https://todomvc.com/ 待办清单示例项目，通过 .ai、.aiTap、 .aiQuery、.aiAssert等API方法，对应前面说到的四种典型操作。\ntodo_spec.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import { expect } from \u0026#34;@playwright/test\u0026#34;; import { test } from \u0026#34;./fixture\u0026#34;; test.beforeEach(async ({ page }) =\u0026gt; { await page.goto(\u0026#34;https://todomvc.com/examples/react/dist/\u0026#34;); }); test(\u0026#34;ai todo - Chinese Prompt\u0026#34;, async ({ ai, aiQuery, aiAssert, aiTap }) =\u0026gt; { // .ai - 通用 AI 操作方法 await ai(\u0026#34;在任务框 input 输入 今天学习 Playwright，按回车键\u0026#34;); await ai(\u0026#34;在任务框 input 输入 明天学习 js脚本，按回车键\u0026#34;); await ai(\u0026#34;在任务框 input 输入 后天学习 AI测试，按回车键\u0026#34;); await ai(\u0026#34;将鼠标移动到任务列表中的第二项\u0026#34;); await aiTap(\u0026#34;第二项任务右边的删除按钮\u0026#34;); // .aiTap - 指定操作类型 await aiTap(\u0026#34;第二条任务左边的勾选按钮\u0026#34;); await aiTap(\u0026#34;任务列表下面的 completed 状态按钮\u0026#34;); // .aiQuery - 页面信息提取操作 const list = await aiQuery(\u0026#34;string[], 完整的任务列表\u0026#34;); expect(list.length).toEqual(1); // .aiAssert - 断言操作 await aiAssert(\u0026#39;列表下方有一个区域显示有 \u0026#34;1 item left\u0026#34;\u0026#39;); }); 执行脚本：\n1 npx playwright test --headed 执行过程可以参见我录制的视频\n【】\n可视化结果报告 报告是Midscene的一大亮点，通过这个报告可以回看整个执行过程，并详细显示AI的空间判断过程和具体操作细节，便于调试和优化脚本。\nYAML文件驱动 除了通过测试框架脚本的集成方法，Midscene也支持直接通过YAML文件编写测试脚本，实现无代码的脚本驱动，类似于传统自动化的关键字驱动方式。\n这种方式，本质上其实还是将对应关键转化为 Midscene 支持的相关API来进行驱动。\n类似如下的格式， 操作天气网站：\n1 2 3 4 5 6 7 8 9 10 11 12 web: url: https://www.bing.com tasks: - name: 搜索天气 flow: - ai: 搜索 \u0026#34;今日天气\u0026#34; - sleep: 3000 - name: 检查结果 flow: - aiAssert: 结果中展示了天气信息 运行yaml格式脚本，需要安装Midscene的命令行支持\n1 2 3 4 npm install @midscene/cli --save-dev # 执行 npx midscene ./weather.yaml MCP方式 除了上述方式之外，Midscene也提供了作为本地MCP server方式。这种方式，其实是将MidScene的Chrome插件作为本地能力封装到MCP中，再通过大模型结合mcp server的方式完成浏览器驱动。\n关于 mcp server的介绍和使用，可以参考我之前的相关文章 【】\nmcp server 配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;mcpServers\u0026#34;: { \u0026#34;mcp-midscene\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;npx\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;-y\u0026#34;, \u0026#34;@midscene/mcp\u0026#34;], \u0026#34;env\u0026#34;: { \u0026#34;MIDSCENE_MODEL_NAME\u0026#34;: \u0026#34;REPLACE_WITH_YOUR_MODEL_NAME\u0026#34;, \u0026#34;OPENAI_API_KEY\u0026#34;: \u0026#34;REPLACE_WITH_YOUR_OPENAI_API_KEY\u0026#34;, \u0026#34;MCP_SERVER_REQUEST_TIMEOUT\u0026#34;: \u0026#34;800000\u0026#34; } } } } 当前版本的局限 虽然Midsence工具已经展现出不俗的潜力，目前也还在持续更新和迭代中，但在实用上还是具有不少缺陷，主要表现在：\n交互类型有限：目前仅支持点击、拖拽(只在 UI-TARS 模型中支持)、输入、键盘和滚动操作。 稳定性风险：AI 模型的返回值不能保证 100% 准确。对提示词的编写要求较高 元素识别能力：部分大模型在元素识别上的能力不太好，比如iframe、canvas等元素的交互。而且对于Chrome的原生控件如弹出提示、右键菜单等还不能支持。 成本较高：基于视觉识别方式，对Token的消耗比较可观，如果使用付费大模型，成本比较高昂。 但瑕不掩瑜，Midscene在UI自动化测试借助AI能力的提升上，已经迈出了坚实的一步！后续我们还会持续关注其进一步发展！\n参考阅读： 【】 【】\n进群，大纲\n","date":"2025-06-01T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/099-midscene.js%E7%9A%84%E4%BD%BF%E7%94%A8/snap_20250521_hu_e1e9efb260050ac6.png","permalink":"https://chengxiaqiucao.github.io/post/099-midscene.js%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"AI自动化工具Mid scene.js评测"},{"content":"何为Magentic UI？ Magentic UI 是微软于5.19重磅发布的开源Agent助手，并于24日刚更新了第二个版本0.04版\n从官方的介绍来看，目标是打造一款 以人为中心 的智能助手，其底层由多个不同的智能体系统驱动，能够实现网页浏览与操作、代码生成与执行、文件生成与分析等功能。\n它区别于其他一些AI浏览器工具的主要区别在于其 透明可控的交互界面，支持高效的人机协同参与。该系统基于微软的Agent构建框架 AutoGen 构建，目前还处在原型研究阶段。\n核心功能包括：\n🧑‍🤝‍🧑 协同规划：用户和AI通过聊天和计划编辑器协作创建并修订分步执行计划。\n🤝 协同任务：用户可直接通过网页浏览器或聊天界面实时介入并指导任务执行。Magentic-UI 能在需要时主动确认或要求协助。\n🛡️ 操作防护：敏感操作需经用户明确批准后方可执行。\n🧠 计划学习与检索：从过往任务中学习经验以优化未来自动化流程，并将优秀方案保存至计划库。在后续任务中可自动或手动调用已存储的计划。\n🔀 并行任务执行：支持多任务并行运行，会话状态指示器会实时提示 Magentic-UI 何时需要您的输入或任务已完成。\n设计架构 Magentic-UI 的底层系统是由一组从 AutoGen 的 Magentic-One 系统（如上图所示）改造而来的专业化 Agent 组构成，各Agent通过模块化协作实现不同功能：\nAgent功能说明 总控代理（Orchestrator） 功能定位：基于大语言模型（LLM）的主控智能体，负责与用户协同制定计划、决策何时请求用户反馈，并向其他智能体分配子任务。 协作流程： 与用户共同制定分步执行计划； 动态判断需用户介入的节点； 将子任务分派至其他智能体执行。 网页浏览代理（WebSurfer） 功能定位：配备网页浏览器的 LLM 智能体，支持多轮次网页交互操作。 核心能力： 根据总控代理的指令，执行点击、输入、滚动、页面跳转等操作； 超越 AutoGen 多模态网页浏览器：新增标签管理、选项选择、文件上传及多模态查询支持。 代码执行代理（Coder） 功能定位：配备 Docker 代码执行容器的 LLM 智能体。 核心能力： 编写并执行 Python 和 Shell 命令； 将执行结果反馈至总控代理。 **文件处理代理（FileSurfer） **\n功能定位：集成 Docker 容器与 MarkItDown 包文件转换工具的 LLM 智能体。 核心能力： 定位 Magentic-UI 控制目录下的文件； 将文件转换为 Markdown 格式并支持内容问答。 用户代理（UserProxy） 功能定位：代表用户与系统交互的代理角色。 协作模式：总控代理可将任务直接委派给用户（而非其他智能体）完成。 用户交互流程 用户利用 Magentic UI 的交互流程可以用下图表示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 graph TD A[用户发起请求] --\u0026gt; B[输入文本/附加图片]; B --\u0026gt; C{Magentic-UI 生成分步计划}; C -- 生成成功 --\u0026gt; D[用户进入计划编辑界面]; C -- 生成失败 --\u0026gt; C1[提示用户重新输入]; C1 --\u0026gt; B; D -- 用户编辑计划 --\u0026gt; E{编辑操作}; E -- 添加/删除/修改步骤 --\u0026gt; D; E -- 确认完成 --\u0026gt; F[总控代理存储计划]; F --\u0026gt; G[启动计划执行引擎]; G --\u0026gt; H{按顺序执行步骤}; H --\u0026gt; I{当前步骤类型?}; subgraph 具体步骤执行 direction LR I -- WebSurfer --\u0026gt; J[执行网页操作]; I -- Coder --\u0026gt; K[生成并执行代码]; I -- FileSurfer --\u0026gt; L[处理文件]; I -- UserProxy --\u0026gt; M[提示用户手动操作]; end J --\u0026gt; N{步骤是否成功完成?}; K --\u0026gt; N; L --\u0026gt; N; M --\u0026gt; N; N -- 是 --\u0026gt; O{所有步骤均已完成?}; N -- 否 --\u0026gt; P[记录错误原因]; P --\u0026gt; Q{是否需要重新规划?}; Q -- 是 --\u0026gt; R[请求用户许可重新规划]; R -- 同意 --\u0026gt; C; R -- 拒绝 --\u0026gt; S[终止流程]; Q -- 否 --\u0026gt; S; O -- 是 --\u0026gt; T[生成最终结果]; O -- 否 --\u0026gt; H; T --\u0026gt; U[向用户呈现结果]; U --\u0026gt; V[结束]; 输入与计划生成\n用户通过文本/图片触发流程，系统生成初始计划。若失败则提示用户重新输入。 用户通过编辑界面迭代优化计划，确认后进入执行阶段。 计划执行逻辑\n总控代理按步骤分配任务至对应智能体（WebSurfer/Coder/FileSurfer）或用户。 每个步骤完成后验证状态，若失败则判断是否需要重新规划（需用户授权）。 动态控制与终止\n用户可随时干预：暂停执行、修改计划或终止流程。 所有步骤完成后交付最终结果，异常情况下提供透明错误反馈。 工具部署 Magentic AI 主要基于Python 开发，Web部分基于FastAPI。而它的AI控制主要通过 Playwright 控制 Docker 容器中的一个虚拟浏览器，且可以实时显示给用户。而背后的大模型则主要基于各个开放大模型的API接入方式使用。\n所以要部署Magentic UI，需要先确认相关前置条件：\nDocker已安装，如果是Window系统，安装Docker Desktop，且和WSL集成 提供大模型的接入API KEY，默认使用的是 OPENAI 的API KEY Python运行环境且 \u0026gt;3.10 版本 是在WSL中部署的这个工具， 首先创建python虚拟环境，然后安装Magentic AI及相关依赖\n1 2 3 python3 -m venv .venv source .venv/bin/activate pip3 install magentic-ui 确保Docker已启动, 运行Magentic UI前应该没有相关容器在运行\n1 docker ps 大模型这里可以使用微软Azure AI上的OPENAI, ， 完成配置后，将对应api key设置为环境变量 OPENAI_API_KEY\n1 export OPENAI_API_KEY=\u0026#34;YOUR_API_KEY\u0026#34; 另外Magentic UI本身需要对大模型进行配置，Azure AI的配置模板如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 model_config: \u0026amp;client provider: AzureOpenAIChatCompletionClient config: model: gpt-4o azure_endpoint: \u0026#34;\u0026lt;YOUR ENDPOINT\u0026gt;\u0026#34; azure_deployment: \u0026#34;\u0026lt;YOUR DEPLOYMENT\u0026gt;\u0026#34; api_version: \u0026#34;2024-10-21\u0026#34; azure_ad_token_provider: provider: autogen_ext.auth.azure.AzureTokenProvider config: provider_kind: DefaultAzureCredential scopes: - https://cognitiveservices.azure.com/.default max_retries: 10 orchestrator_client: *client coder_client: *client web_surfer_client: *client file_surfer_client: *client action_guard_client: *client 运行 然后运行Magentic ui, 默认使用8081端口，首次运行会下载多个不同docker镜像及相关依赖，时间较长，等待安装完成\n1 magentic ui --port 8081 等运行log中出现如下信息，则启动成功\n1 | INFO | magentic_ui.backend.web.app:lifespan:59 - Application startup complete. Navigate to http://127.0.0.1:8081 浏览器访问 http://localhost:8081\n会看到如下界面 启动一个会话后，比如让AI协助我们完成一个测试\n1 请测试saucedemo.com网站的不同用户登录功能是否正常，并汇总问题为markdown格式 如安装正确，大模型调用正常，那么Magentic UI 就会规划相关任务计划，并让用户确认\n用户也可以根据相关反馈，对计划进行调整，在计划执行过程中，也可以和AI交互，变更它的执行路径。具体的执行演示，可参看下方视频。\n这时查看WSL中的docker 运行信息，可以看到运行了3个容器，其中两个是mangenti UI的coder 和 file surfer 智能体，另一个是可远程查看的 vnc_browser 容器\n一系列步骤执行完成，Magentic UI根据最开始的指令，得到了如下markdown格式结果汇总。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 以下是对saucedemo.com网站不同用户登录功能测试的结果汇总： 1. **标准用户** (`standard_user`): - 登录成功。 - 无问题，用户可以正常访问库存页面并浏览产品。 2. **被锁定用户** (`locked_out_user`): - 登录失败。 - 显示错误消息 \u0026#34;Epic sadface: Sorry, this user has been locked out.\u0026#34; 账户已被锁定，无法访问。 3. **问题用户** (`problem_user`): - 登录成功。 - 产品图像存在不匹配的问题，图像错误是已知问题。 4. **性能故障用户** (`performance_glitch_user`): - 登录成功。 - 无明显系统减慢或异常，用户可以正常导航。 这些结果表明网站能够正确处理不同账户类型的登录场景。如果您想亲自测试，可以访问 [saucedemo.com](https://www.saucedemo.com/)。 使用体会 总体应用下来，把AI重新定位为辅助者角色，显然更贴合当前AI应用的实际，而且通过容器实时显示AI的操作过程，使AI执行任务不再像个黑盒，确实友好了很多。\n不过应用中感觉还是实用性不是太好，虽然官方已声明现阶段还是研究性质，但尚有较大改进空间。\n安装和配置比较复杂，各种依赖包众多，耗时较久 大模型本身能力对执行过程，包括是否能正常完成交互都有较大影响。调用失败和异常较多。 大模型的token消耗比较可观，完成一个任务，其实会分解多数十个不同请求，而每个请求的token消耗也是数千计，实用付费模型的话，成本高昂 下图是Azure后台查看的我试验期间的token消耗，比较可观。\n总之，Magentic UI 的发展方向值得期待，但当下还需要多等待它的进一步完善。\n","date":"2025-05-30T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/097-magenticui%E8%AF%84%E6%B5%8B/magentic_logo_hu_aa21c3380c93ae94.png","permalink":"https://chengxiaqiucao.github.io/post/097-magenticui%E8%AF%84%E6%B5%8B/","title":"微软重磅发布Magentic UI，交互式AI Agent助手实测！"},{"content":"在AI大模型飞速发展的今天，各类智能应用层出不穷。然而，当前许多大型语言模型（LLMs）仍面临一个核心挑战：记忆的缺失。也就是它们往往是“无状态”的，很多AI工具从性能考虑，有较严格的上下文窗口限定，超过这个窗口的历史交互信息就会被遗弃。导致AI无法在不同会话甚至同一会话的复杂交互中持续记住上下文，对话缺乏连贯性，并经常出现信息重复，无法处理长期任务。\n对于一个个性化的AI助手，如果每次交流它都“失忆”，不能指导你的偏好和习惯，这种体验无疑是令人沮丧的。正是为了解决这一痛点，一个名为 Mem0 的开源项目应运而生。它旨在为AI应用提供可扩展、持久且可插拔的记忆能力，让你的AI真正拥有“大脑”。\n其实在我们之前的文章中介绍过的Browser-Use这个开源项目，就使用了 Mem0 来实现任务记忆。\n本篇我们就来详细介绍下 Mem0 的核心理念、技术特点。\n为什么AI需要“记忆”？ 当前LLMs的强大主要体现在其对单次输入的高效处理能力上。它们能够生成流畅的文本、回答复杂的问题，但这些能力往往局限于当前的“提示”（prompt）窗口内。一旦对话结束或上下文超出窗口限制，之前的交互信息就会被遗忘。\n这种“无状态”的特性，导致了以下几个问题：\n上下文丢失：长时间对话中，AI无法记住早期内容，导致重复提问或理解偏差。 个性化缺失：AI无法基于用户的历史行为和偏好提供定制化服务。 长期任务受限：对于需要多轮交互、信息累积才能完成的任务（如项目管理、复杂规划），无记忆的AI难以胜任。 效率低下：用户不得不反复提供背景信息，降低了交互效率。 Mem0 的出现，则弥补了这一“记忆鸿沟”，让AI能够积累经验、学习成长。\nMem0 是什么？ Mem0 是一个开源的、模块化的框架，专为赋予LLMs可扩展、持久且可插拔的记忆能力而设计。 它将AI的记忆抽象为不同的层级，并提供了一套统一的API，使得开发者能够轻松地为任何LLM应用添加记忆功能。\n简单来说，Mem0 就是AI应用的一个外置“记忆库”。它能够捕获、存储和检索AI与用户交互过程中产生的所有相关信息，并在需要时将其注入到LLMs的上下文中，从而实现更连贯、更智能的对话和任务执行。\nMem0 的核心特性说明 Mem0 的强大之处在于其精心设计的架构和丰富的功能集：\n分层记忆架构：Mem0 将记忆分为不同类型，以适应不同的需求：\n短暂记忆 (Ephemeral Memory)：存储短期的、会话内的上下文信息，类似于人类的短期记忆。 长期记忆 (Long-Term Memory)：存储重要的、需要长期保留的知识和经验，通过语义嵌入实现高效检索。 归档记忆 (Archival Memory)：用于备份和审计，确保所有交互都有迹可循。 知识记忆 (Knowledge Memory)：专为存储外部知识库设计，例如文档、网页等。 高度可插拔（Pluggable）：Mem0 提供了灵活的集成能力，支持与多种主流LLM服务（如OpenAI、Anthropic、Groq等）和向量数据库（如Qdrant、Pinecone、ChromaDB等）无缝协作。 这意味着开发者可以根据自己的需求和偏好，自由选择后端服务。\n多租户支持：Mem0 支持多租户架构，允许为不同的用户或应用实例创建独立的记忆空间，确保数据隔离和安全性，这对于构建SaaS产品尤为重要。\n开发者友好：提供简洁易用的Python SDK，并计划支持JavaScript/TypeScript，大大降低了开发者集成记忆功能的门槛。\n与主流框架集成：原生支持 LangChain、LlamaIndex 等流行的LLM应用开发框架，加速了开发流程。\nBrowser-Use 对 Mem0 的应用分析 Browser-Use 旨在让AI agent能够像人类一样，在浏览器中执行复杂的任务。它利用了Mem0 来赋予AI agent “记忆”能力，在执行任务时，可以根据设定，记录多达100甚至更多的操作步骤详细信息，作为后续步骤的参考。\n通过集成 Mem0，Browser-Use 项目中的AI agent获得了以下关键能力：\n浏览历史记忆与导航优化 AI agent访问过的每一个URL、每一个交互（点击、输入），都可以通过Mem0存储为短暂记忆或转化为长期记忆。\n当用户要求agent “回到之前搜索的结果页面” 时，agent不再需要从头开始搜索，而是可以直接从Mem0中检索历史URL并导航过去，大大提升了效率和用户体验。\n复杂任务的上下文保持 比如一个AI agent需要完成一个跨多个页面的在线购物流程：搜索商品 -\u0026gt; 添加购物车 -\u0026gt; 填写地址 -\u0026gt; 支付。\nMem0 可以在每一步都存储当前的页面状态、用户输入、商品详情等短暂记忆。即使流程中断，agent也能从Mem0中加载之前的上下文，准确地从中断处继续，而不是“失忆”重来。\n例如，agent可以记住在某个商品页面上用户选择的颜色和尺码，即使跳转到购物车页面后又返回，这些信息依然存在。\n用户操作模式与偏好学习： 如果用户经常让AI agent在特定网站上执行相似的任务（如每天早上查看某个新闻网站的头条），Mem0 可以将这些高频行为模式转化为长期记忆。\n未来，AI agent可以更智能地预测用户需求，甚至主动推荐或预加载相关内容，实现真正的个性化浏览器操作体验。\n多会话任务的持久性： 对于需要几天才能完成的复杂研究任务（如收集某个主题的资料），AI agent可以将每个浏览会话中的关键发现、已访问的资源和任务进度存储在Mem0的长期记忆中。\n即使关闭浏览器，下一次启动时，agent也能加载这些记忆，继续之前的研究，确保任务的连续性和完整性。\n通过上述剖析，我们可以清晰地看到 Mem0 如何帮助 Browser-Use 项目中的AI agent从一个“即用即弃”的工具，转变为一个能够理解浏览器环境、记住历史操作、并持续执行复杂任务的智能助手。 它让AI agent不再仅仅是机械地执行指令，而是能够积累经验、适应环境、并提供更流畅、更人性化的自动化浏览体验。\n总结 在构建真正智能、能够进行复杂交互的AI应用时，记忆能力是不可或缺的一环。Mem0 作为一款专注于为LLMs提供可扩展、持久且可插拔记忆的开源框架，无疑为开发者们提供了强大的工具。它通过分层记忆、灵活的集成能力和开发者友好的设计，极大地简化了AI记忆功能的实现。\n无论是赋能像 Browser-Use 这样的AI浏览器agent，使其在复杂的网页交互中拥有持久记忆，还是构建更聪明的个人助手、客服机器人，Mem0 都能提供坚实的基础。\n对于希望打造个性化助手或让自己的AI Agent更贴合实际应用场景，Mem0是一个不可不了解的AI生态工具。\n","date":"2025-05-27T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/098-mem0/Pasted-20250722_hu_8166738c3a2052a5.png","permalink":"https://chengxiaqiucao.github.io/post/098-mem0/","title":"mem0，让AI拥有记忆，打造个性化助手的基石"},{"content":"前言 自动化测试是现如今软件研发中不可或缺的重要环节。而为了确保测试环境的一致性、简化配置并加速测试的反馈，Docker 技术被广泛应用于测试自动化框架，进行容器化封装。\n通常的共识是：一旦测试套件被 Docker 化，即可实现 “一次构建，处处运行” 的理想状态，彻底消除环境差异带来的测试不确定性。\n然而，在实际工程实践中，Docker 化是否真的能完美保障测试执行的一致性？本篇我们将深入探讨 Docker 在自动化测试应用中的承诺与现实，揭示那些可能导致“一致性幻象”的关键因素，并提供相应的规避策略。\nDocker 的承诺：环境封装与一致性 Docker 的核心价值在于通过镜像（Image）封装应用的完整运行环境（操作系统层、运行时、库、工具、代码及配置）。其工作流程通常为：\n构建镜像：在开发环境（如开发者本地PC）中，通过 Dockerfile 定义依赖安装和配置步骤，构建包含测试套件及其运行环境的镜像。 分发镜像：将构建好的镜像推送到镜像仓库（如 Docker Hub, Artifactory）。 运行容器：在目标环境（CI/CD 流水线、其他开发者机器、生产前环境等）中拉取该镜像并实例化为容器执行测试。 理论上，此流程应确保无论底层宿主机的具体配置如何，容器内部的测试执行环境始终保持一致，从而消除开发者 “在我机器上能跑” 的经典问题，实现测试结果的可靠复现。\n现实：一致性的幻想 理想丰满，现实骨感。尽管 Docker 提供了强大的环境隔离能力，但以下因素仍可能破坏测试的绝对一致性，形成“幻象”：\n跨平台的宿主架构差异 在 x86 架构宿主机上构建的镜像，在基于 ARM 架构的 CI 节点（如 Apple Silicon M1/M2）上运行时，可能导致依赖特定 CPU 指令集的二进制文件、包含 C 扩展的 Python 包等运行异常或崩溃，致使本地通过的测试在 CI 失败。\n原因：Docker 容器共享宿主机的内核。不同 CPU 架构（x86_64 vs arm64）的指令集不兼容。\n如何解决？ 多架构镜像构建：使用 docker buildx 工具构建支持多平台（如 linux/amd64, linux/arm64）的镜像。 显式指定平台：在运行或构建时通过 --platform 参数强制指定目标平台（如 docker run --platform linux/amd64 my-test-image）。 外部依赖 测试容器内运行良好，但若测试用例需要访问容器外的真实服务（数据库、API、S3、需 VPN 访问的内部系统），则测试结果可能受外部服务的状态、网络延迟、DNS 解析差异、防火墙规则或 VPN 连接状态影响而波动。\n原因：Docker 容器化的是测试套件本身，而非其依赖的所有外部系统。网络请求突破了容器的隔离边界。\n如何解决？ 依赖容器化：使用 Docker Compose 在测试运行时动态拉起所需的外部服务（如数据库、Mock 服务器）作为独立的容器，并与测试容器建立内部网络连接。 Mock/Stub 技术：在单元测试和集成测试中广泛应用 Mock 和 Stub 技术替代真实的外部依赖调用。 网络环境控制：严格管理测试环境的网络配置（DNS、代理、防火墙），确保其可预测性。 宿主操作系统差异 在 Linux 宿主机上运行正常的挂载卷（Volume Mounts）操作或网络访问（localhost），在 macOS 或 Windows（通过 Docker Desktop）上可能出现文件权限错误、符号链接失效、换行符（CRLF vs LF）问题、inotify 事件监听失效，或 localhost 指向歧义。\n原因：虽然容器内 OS 一致，但 Docker 与宿主 OS 交互的机制存在差异：\n文件卷挂载：涉及主机文件系统到容器文件系统的映射，不同 OS 对文件权限、元数据、事件通知的支持不同。 网络模型：在 Linux 上，容器网络通常更直接集成；在 macOS/Windows 上，Docker Desktop 使用虚拟机桥接，访问宿主机服务需使用特殊主机名 host.docker.internal 而非 localhost。 如何解决？ 理解平台差异：明确意识到 Docker 并非完全 OS 无关，其行为受宿主机影响。 谨慎使用挂载卷：避免测试核心逻辑过度依赖主机卷挂载，尤其对于写操作（如生成报告、缓存）。优先使用容器内路径或复制（COPY）机制。如需挂载，注意文件权限和换行符问题。 使用正确的网络访问方式：在容器内访问宿主机服务时，统一使用 host.docker.internal（Mac/Windows）或了解 Docker 网络模式（bridge/host）下的服务访问规则（Compose 服务名）。避免硬编码 localhost。 资源约束 在资源充沛的本地开发机（如 16 核 32GB RAM）上测试通过，但在资源受限的 CI 节点（可能 CPU 被限流、内存不足、或与其他任务共享资源）上运行时，测试因超时、资源竞争（CPU、IO）而失败或变得不稳定（Flaky）。\n原因：Docker 容器共享宿主机的物理资源（CPU、内存、磁盘 IO、网络带宽）。CI 环境的资源配额通常低于开发机且存在竞争。\n如何解决？ 资源限制与监控：在 Docker 运行命令或 Compose 文件中为测试容器明确设置资源限制（--cpus, --memory），使其更接近 CI 环境。监控 CI 节点的资源使用情况。 性能优化：优化测试用例和框架本身，减少资源消耗（如并行化控制、避免内存泄漏、优化 I/O 操作）。 选择匹配的 CI 环境：确保 CI 环境的基础资源配置能满足测试运行的最低要求。 可变依赖与版本漂移：“latest”标签的隐患 镜像构建时使用基础镜像标签 FROM python:latest 或未严格锁定依赖版本 pip install -r requirements.txt（未使用 pip freeze 或版本锁文件），导致后续构建的镜像因底层依赖（Python 解释器、库）的意外升级而引入不兼容或 Bug，破坏测试稳定性。\n原因：依赖项的“latest”标签或未锁定的版本号会随时间推移指向新版本，带来不确定性。\n如何解决？ 严格版本锁定：在 Dockerfile 中使用确定版本的基础镜像标签（如 FROM python:3.11-slim）。使用版本锁文件（如 requirements.txt 明确每个依赖的版本号，或使用 poetry.lock/Pipfile.lock）管理依赖项。 可重现的构建：确保基于相同的锁文件，每次构建都能生成完全一致的镜像。定期有计划地更新依赖版本并重新测试验证。 理性看待Docker 的价值与工程实践 尽管存在上述诸多问题，我们还是不应否定 Docker 在测试自动化中的巨大价值。它在环境标准化、简化依赖管理、让CI/CD流水线更易管理等方面，依然有着不可替代的优势。\n所以应用Docker，关键在于理解：Docker 是实现一致性的强大工具，但非一劳永逸的“银弹”。技术的应用还是需要通过良好的工程实践和有效约束发挥作用！\n总结 Docker 为测试自动化环境的一致性筑起了一道坚固的“围栏”，极大地提升了测试的可信度和效率。然而，“围栏”并非密不透风。\n宿主架构差异、外部依赖渗透、OS 交互特性、资源竞争以及依赖版本漂移等因素，都可能悄然侵蚀预期的绝对一致性。\n实现真正可靠的 Docker 化测试自动化，不仅需要熟练运用 Docker 技术本身，更要求我们秉持严谨的工程实践——明确环境边界、严格依赖管理、优化资源利用、持续监控改进。唯有如此，我们才能有效破除“一致性幻象”，让 Docker 真正成为保障软件质量的坚实基石。\n所以，下次当我们听到 “没问题，它已经 通过Docker容器化了”，不妨多问一句：\n它运行在什么架构上？ 依赖是否锁定？ 网络和文件访问是如何处理的？ 资源足够吗？ 知己知彼，方能运筹帷幄。\n","date":"2025-05-24T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/096-docker%E5%9C%A8%E8%87%AA%E5%8A%A8%E5%8C%96/Docker%E8%87%AA%E5%8A%A8%E5%8C%96_hu_7da9a6a7143e6cfd.png","permalink":"https://chengxiaqiucao.github.io/post/096-docker%E5%9C%A8%E8%87%AA%E5%8A%A8%E5%8C%96/","title":" 自动化测试中应用Docker的正反两面"},{"content":" 我们都知道，Deepseek是个文本模型，不具备生成图像能力。而在线的各种图像生成AI要么收费，要么有额度限制，这里就跟大家分享一个通过本地部署的Deepseek，全免费的AI生图技巧。\nAI生图接口 Deepseek本身目前当然是没办法生成图片，但 github 这个宝藏，自然是能找到惊喜。本文我们介绍的这个图像生成工具，来自一个德国的AI初创公司，支持文生图、文生音频等功能。\npollinations.ai 介绍 该项目支持通过基本的Restful API接口来完成图像的生成。\n开源项目地址：\nhttps://github.com/pollinations/pollinations\n官网：\nhttps://pollinations.ai/\n官网虽简陋，但无需注册和密钥，开源免费，简直太香了\nAPI定义 生成图像的API 是最基本的 get 方法\n1 GET https://image.pollinations.ai/prompt/{prompt} API支持的参数：\n参数 是否必须 作用 默认值 prompt Yes 图像生成提示词 model No 使用的生图模型 flux seed No 随机种子 width No 图像宽度（像素） 1024 height No 图像高度（像素） 1024 nologo No 是否保留pollinations的logo false private No 是否公开生成的图像 false enhance No 是否使用LLM增强提示词 false safe No 十八禁 false transparent No 透明背景(仅gptimage model有效). false 支持的模型清单：\nflux（基本模型） flux-pro（加强效果） flux-realism（写实风格） flux-anime（动漫风格） flux-3d（3D 风格） flux-cablyai（未知） turbo（快速生成） http的get方法，其实通过html是可以直接请求并渲染的，这就给我们基于Deepseek来完成图像生成带来机会。也就是我们可以制定规则，让Deepseek生成需要的提示词，并按HTML格式将 pollinations api 生成的图像在html中呈现出来\n本地Deepseek和cherry studio配置 本地通过 Ollama 部署 Deepseek，并通过cherry studio 交互的方法，在前文 【】中有详细描述，这里不再赘述。\n本地运行 Deepseek 模型后，比如 deepseek-r1:14b, 打开cherry studio， 增加一个角色，如图像生成助手。并设置其系统提示词，定义相关规则(具体提示词参见文末)\n接下来，测试一下，在 cherry studio 中输入：\n1 秋天，古城墙根下，一丛荒草随风摇摆 动漫风格，16:9 Deepseek 经过一番思考，成功生成了一幅 城下秋草图\n大家快试试吧~~\n附： 提示词设定规则模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #角色：你是一个专业的图像创作助手 #技能：能根据用户输入的简单描述，生成一幅完整画面的\u0026#34;详细描述\u0026#34;。 #规则： 1.用户输入的简单描述，插入到【输出】的{user_prompt}部分 2.生成的\u0026#34;详细描述\u0026#34;尽可能全面，细节丰富，从图像的专业生成角度补充如光线使用、构图、材质、视角、色彩、渲染方式等。 3.将\u0026#34;详细描述\u0026#34;插入到【输出】的{ai_chinese_prompt}部分 4.将\u0026#34;详细描述\u0026#34;完整、准确翻译成英文，插入到【输出】的{ai_english_prompt}部分 5.如果用户的描述中包含高度信息，直接插入到【输出】的{width}部分，否则插入默认值 1280 6.如果用户的描述中包含宽度信息，直接插入到【输出】的{height}部分，否则插入默认值 1280 7.如果出现比例，指宽:高，宽度默认用1280，根据比例计算高度，插入到【输出】的{height}部分 8.随机生成一个整数，插入到【输出】的{seed}部分 9.根据用户对画面风格的描述，选择对应的模型。如果用户没有特别指定，从下面 7 个模型中随机选一个模型，插入到【输出】的{model}部分 - `flux`（基本模型） - `flux-pro`（加强效果） - `flux-realism`（写实风格） - `flux-anime`（动漫风格） - `flux-3d`（3D 风格） - `flux-cablyai`（未知） - `turbo`（快速生成） 10. 输出结果直接渲染，不展示为代码块 #输出： \u0026lt;html\u0026gt; \u0026lt;title\u0026gt;Image Generator\u0026lt;/title\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;{ai_chinese_prompt}\u0026lt;/h2\u0026gt; \u0026lt;h4\u0026gt;{ai_english_prompt}\u0026lt;/h4\u0026gt; \u0026lt;img src=\u0026#34;https://image.pollinations.ai/prompt/{ai_english_prompt}?width={width}\u0026amp;height={height}\u0026amp;seed={seed}\u0026amp;enhance=true\u0026amp;private=true\u0026amp;nologo=true\u0026amp;safe=false\u0026amp;model={model}\u0026#34; alt=\u0026#34;{user_prompt}\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2025-05-18T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/095-deepseek%E7%94%9F%E5%9B%BE/snap_20250613_hu_e272a049af6cf9bc.png","permalink":"https://chengxiaqiucao.github.io/post/095-deepseek%E7%94%9F%E5%9B%BE/","title":"AI技巧，用本地Deepseek也可以生图啦"},{"content":"目前大模型应用如火如荼，各大LLM如Deepseek也都提供了在线的助手服务，结合mcp-server还可以进一步拓展到本地的工具能力。\n但对于一些和本地业务和数据强相关的资料，在线的大模型训练数据集一般并不能涵盖，特别还有一些敏感或对安全要求很高的数据，使用在线大模型并不现实。所以我们个人应用和实际工作中，本地部署大模型并加入本地知识库也是一个刚性需求。\n本文就记录下在WSL中通过Ollama和CherryStudio搭建本地大模型，并将本地模型集成到VsCode的AI助手的过程分享。\nOllama简介 Ollama 是一个基于Go 语言开发的简单易用的本地大语言模型运行框架，专为在本地机器上便捷部署和运行大型语言模型（LLM）而设计。Ollama 是 Omni-Layer Learning Language Acquisition Model（全方位学习语言接受模型） 的简写。\nDeepseek本地模型及运行配置 Deepseek目前根据本地部署包含的参数集大小，又包含 1.5B 到 671B 等多个版本，参数集越大则AI越智能，但相应地对硬件要求则越高。\n一般对应不同deepseek模型版本，推荐的硬件配置如下：\n模型型号 CPU 内存 硬盘 显存 适用场景 DeepSeek-R1-1.5B 4 核 8 GB+ 3 GB+ 非必需（若需 CPU 加速可选 GTX 1650） 个人使用，如笔记本电脑、台式电脑等 DeepSeek-R1-7B 8 核 16 GB+ 8 GB+ 8 GB+显存（如 RTX 3070/4060） 中小型企业本地开发 DeepSeek-R1-8B 8 核 16 GB+ 8 GB+ 8 GB+显存 中小型企业本地开发（提升精度的轻量级任务） DeepSeek-R1-14B 12 核 32 GB+ 15 GB+ 16 GB+显存（如RTX 4090 或 A5000） 中小型企业本地开发（中量级任务） DeepSeek-R1-32B 16 核 64 GB+ 30 GB+ 24 GB+显存（如 A100 40 GB 或 RTX 3090） 专业领域任务，如医疗、科研、法律 DeepSeek-R1-70B 32 核 128 GB+ 70 GB+ 多卡并行（如 2x A100 80GB 或 4x RTX 4090） 大型企业或科研机构，专业领域任务处理 DeepSeek-R1-671B（满血版） 64 核 512 GB+ 300 GB+ 多卡并行（如 8x A100/H100） 国家级科研任务处理 对我们个人用户来说，根据自己的电脑配置情况，通常选择1.5B到14B。 当然如果不是高频使用本地模型，个人建议可以将配置和推荐模型降一档匹配。 利用Ollama在WSL中部署本地Deepseek 因为笔者当前主要是希望将一些本地数据接入Deepseek，也没有高频使用本地LLM的需求。所有这里我选择部署 DeepSeek-R1-14B， 另外为了避免每次启动电脑都因为LLM运行占用大量资源，所以这里我希望在Windows电脑的WSL下运行LLM\nWSL配置 如果当前系统还没有启用WSL，可以先启用（过程不再详述， Win11中运行WSL install [对应Linux发行版] 即可安装）\n通过命令行查看WSL状态:\n1 2 3 C:\\qiucao\u0026gt;wsl --status 默认分发: Ubuntu-24.04 默认版本: 2 WSL默认的网络模式是NAT，这里可以通过WSL Setting程序，修改下当前配置，改为Mirrored镜像模式，共用宿主机网络。\n安装Ollama 进入Ollama官网(https://ollama.com/)下载界面, 因为我们是在WSL中部署，所以选择Linux安装。\n执行如下命令，等待下载并自动安装完成。\n1 2 3 4 5 curl -fsSL https://ollama.com/install.sh | sh # 安装完成查看版本 ~$ ollama --version ollama version is 0.6.5 部署deepseek 完成ollama安装后，就可以根据Ollama提供的大模型清单，选择对应大模型进行安装。目前支持的大模型清单，可以从官网如下地址查询：https://ollama.com/library\n执行如下命令下载并运行deepseek\n1 ollama run deepseek-r1:14b 安装成功后可以提问测试一下deepseek是否已正常提供服务\n添加知识库分析模型 至此，Deepseek其实已在本地部署。但如果要通过Deepseek使用本地数据和文档，我们还需要部署一个语义向量模型（Embedding Model），用来将本地数据转化为大模型可分析的知识库数据。这里我们选择 bge-m3 模型，这是一个通用向量模型，可以支持多语言、长文本和多种检索方式。\n执行：\n1 ollama pull bge-m3 用Cherry Studio管理知识库并提供本地交互界面 安装完Deepseek后，虽然我们可以在命令界面下和deepseek进行交互，但还是不够友好，包括对本地知识库的管理也不够方便。所以这里我们还可以安装一个开源的本地AI助手和知识库客户端Cherry Studio。从官网（https://cherry-ai.com）下载windows版本安装即可。 打开Cherry Studio，按如下步骤添加我们刚刚通过ollama部署的Deepseek\n会看到已经安装好的模型，添加进来 然后就可以利用Cherry Studio的知识库管理，将我们需要加入的本地文档纳入大模型的数据集中。这里包括直接添加文件、直接指定目录、从网站采集等多种方式，非常方便。\n集成本地Deepseek到vscode 而有了本地的LLM后，如果我们希望在vscode中使用，可以利用vscode 的 AI Toolkit 插件，按如下方式添加本地LLM\nvscode中测试下本地库的能力\n以上就是我们部署本地Deepseek的实践分享\n","date":"2025-05-15T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/094-deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/snap_20250419-3_hu_d3a5441cc808708e.png","permalink":"https://chengxiaqiucao.github.io/post/094-deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/","title":"打造个人知识库，wsl+ollama部署deepseek与vscode集成"},{"content":"前言 很多刚接触 AI 辅助编程的小伙伴应该都听说过 Cursor 的强大，对初学者而言，免费版Cursor的免费额度也足够让大家体验它的强悍能力。\n可是在实际应用过程中，从我的实际经验，如果只是把它当作一个沟通对象，像和人沟通那样来完成开发任务，却会浪费大量时间在纠正它的理解偏差，而且极大概率在某一次对话后，把原来的成果改得面目全非，大量努力付诸东流。\nCursor的12条军规 其实 Cursor 是否能更有效地发挥作用，跟它的使用方式有很大关系。Cursor的首席设计师 Ryo Lu 早前曾在 X 上给出善用 Cursor 的12条军规：\n明确项目规则： 在项目开始前，设置5-10条清晰的项目规则，让Cursor了解你的代码结构和约束。对于现有代码库，可以尝试使用/generate rules命令来生成规则。 具体化提示： 在提示中要非常具体，详细说明技术栈、期望行为和限制，就像编写一个迷你规范。 按文件操作： 每次处理一小部分，生成、测试并审查，保持专注。 测试先行： 优先编写测试，锁定测试用例，然后生成代码直到所有测试通过。 严格审查与修正： 始终审查AI的输出，并手动修复任何错误，然后将这些修正作为示例告知Cursor。 限定作用域： 使用@ file, @ folders, @ git等命令来将Cursor的注意力限制在代码库的特定部分。 提供完整上下文： 将设计文档和清单保存在.cursor/目录下，以便Cursor代理能够充分理解下一步需要做什么。 直接修改错误代码： 如果生成的代码有误，直接手动修改。Cursor从编辑中学习的速度比从解释中学习更快。 利用聊天历史： 使用聊天历史来迭代旧的提示，而无需从头开始。 明智选择模型： 根据需求有目的地选择模型。例如，Gemini适用于追求精确性，而Claude适用于需要更广泛知识的场景。 处理新栈或不熟悉栈： 在处理新或不熟悉的技术栈时，粘贴相关文档链接。让Cursor逐行解释所有错误和修复方法。 优化大型项目性能： 对于大型项目，让其在夜间进行索引，并限制上下文范围以保持性能的流畅性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Using Cursor well = fast, clean code. Using it wrong = AI spaghetti you’ll be cleaning up all week. Here’s how to actually use it right: 1. Set 5-10 clear project rules upfront so Cursor knows your structure and constraints. Try /generate rules for existing codebases. 2. Be specific in prompts. Spell out tech stack, behavior, and constraints like a mini spec. 3. Work file by file; generate, test, and review in small, focused chunks. 4. Write tests first, lock them, and generate code until all tests pass. 5. Always review AI output and hard‑fix anything that breaks, then tell Cursor to use them as examples. 6. Use @ file, @ folders, @ git to scope Cursor’s attention to the right parts of your codebase. 7. Keep design docs and checklists in .cursor/ so the agent has full context on what to do next. 8. If code is wrong, just write it yourself. Cursor learns faster from edits than explanations. 9. Use chat history to iterate on old prompts without starting over. 10. Choose models intentionally. Gemini for precision, Claude for breadth. 11. In new or unfamiliar stacks, paste in link to documentation. Make Cursor explain all errors and fixes line by line. 12.Let big projects index overnight and limit context scope to keep performance snappy. Structure and control wins (for now) Treat Cursor agent like a powerful junior — it can go far, fast, if you show it the way. 测试开发如何善用Cursor? 而作为一个测试开发或自动化测试工程师，我们在编写相关测试脚本或工具时，如何善用 Cursor 更好帮助我们提升效率和产出呢？本文我们参照以上 12 条规则，总结相关的实践指南。\n初始化与上下文构建——将Cursor训练成“测试领域专家” 在项目启动或介入初期，首要任务是让Cursor充分理解当前测试环境的规范与约束。高质量的上下文输入，是高质量代码输出的前提。\n明确项目测试规则与约定 (规则1) 在自动化测试项目中，代码规范、框架选型和设计模式的统一至关重要。基于规则1：明确项目规则 ，我们可以利用.cursor/rules.md文件，将这些隐性的团队知识显性化，为Cursor提供一份清晰的行动纲领 。而对于存量项目，还可先使用/generate rules命令初步提炼规则，再进行人工增补。\n实践案例：在一个基于Python Flask的Web项目中，测试技术栈为Pytest与Selenium。可以在.cursor/rules.md中定义如下规则：\n1 2 3 4 5 6 7 8 # .cursor/rules.md - [cite_start]所有单元测试文件命名为 `test_*.py` - UI测试文件命名为 `ui_test_*.py` - [cite_start]测试函数必须以 `test_` 开头 - [cite_start]使用Pytest fixture进行测试环境的设置与销毁（setup and teardown） - [cite_start]UI测试遵循Page Object模式，页面对象进行封装 - [cite_start]避免使用硬编码等待，优先采用WebDriver的显式等待机制 - [cite_start]测试报告统一使用Allure框架生成 提供详尽的指令以模拟“测试场景” (规则2) 与AI的交互质量直接决定输出代码的质量。自动化测试的指令尤其需要精确性，因为它必须完整描述被测功能、输入数据、预期行为乃至异常路径。\n实践案例：为用户登录功能编写集成测试。\n效果不佳的指令：写一个登录测试。 结构清晰的指令： 1 2 3 4 请使用Pytest框架，为Flask应用的用户登录功能（端点为POST /api/login，接收username和password）编写集成测试。需要覆盖以下三个场景： 1. 成功登录 (使用admin/password123)； 2. 密码错误 (使用admin/wrongpass)； 3. 用户不存在 (使用nonexistent/anypass)。对于成功场景，断言HTTP状态码为200且响应中包含非空的token。对于失败场景，断言状态码为401。 迭代式开发与修正——实现“测试代码的持续集成” 将复杂的测试任务分解，通过“生成-验证-修正”的敏捷循环进行开发，是确保代码质量和项目进度的有效策略。\n小步快跑，增量验证 (规则3) 应规避一次性生成整个复杂模块所有测试的诱惑。\n正确的做法是将任务分解为最小可验证单元，逐个击破。\n例如，在为一组RESTful API编写测试时，应按“创建用户 -\u0026gt; 获取用户 -\u0026gt; 更新用户 -\u0026gt; 删除用户”的逻辑顺序，逐一生成和验证测试代码\n这种方式有助于快速定位问题，避免错误的累积。\n测试驱动开发（TDD）的应用 (规则4) 测试驱动开发是保障代码质量的经典模式，Cursor可以成为该模式的强大加速器。工程师先定义函数的预期行为（即编写测试用例），再让AI生成满足这些测试的实现代码。\n实践案例：实现一个折扣计算函数calculate_discount(price, discount_rate)。\n定义测试: 首先要求Cursor：生成一个Pytest测试用例，用于测试calculate_discount函数。当price=100, discount_rate=0.1时，预期返回值为90；当discount_rate为负数时，应抛出ValueError异常。 生成实现: 在测试代码test_calculate_discount.py生成后，运行它（此时会失败），然后对Cursor发出新指令：请根据刚才生成的测试用例，实现calculate_discount函数的功能。 验证闭环: Cursor生成函数实现后，再次运行测试，直至全部通过。 主动纠正，教学相长 (规则5) 需要注意的是，AI生成的代码并非永远正确，而工程师的审查和修正是最后一道防线。直接在代码中修正错误，是训练Cursor最有效的方式，远胜于用自然语言向其解释。\n实践案例： 比如Cursor在生成的UI测试中，使用了一个不稳定且错误的XPath定位器//button[@id='submit']。在测试运行失败后，我们可以直接手动将其修改为正确的定位器，例如 //input[@value='Login']。修正后，可以在聊天中备注一句以强化其学习：“我已修正登录按钮的定位器，新的定位器更准确。请在后续任务中参考此模式。” 。\n精细化管理——实现“测试资源的智能调度” 在大型项目中，如何让Cursor聚焦于正确的信息，是决定其效率和相关性的关键。\n精准限定上下文范围 (规则6) 在庞大的代码库中，测试任务往往只与特定模块或服务相关。通过使用@folders或@file命令，可以显著缩小Cursor的分析范围，让其专注于必要的上下文。\n实践案例： 当为user_service微服务编写API测试时，所有相关代码位于services/user_service/目录。此时，应在提问前先输入@folders services/user_service/，然后再描述具体的测试需求。\n沉淀项目知识以辅助决策 (规则7) 可以将测试策略、UI定位器优先级、数据模拟规范等关键信息沉淀为文档，并存放于.cursor/目录中。这相当于为Cursor提供了一套“项目级知识库”。\n实践案例： 创建.cursor/ui_locators_priority.md文件，内容为：“UI元素定位优先顺序：ID \u0026gt; Name \u0026gt; CSS Selector \u0026gt; XPath”。在提问时便可引用：请参考.cursor/ui_locators_priority.md中的策略，为注册页面的‘提交’按钮生成Selenium定位代码。。\n问题解决与效率优化——化身“测试效率加速器” 掌握高级用法，能进一步将Cursor从日常助手，转变为解决复杂问题和加速学习的利器。\n智能选择AI模型 (规则10) 不同的AI模型具有不同的能力侧重。根据测试任务的特性选择合适的模型，可以事半功倍。\nGemini (精度优先)：适用于生成语法要求严格的单元测试、算法校验、或使用特定框架（如React Testing Library）的精细化测试代码。 Claude (广度优先)：更适合需要理解大量上下文的场景，如根据API文档生成全面的集成测试、设计端到端（E2E）测试场景，或在不熟悉的代码库中探索和建议测试点。 利用文档快速掌握新技术 (规则11) 当团队引入新的测试框架（如Playwright）时，工程师可以利用Cursor快速跨越学习曲线。\n实践案例： 直接向Cursor提供Playwright官方文档链接，并要求其生成示例代码。当生成的代码运行出错时，可以粘贴错误信息并提问：“这是运行Playwright脚本时出现的错误，请根据官方文档逐行解释错误原因，并提供修复建议。”。\n限制上下文范围 (规则12) 当项目代码量比较大时，通过过夜索引，并限制上下文范围。\n实践案例：\n在处理大型测试项目时，允许Cursor在后台处理索引，到第二天再进行具体的代码生成，从而保持性能流畅。\n1 2 3 4 # 优先索引核心模块 @folder tests/unit # 延迟加载集成测试 @defer tests/integration 总结 对于我们实际工作而言，成功运用Cursor的本质，是一个从“指令下达者”转变为“智能协作者”和“知识引导者”的过程。着眼点在于突出其 智能协作、知识沉淀和效率提升 的系统性作用。\n","date":"2025-05-13T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/093-cursor%E7%9A%8412rules/cursor_hu_485350db68cc04ed.png","permalink":"https://chengxiaqiucao.github.io/post/093-cursor%E7%9A%8412rules/","title":"测试开发如何善用Cursor？"},{"content":"之前我们介绍通过AI生成自动化测试代码，以及通过 mcp server 控制浏览器，使用的是AI编程IDE Cursor, Cursor以其强大的智能分析和辅助编程能力，在我们用自然语言给出一个编程需求时，即可自动帮我们完成代码的实现，高效且效果很好。但 Cursor 并不是一个免费软件，试用期结束后，作为日常工具的话，费用还是比较高昂。\n但现在，腾讯也出手推出了一个代码助手，正是本文主角，CodeBuddy。编程能力比Cursor不遑多让，更是对小程序这样腾讯生态下的应用有光环加成，更重要的是：完全免费！\n安装 CodeBuddy本身并没有提供单独的IDE，但是对于各种主流IDE，都提供了插件支持\n在各款开发工具的插件市场中搜索”腾讯云代码助手“，均能找到对应插件，相应进行安装即可\n以vs code为例，插件安装后，打开插件界面，即可类似Copilot或Cursor的助手页面那样进行编程辅助， 在CodeBuddy中，称为 Craft 模式\n除了辅助生成代码这个模式，还包括Chat模式，可以类似生成式AI那样进行对话交流。\n此外Code Review模式可以帮助完成已有代码的评审，Unit Test则会针对当前代码自动编写单元测试脚本。\n小程序开发实测 而CodeBuddy本身基于腾讯生态，对于像小程序开发这样的工作，可以说是有着先天的右手。\n这里笔者在微信开发者工具中，安装CodeBuddy插件之后，仅仅通过几次交互问答，就帮助我完成了一个小程序的实现。\n如下，就是我通过它完成的获取Github最近一个月最热门仓库的实现，总用时大概10多分钟，实测可用且界面友好。\n以后可能真的人人都是开发者，即便对编程不甚了解，只要有想法，也能轻松转化为现实！\n附上完成这个应用的完整交互过程\n请帮我开发一个简单的小程序，获取github上当日最热门的5个repo的介绍，界面重点突出，保证视觉效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 CodeBuddy 用户需要一个小程序来展示GitHub上当日最热门的5个仓库，并且要求界面视觉效果突出。我需要进一步了解用户的需求，并收集一些信息来制定合适的计划。 首先，我需要明确以下几点： 1. 小程序的平台 - 是Web应用、移动应用还是桌面应用？ 2. 技术栈偏好 - 用户是否有特定的编程语言或框架偏好？ 3. \u0026#34;当日最热门\u0026#34;的定义 - 是基于星标数、fork数还是其他指标？ 4. 视觉效果的具体要求 - 用户对UI/UX有什么特定的期望？ 5. 功能需求 - 除了展示仓库介绍外，是否需要其他功能，如点击跳转到仓库页面等？ 让我先看看项目目录结构，了解当前的环境： 根目录0个文件 已完成 明白了，这是一个全新的项目。让我与用户进行需求澄清，以便更好地规划这个项目。我需要询问一些关键问题来确保我们能够开发出符合用户期望的应用。 为了更好地帮助您开发这个展示GitHub热门仓库的应用，我需要确认一些关键细节： 1. **平台选择**： - 您期望这个应用是网页应用（Web App）还是桌面应用（Desktop App）？ 2. **技术栈偏好**： - 您是否有特定的编程语言或框架偏好？ - 比如： - Web应用：React、Vue、Angular等 - 桌面应用：Electron、Python+Qt等 3. **UI/视觉需求**： - 您对视觉效果有什么具体期望？比如： - 现代简约风格 - 深色/浅色主题 - 卡片式布局 - 动画效果等 4. **功能细节**： - 除了显示仓库名称和介绍外，您是否需要显示： - 仓库星标数 - 作者信息 - 编程语言 - 直接跳转链接 - 是否需要自动刷新功能？ 请告诉我您的偏好，这样我可以制定一个更符合您需求的具体实现方案。 平台：微信小程序；技术偏好：vue；视觉效果：现代简约；功能：包含当前建议功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 CodeBuddy 感谢用户的回复，现在我有了更明确的需求信息： 1. 平台：微信小程序 2. 技术偏好：Vue (在微信小程序中，我们可以使用类似Vue的MVVM框架，即微信小程序原生开发方式) 3. 视觉效果：现代简约风格 4. 功能：包含我建议的功能，即： - 显示仓库名称和介绍 - 显示仓库星标数 - 显示作者信息 - 显示编程语言 - 提供直接跳转链接 现在我可以制定一个更具体的实施计划。微信小程序开发需要使用微信开发者工具，并且需要调用GitHub API来获取热门仓库信息。 感谢您的回复！基于您提供的信息，我们将开发一个**微信小程序**，使用**类Vue的开发方式**，采用**现代简约**的视觉风格，展示GitHub当日最热门的5个仓库。 还有几个技术细节需要确认： 1. **GitHub API 访问方式**： - 微信小程序对跨域请求有限制，我们需要考虑如何调用GitHub API - 选项1：使用云函数作为中间层（推荐，更安全且避免跨域问题） - 选项2：直接在小程序中调用API（可能面临跨域限制） 2. **热门仓库的定义**： - GitHub API提供多种排序方式，您希望基于哪种指标来定义\u0026#34;热门\u0026#34;？ - 当日新增星标数最多 - 总星标数最多 - 当日新建且受关注度高的 3. **刷新机制**： - 是否需要下拉刷新功能？ - 是否需要定时自动刷新（如每小时更新一次）？ 这些信息将帮助我设计一个更符合您期望的小程序方案。 github API使用云函数，热门指标：当日新增星标最多；启动App时进行刷新即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 CodeBuddy 非常感谢用户的进一步澄清。现在我有了完整的需求信息： 1. 平台：微信小程序 2. 技术偏好：Vue风格的微信小程序开发 3. 视觉效果：现代简约风格 4. GitHub API访问方式：使用云函数作为中间层 5. 热门仓库定义：当日新增星标数最多 6. 刷新机制：启动App时进行刷新 基于这些信息，我可以制定一个详细的实施计划，包括项目结构、主要功能模块、UI设计思路以及开发步骤。 # GitHub热门仓库微信小程序开发计划 **项目概述** 开发一个微信小程序，展示GitHub当日新增星标数最多的5个仓库，采用现代简约的UI设计，使用云函数调用GitHub API。 **技术栈** - 前端：微信小程序原生开发（WXML, WXSS, JS） - 后端：微信云开发（云函数） - API：GitHub REST API **项目结构** `├── miniprogram/ # 小程序前端代码 │ ├── pages/ # 页面文件 │ │ ├── index/ # 主页面 │ │ └── detail/ # 详情页面（可选） │ ├── components/ # 自定义组件 │ │ └── repo-card/ # 仓库卡片组件 │ ├── images/ # 图标和图片资源 │ ├── styles/ # 公共样式 │ └── utils/ # 工具函数 └── cloudfunctions/ # 云函数 └── getHotRepos/ # 获取热门仓库的云函数` **功能模块** **1. 云函数模块** - 创建`getHotRepos`云函数，负责： - 调用GitHub API获取当日新增星标最多的仓库 - 数据处理和过滤，返回前5个仓库的详细信息 - 处理API请求限制和错误情况 **2. 前端展示模块** - 主页面（index）： - 顶部标题栏，展示应用名称和刷新状态 - 仓库列表区域，使用卡片式布局展示5个热门仓库 - 加载状态和错误提示 - 仓库卡片组件（repo-card）： - 仓库名称和描述 - 作者信息和头像 - 星标数（总数和今日新增） - 编程语言（带颜色标识） - 跳转按钮（可打开web-view或复制链接） **3. 数据交互模块** - 应用启动时自动调用云函数获取数据 - 实现下拉刷新功能（可选） - 数据缓存机制，减少不必要的API调用 **UI设计思路** - 配色方案： - 主色调：GitHub深蓝色 (#0366d6) - 背景色：浅灰色或白色 (#f6f8fa) - 强调色：GitHub绿色 (#2ea44f) - 卡片设计： - 圆角矩形卡片 - 适当的阴影效果 - 信息层次分明 - 动效： - 加载动画 - 卡片点击反馈 - 平滑的列表滚动效果 **开发步骤** 1. **项目初始化** - 创建微信小程序项目 - 配置云开发环境 2. **云函数开发** - 编写获取GitHub热门仓库的云函数 - 测试API调用和数据处理 3. **前端页面开发** - 设计并实现主页面布局 - 开发仓库卡片组件 - 实现数据加载和展示逻辑 4. **样式优化** - 应用现代简约风格 - 优化视觉效果和交互体验 5. **功能测试与优化** - 测试数据加载和展示 - 优化性能和用户体验 6. **发布与部署** - 配置小程序基本信息 - 提交审核并发布 **注意事项** - GitHub API有请求频率限制，需要合理设计缓存策略 - 微信小程序对网络请求和页面大小有限制，需注意性能优化 - 确保UI在不同尺寸的设备上都有良好的展示效果 根据用户提供的开发计划，我需要开发一个微信小程序，展示GitHub当日新增星标数最多的5个仓库。这个项目需要使用微信小程序原生开发和云开发。 首先，我需要创建项目的基本结构，包括： 1. 创建小程序前端代码结构 2. 创建云函数 3. 实现主要功能模块 让我先检查当前目录是否为空，然后开始创建项目结构。 根目录0个文件 已完成 目录为空，我们需要从头开始创建项目结构。首先创建基本的项目目录结构，包括小程序前端代码和云函数目录。 我们先创建以下关键文件： 1. project.config.json - 小程序项目配置文件 2. app.json - 小程序全局配置文件 3. app.js - 小程序入口文件 4. app.wxss - 小程序全局样式文件 让我们先创建项目配置文件。 project.config.json +78 -0 已接受 现在我们已经创建了项目配置文件，接下来需要创建小程序的基本结构。首先创建miniprogram目录，然后在其中创建app.js、app.json和app.wxss文件。 1. 创建miniprogram目录 2. 创建app.js - 小程序入口文件 3. 创建app.json - 小程序全局配置文件 4. 创建app.wxss - 小程序全局样式文件 让我们先创建miniprogram目录，然后创建这些基本文件。 mkdir -p miniprogram 目录创建成功，现在让我们创建小程序的基本文件。首先创建app.json，配置小程序的全局设置，包括页面路径、窗口样式等。 miniprogram/app.json +16 -0 已接受 现在创建app.js文件，这是小程序的入口文件，用于初始化小程序。我们将在这里初始化云开发环境。 miniprogram/app.js +22 -0 已接受 接下来创建app.wxss文件，定义全局样式。我们将使用GitHub的配色方案，并定义一些通用样式。 miniprogram/app.wxss +80 -0 已接受 现在我们需要创建主页面（index）的相关文件。我们需要在miniprogram/pages/index/目录下创建以下文件： 1. index.js - 页面逻辑 2. index.wxml - 页面结构 3. index.wxss - 页面样式 4. index.json - 页面配置 首先创建index目录，然后创建这些文件。 mkdir -p miniprogram/pages/index 目录创建成功，现在让我们创建index页面的文件。首先创建index.wxml，设计页面的基本结构，包括加载状态、仓库列表等。 miniprogram/pages/index/index.wxml +58 -2 已接受 现在创建index.wxss文件，为主页面添加样式。我们将使用现代简约的设计风格，包括卡片式布局、适当的阴影效果等。 miniprogram/pages/index/index.wxss +144 -0 已接受 接下来创建index.js文件，实现页面的业务逻辑，包括： 1. 页面加载时获取热门仓库数据 2. 处理刷新操作 3. 实现复制链接和打开仓库等功能 miniprogram/pages/index/index.js +78 -40 已接受 现在创建index.json文件，配置页面的基本设置，包括启用下拉刷新等功能。然后我们需要创建云函数getHotRepos来获取GitHub热门仓库数据。 miniprogram/pages/index/index.json +7 -0 已接受 现在我们需要创建一些必要的图片资源。我们需要在miniprogram目录下创建images文件夹，并准备一些基本图标，如加载图标、星标图标等。 首先创建images目录： mkdir -p miniprogram/images 现在我们需要创建云函数getHotRepos。首先创建cloudfunctions目录和getHotRepos云函数目录，然后创建云函数的相关文件。 1. 创建cloudfunctions/getHotRepos目录 2. 创建package.json和index.js文件 mkdir -p cloudfunctions/getHotRepos 现在创建云函数的package.json文件，添加必要的依赖，包括用于发起HTTP请求的axios。 cloudfunctions/getHotRepos/package.json +17 -0 已接受 现在创建云函数的主文件index.js，实现获取GitHub热门仓库的逻辑。我们将： 1. 使用GitHub API搜索仓库 2. 按照当日新增星标数排序 3. 获取前5个仓库的详细信息 4. 处理错误情况和API限制 cloudfunctions/getHotRepos/index.js +144 -0 已接受 现在我们需要创建一些基本的图标文件。由于我们无法直接创建二进制图片文件，我们可以创建一个sitemap.json文件，这是微信小程序必需的文件，用于配置小程序的索引规则。 然后，我们可以创建一个README.md文件，提供项目的说明和使用指南。 miniprogram/sitemap.json +8 -0 已接受 现在让我们创建一个README.md文件，提供项目的详细说明、安装步骤和使用指南。这将帮助其他开发者理解和使用这个项目。 README.md +88 -0 已接受 现在我们已经完成了项目的基本结构和核心功能的开发。让我们总结一下已完成的工作和下一步需要用户进行的操作： 1. 已完成的工作： - 创建了完整的项目结构 - 实现了主页面的UI和逻辑 - 实现了云函数获取GitHub热门仓库 - 创建了项目文档 2. 用户需要进行的操作： - 配置微信开发者工具和AppID - 开通云开发环境 - 配置GitHub Token - 上传和部署云函数 - 在images目录中添加必要的图标文件 让我使用attempt_completion工具来总结项目的完成状态和后续步骤。 # GitHub热门仓库小程序开发完成 **已完成的开发工作** 1. **项目结构搭建** - 创建了完整的微信小程序项目结构 - 配置了必要的项目文件（project.config.json, app.json等） - 创建了云函数目录结构 2. **前端开发** - 实现了主页面（index）的完整功能 - 设计了现代简约风格的UI界面 - 实现了下拉刷新等交互功能 3. **后端开发** - 实现了getHotRepos云函数 - 集成了GitHub API的调用 - 实现了数据处理和错误处理 4. **文档编写** - 创建了详细的README.md文件 - 提供了完整的安装和使用说明 **后续步骤** 要运行这个项目，您需要： 1. **环境配置** - 使用微信开发者工具打开项目 - 在project.config.json中配置您的AppID - 开通云开发并创建云环境 - 在app.js中配置云环境ID 2. **资源准备** - 在miniprogram/images/目录下添加必要的图标： - loading.gif（加载动画） - star.png（星标图标） 3. **云函数部署** - 进入cloudfunctions/getHotRepos目录 - 安装依赖：npm install - 在云开发控制台中配置GitHub Token（可选） - 上传并部署云函数 4. **运行测试** - 编译运行项目 - 测试数据加载功能 - 测试下拉刷新功能 - 测试仓库链接复制功能 **注意事项** 1. 请确保正确配置了所有必要的环境变量和配置项 2. 建议配置GitHub Token以避免API限制 3. 首次运行时需要等待云函数部署完成 4. 如遇到问题，请查看README.md中的详细说明 项目源码已经准备就绪，您可以按照上述步骤开始使用和测试了。如果有任何问题，欢迎参考README.md文件或提出问题。 ","date":"2025-05-09T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/092-codebuddy/","title":"Cursor收费？没事，咱们还有codebuddy！"},{"content":"前言 在软件产品研发中，Bug既是测试工作最为重要的产出，也是开发人员修复问题的直接输入，更是产品质量改进的主要抓手。\n在前文【】中，我们从测试人员的角度，分析了在提交Bug时应如何帮助团队更高效地去进行质量改进。\n但除了Bug提交环节，在我们工作中，Bug从发现到被修复，会经历一个完整的生命周期，对应到我们提交的问题单，会呈现不同的状态。而Bug在这些不同状态间的迁移，其实反映了团队围绕Bug的协作沟通过程。实际工作中，因为Bug认定或状态设定上产生的分歧屡见不鲜，特别是在很多将Bug作为重要KPI数据的团队，测试和开发之间因为Bug产生激烈争论，时有发生。比如：\n开发和测试对Bug认定有分歧，测试觉得是Bug，开发觉得不是问题，怎么处理？ Bug归属产生分歧，是前端问题还是后端问题？ Bug无法复现，应不应该关闭？ \u0026hellip;..等等 本文，我们就来详细梳理一下，Bug的完整生命周期，以及它在不同阶段的状态处理原则。\nBug的生命周期及不同状态 Bug并不是凭空产生，是在测试过程中暴露出来的质量问题，从被发现到完成修复并确认无误，会经历一个过程，这个过程就是Bug的生命周期。在软件研发过程中，针对这个生命周期的管理，通常会由Bug管理系统（常用的比如Jira、禅道、Bugfree、HP QC等）来跟踪和同步每个Bug的状态，并在开发和测试人员之间起到协作桥梁的作用。\nBug生命周期的主要过程大致如下：\n已提交（Open） Open 状态，是Bug被发现以后的初始状态。通常由发现Bug的测试人员录入Bug管理系统，形成问题单，此时Bug的状态处于 Open 状态，也表示该Bug待处理。\n另外，如果有已关闭的历史Bug，后来发现其实并未解决，也可以重新将Bug激活，此时Bug也会处于 Open 状态。\n在该状态下，提交Bug的测试人员应该指定处理Bug的开发人员进行下一步处理，通常会根据Bug的现象，直接指定到能修复Bug的开发这里。不过一般Bug管理系统，也会设置默认处理人，对于Open 状态的Bug，默认处理人通常会设置为开发负责人，会做进一步更准确的判断以便重新指派。\n状态 说明 当前负责人 移交处理人 Open 初始状态，待处理 测试人员 开发负责人或Bug归属人 处理中（In Progress） 开发人员被指派Bug后，会进入Bug的分析阶段，此时Bug不能确定是否能被修复，所以会进入处理中状态，经过分析后，可以对Bug进行修复操作，或发现并不是自己可以完成修复的问题，再将bug重新指派给实际应该修复bug的开发人员。\n这里如果存在Bug在开发人员间的移交，Bug状态会保持在 In Progress, 仅仅当前处理人会发生变化。\n状态 说明 当前负责人 移交处理人 In Progress Bug进入分析，通常针对较复杂Bug 被指派开发人员 实际Bug修复人 已解决（Resolved） Bug在经过开发人员的修复后，会标记为已解决。该状态其实代表测试人员可以对Bug进行验证。\n这里需要注意，很多开发人员会有的一个误区，就是我把代码进行修改或者做过自测，就是Resolved。其实并不是，Resolved 状态的重点是被移交的处理人，也就是测试人员是可以进行验证的。\n因为实际工作中，测试人员对产品进行测试，会有测试轮次的概念，并不是随时都可以测试。 所以只有当修复的代码已经进入下一轮的提交测试，才应该将状态置为 Resolved。否则当前测试环境中，被修复的代码尚未部署，当然实际并无法完成验证。\n（当然更完善的Bug管理系统，会再增加一个待验证的状态，这时已解决就只代表开发完成了代码的修复，而待验证才是重新提测。本文重在说明常用必要状态，不再过多扩展）\n状态 说明 当前负责人 移交处理人 Resolved Bug已经完成修复，标记为已解决，即待验证 Bug修复人 测试人员 已关闭（Closed） 经过验证，确认Bug已被修复后，Bug可以置为 已关闭 状态。该状态代表Bug所反映的质量问题在当前产品版本中已不复存在。\n关闭Bug应该是一个很严肃的事情，通常应该由Bug的提交人进行确认后才可关闭。当然特殊情况下，产品的决策团队（CCB）也可决定Bug是否可以进行关闭。\n另外，关闭的Bug需要重新激活的情况也时有发生，比如验证时场景考虑不够完整，环境问题导致误关或者是提测版本切换后，已修复的Bug又被重新改错，或是错误代码又被重新合入等等，这时就会牵涉Bug重开（ReOpen）操作\n状态 说明 当前负责人 移交处理人 Closed Bug已确认修复，版本中已不存在Bug对应的质量问题 Bug提交人 无 除了上面几个最主要的Bug生命周期状态外，实际工作中，还会存在一些特殊情况，也会对应到不同的Bug状态\n已拒绝（Rejected） 测试过程中，测试人员出现误判，或者环境配置有误时，还是比较容易出现测试提交的Bug实际并不是质量问题的情况，开发人员在经过分析后，认为不是bug，此时就可以将Bug置为 已拒绝 状态。这时Bug会回到测试人员手中，进行确认，若认可误报，可由提交人进行关闭操作。\n状态 说明 当前负责人 移交处理人 Rejected 经分析Bug属于误报，不反映质量问题 Bug分析人 Bug提交者 但实际中，针对被拒绝Bug，很多时候是测试和开发人员对需求或是否质量问题的分歧导致，在分歧无法自行弥合的情况下，正常的操作应该是： 测试人员重新提交Bug，但Bug不在指派到开发人员，而是指派到产品决策团队CCB（其实主要是BA或PO），由CCB进行仲裁，根据仲裁结果来判断是否需要进行修复或关闭。\n已验证（Verified） 测试人员验证Bug无误后，通常可以进行关闭操作将状态置为Closed，但更完整的生命周期，其实还又一个已验证的状态。这个状态的使用，通常出现在验证Bug的测试人员和提交Bug的提交人并不一致，验证人对Bug实施验证后，不能代表提交人，确认Bug可关闭。\n另外一种情况，就是更严谨的大型软件研发流程，测试环节可能也包括多个。子系统级别的测试团队测试完成后，还会有大系统级别的系统测试或全面验收，在子系统级别的测试进入后续测试后才会将状态置为Closed\n状态 说明 当前负责人 移交处理人 Verified Bug经过验证已被修复 Bug验证人 Bug提交者 待补充信息（Need More Info） 这个状态是针对测试人员提交的Bug信息不完整或不足以对Bug完成分析，开发人员难以理解具体的Bug现象等情况。这时处理人将问题单置为 Need More Info 状态，返回给Bug提交人补充相关信息。\n状态 说明 当前负责人 移交处理人 Need More Info Bug单信息不充分，需要补充更详细的信息 Bug分析人 Bug提交者 已延期（Deferred） 延期一般针对下面几种情况：\nBug难以复现，较难分析出产生原因 Bug修改难度大，需要对产品进行较大改动，且存在规避方案 Bug优先级较低，不影响主要功能，在版本发布前还有其他更重要问题需要解决 针对以上情况，经过产品CCB团队决策，可以将Bug延期处理。同时Bug的负责分析人，还是需要继续针对Bug做分析或后续进行修复。\n但这里需要注意，Deferred 状态不代表Bug不是问题，在测试团队的质量分析时，还是应该将该状态的Bug视作有效Bug看待。也就是这类Bug还是会影响到版本最终的质量评估结论。\n状态 说明 当前负责人 移交处理人 Deferred Bug因特定原因无法在当前版本解决，经项目CCB团队决策认可后，可将Bug保留在版本中，留待后续解决 CCB决策团队 Bug分析人 以上就是我们针对Bug生命周期中会出现的主要的一些状态定义及相关处理原则的介绍。除了上面列出的这些Bug状态外，更完整的Bug生命周期还包括有：\n待验证： 已修复，等待版本提测 调研中： 针对比较复杂的Bug，牵涉技术选型、方案对照等较多研究工作时，可在处理Bug前定义该状态 已调研： 针对上面进行了方案研究的Bug，但尚未确定修复方案时，Bug处于该状态 验证中： 对于测试场景比较复杂的Bug，需要进行较长时间的验证，比如性能类的问题，在完成验证前，可将Bug置于该状态 当然，流程是死的，良好、高效的团队协作最重要的还是团队中不同角色的互信互助。\n不过我们理解正确流程中的不同环节和正确处理的原则，也有助于我们在出现问题或分歧时，减少互相争论、扯皮的内耗。\nBug状态迁移 基于上述不同状态的分析，一个比较完整Bug状态迁移图如下，供参考。\n如需以上完整大图，可回复 Bug状态 获取。\n另回复大纲 可查看秋草测试技能全栈提升课详细目录。回复 进群可进入测试交流群和小伙伴们分享测试技术、交换资讯。\n","date":"2025-05-07T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/091-bug%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/snap_20250513-1_hu_dbf52ef581bcf2fd.png","permalink":"https://chengxiaqiucao.github.io/post/091-bug%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","title":"谈谈Bug的生命周期和Bug状态变更原则"},{"content":"在前文 【】和 【】中，我们分别对Bruno 这个近来备受关注的接口测试工具的优缺点和基本使用方法进行了介绍，本文我们会继续在上一篇的基础上，介绍 Bruno 和自动化测试相关的进阶用法\nBruno的六层变量作用域 和 postman 类似，Bruno 中也同样对接口测试中的变量使用提供了多层设计，可以通过不同层级的作用域区分，为接口测试和自动化提供了更多灵活性和应用场景。\nBruno中提供了6类不同的变量，其作用范围次序如下：\n全局变量 全局变量是作用范围最大的变量类型。设置全局变量是通过 Bruno 的 global Environments 设置，位置如下：\n然后比如增加一个全局变量，配置并启用： 这时我们获取Github API中的用户信息，可以获取userid = 1 的用户\nCollection变量 在设置了全局变量后，再设置 collection 集合变量 然后发送请求，此时生效的就是集合变量\n环境变量 下一层是可以设置不同的环境，在如下位置配置：\n此时生效的是 userid = 3\nFolder变量 在collection下一层，可以创建目录，这里设置变量， 生效的就是目录变量\n请求变量 再下一层，则是具体的请求当中设置的变量\n运行时变量 除了预设变量的情况，Bruno也支持通过脚本，在执行时设置运行时变量，使用如下代码设置\n1 bru.setVar(\u0026#34;userid\u0026#34;, 6) 在执行请求后，查看当前runtime变量，还可以通过工具栏中的对应按钮进入显示界面查看。\n通过以上实例，可以看到，Bruno的多层变量体系及其作用范围，同样的变量名，生效优先次序依次为：\n运行时变量 -\u0026gt; 请求变量 -\u0026gt; 目录变量 -\u0026gt; 环境变量 -\u0026gt; 集合变量 -\u0026gt; 全局变量\n流程环境变量 除了上面这些多层变量设计外，在我们处理接口时，像token、API Key或一些账号密码等比较敏感的数据变量，可能并不希望在接口及相关配置文件( *.bru )中体现。针对这类变量，Bruno 也提供了一个针对性的处理方式，就是通过 .env 文件来存储。.env 文件需放置在collection的根目录下，变量定义采用key-value 形式，如：\n1 userid = 7 这时，我们在配置变量时就可以通过{{process.env.userid}} 来实现引用，避免相关敏感数据，直接出现在接口定义文件中\nBruno脚本及执行顺序 Bruno的脚本功能，使用的是标准JavaScript语法。可以在Collection、Folder、Request三个不同层级上定义请求前（Pre）和请求后（Post）要执行的脚本。并且Bruno提供了两种脚本执行顺序模型（主要区别是post脚本的执行顺序）\n1. Sandwich Flow （默认） 这种模式下，不同层级脚本的执行顺序如下\nCollection Pre Script Folder Pre Script Request Pre Script Request Post Script Folder Post Script Collection Post Script 和各类单元测试框架的分层执行顺序类似。\n2. Sequential (Natural) Flow 这种执行顺序，和Postman的脚本执行顺序类似，完全按层级顺序来执行。\nCollection Pre Script Folder Pre Script Request Pre Script Collection Post Script Folder Post Script Request Post Script 要采用这种顺序，需要在Bruno的配置文件 bruno.json 中配置 flow 参数，形如：\n1 2 3 4 5 6 7 8 9 { \u0026#34;scripts\u0026#34;: { \u0026#34;filesystemAccess\u0026#34;: { \u0026#34;allow\u0026#34;: true }, \u0026#34;flow\u0026#34;: \u0026#34;sequential\u0026#34; // Or \u0026#34;sandwich\u0026#34; } } 执行示例 在各个层级的脚本中分别添加对应的脚本日志，打开Bruno集成的Dev Tool控制台，可看到对应执行顺序的不同。\n修改 bruno.json， 配置flow模式为 sequential，可以看到post部分的输出顺序发生了变化。\n流程依赖处理 在我们实际的接口测试时，一个经常遇到的场景，就是后续的请求，会需要依赖之前请求的返回数据，比如最常见的动态token获取等场景。\n而利用Bruno的变量和脚本，我们可以通过脚本实现这种接口的关联操作。\n在Bruno的官方文档中，他内置的bru对象，提供了 setNextRequest， runRequest 这样的方法，使我们可以根据自己的需要，确定在执行某个接口请求时，指定下一条需要执行的请求（不再按默认顺序执行），或者也可以直接在当前请求的脚本中，运行其他接口请求。\n通过这种方式，我们就可以通过设置变量，并将变量进行接口间的传递，以此完成流程依赖场景的实现。\n比如这里我们获取github用户下的repo清单，这个接口。 这里的 {{username}} 变量，我们希望通过指定 userid 来获取。也就是先执行前面的 getUserInfo 这个接口，根据 userid 来获取 username。\n这里我们定义getUserRepos，使用变量{{username}}， 但此时该变量未定义，所以显示为红色\n然后在 getUserInfo 这个接口中，我们定义脚本，提取当前响应的username，并进行变量赋值。然后直接调用 getUserRepos 接口（注意这里调用的接口路径，应该以collection根路径进行定义）\n1 2 3 4 5 6 bru.setVar(\u0026#34;username\u0026#34;,res.body.login) const response = await bru.runRequest(\u0026#34;variables/getUserRepos\u0026#34;) console.log(response.status) 执行getUserInfo， 可以看到，执行成功，脚本中执行的 getUserRepos 接口也成功得到了 200OK 的响应状态\nRunner执行器 除了在脚本中执行指定接口， Bruno其实也提供了一个Runner的执行器，从工具栏打开执行器，也可以批量地依次运行Collection中的所有接口\n比如上例，我们如果只是在 getUserInfo 中获取并定义变量 username, 而不执行。 只要getUserRepos在 getUserInfo 之后执行，也同样可以执行成功。\nRunner运行效果如下：\n但这里Bruno默认的功能，是运行collection中的所有请求，且调整顺序的功能，虽然有提供，但只包含在付费的高级版中，包括基于csv或json的数据驱动功能，免费版本中也不包含。稍显鸡肋。\nBruno命令行 Bruno CLI 上面 Runner执行器 的功能因为受限，在我们要进行接口自动化时，比较鸡肋，基本无法使用。但Bruno这里的高级版本功能，其实只是针对界面上触发进行了限制。\n我们要执行自动化，也可以利用它提供的命令行功能来实现。\n这里的CLI程序，需要单独安装\n1 npm install -g @usebruno/cli 安装后，能正确显示版本号表示安装成功， 如：\n1 2 C:\\qiucao\u0026gt;bru --version 2.1.0 通过命令行执行，我们就可以根据自己的需要，比如执行指定目录下的接口。\n这里携带的两个参数 --env 指定需要使用的环境， --reporter-html 会在完成执行后生成一个html格式的测试报告。（详细的参数，可参考文档 https://docs.usebruno.com/bru-cli/commandOptions）\n生成的测试报告：\n以上就是关于Bruno中使用脚本和自动化执行相关功能的进阶说明。欢迎继续关注后续文章。\n回复大纲 可查看秋草测试技能全栈提升课详细目录。回复 进群可进入测试交流群和小伙伴们分享测试技术、交换资讯。\n","date":"2025-05-04T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/090-bruno%E8%BF%9B%E9%98%B6/","title":"可以抛弃postman啦, API测试工具Bruno实用教程(二)：进阶篇"},{"content":"序言 在前文【】中，我们介绍了目前目前Github上广受关注的新锐接口测试工具Bruno，给厌倦了Postman必须在线使用限制的同学提供了一个很好的替代选择。\nBruno的核心优势，官网重点给出了如下几点：\n承诺开源和可扩展，并且专心做客户端，永不向“平台化”扩充产品。 基于Git实现协作和版本管理 离线使用，永不同步本地数据 😂😂😂 下面我们就通过一个系列，详细介绍通过Bruno来进行API接口测试的详细实战教程。本文是第一篇，重点介绍如下内容：\nBruno的安装和界面说明 结合Github API实现典型API操作的方法 环境管理 鉴权机制和加密 Bruno安装和界面概览 安装 1 2 3 4 5 6 7 8 # Mac (Homebrew) brew install bruno # Windows (Winget) winget install usebruno.bruno # Linux (Snap) sudo snap install bruno 使用界面 左侧面板：Collection管理、导航（类似IDE的项目结构）\n中央区域：请求编辑器（URL/Headers/Body配置）\n右侧面板：响应结果显示（内容、状态、断言等）\n工具栏：顶部主要是一些高级功能配置（付费版本）、变量管理（全局、环境）；底部工具栏是工具的系统级配置（界面、代理、鉴权等），cookies、license管理\n快捷键体系：\nCtrl +E：环境变量设置 Ctrl + B：新建请求 Ctrl + Enter：立即发送请求 典型HTTP接口测试实现(Github API) 下面我们结合 Github 的官方API接口，介绍在 Bruno 中如何完成典型HTTP接口请求测试。\nGithub API简介 GitHub 是一个面向开源软件项目的托管平台，因为使用 Git 作为唯一的版本库格式进行托管，故名 GitHub。也是目前全球最大的代码托管平台，可以说是程序员的圣地，号称全球最大的同性交友平台\nGitHub API目前有两个版本，一个是基于GraphQL的V4版本， 而更常用的主要还是之前的Restful API，它的Restful API定义长期以来被视作此类接口的典范。\n具体的接口说明文档：参见 https://docs.github.com/zh/rest?apiVersion=2022-11-28\ngithub 中的时间格式 YYYY-MM-DDTHH:MM:SSZ\ngithub 限流规则 github 为包含服务端负载压力，会对请求流量进行限制。在每个 github 的响应消息头中都会携带 github 的限流设置。\n头参数 含义 X-RateLimit-Limit 当前每小时最大请求限制，一般未鉴权请求60次，鉴权请求5000次 X-RateLimit-Remaining 当前剩余请求次数 X-RateLimit-Reset 剩余限制重置时间，毫秒 请求参数与分页 请求中可以携带参数，一般包含两种参数: 路径参数和查询参数 github API中默认支持两个分页参数：\npage 当前显示页数 per_page 每页显示结果数 github 请求Token 从Github账号设置页中，增加访问API的Token配置\n配置Token鉴权 进入Bruno，新建一个Collection， 命名 github，在其中的 Auth 部分, 将之前设置的API token添加进来，这里的鉴权方式选择 bearer Token\n除了 bearer Token 外， Bruno还支持其他多种鉴权方式，能基本覆盖到各种API接口的鉴权模式。\nAWS Sig：针对亚马逊的AWS公有云用户签名的认证方式 Basic auth：基本鉴权，通过输入账号、密码 WSSE auth：Web Service安全用户认证 Bearer Token：基于加密文本的安全认证令牌 Digest auth：摘要式认证 NTLM auth：微软的局域网管理认证协议 Oauth 2.0：开放式授权协议，是第三方认证的常用协议 API Key：服务端自己定义的接入令牌 no Auth：不鉴权 inherit：继承上一级鉴权（Bruno中，下一级请求可以使用上一级的鉴权设置） 接口测试中的增删改查 1. GET请求：获取制定项目最新Release 目标接口：GET /repos/{owner}/{repo}/releases/latest\nBruno中通过 {{var}}，可以在请求中指定变量，变量配置如下。点击发送按钮后，成功获得响应。\n请求这里的鉴权方式使用inherit， 继承collection中配置的 bearer token 鉴权方式\n2. POST请求：创建Issue 目标接口：POST /repos/{owner}/{repo}/issues\n创建issue，对应 POST 方法，Bruno中配置如下，\nBody配置：\n1 2 3 4 5 6 7 { \u0026#34;title\u0026#34;: {{issue_title}}, \u0026#34;body\u0026#34;: \u0026#34;发现一个测试问题\u0026#34;, \u0026#34;labels\u0026#34;: [ \u0026#34;bug\u0026#34; ] } 动态变量注入：\n这里的issue标题，我们使用Bruno的内置动态变量 {{$timestamp}}, Bruno提供了丰富的内置动态变量，对于我们动态模拟请求数据提供了极大方便。\n1 2 3 # 标题预置变量 vars: issue_title: \u0026#34;测试问题_{{$timestamp}}\u0026#34; 到Github上查看，Issue已创建 3. PATCH请求：修改Issue 目标接口：PATCH /repos/{owner}/{repo}/issues/3\n关闭 issue_number 为 3 的问题\n1 2 3 { \u0026#34;state\u0026#34;: \u0026#34;closed\u0026#34; } 4. DELETE请求：删除Issue 评论 目标接口：DELETE /repos/{owner}/{repo}/issues/comments/{comment_id} 基础测试断言 Test脚本验证 状态码 Bruno 中可以类似Postman那样编写Test脚本来进行结果验证\n1 2 3 test(\u0026#34;Status is 200\u0026#34;, () =\u0026gt; { expect(res.status).to.equal(200); }); 界面Assert 对于一些常用的断言，Bruno中也可以直接在界面上通过添加 Assert 来进行断言。\n以上Test和Assert 执行结果如下\n以上就是关于Bruno进行接口测试时，主要的基础功能用法介绍。后续会继续更新其他进阶用法更新。 也欢迎大家进入测试交流群和小伙伴们继续深入交流。回复 进群 获取入群邀请。\n","date":"2025-05-02T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/088-bruno%E5%9F%BA%E7%A1%80/","title":"Postman最佳平替, API测试工具Bruno实用教程(一)：基础篇"},{"content":"前言 在之前关于 AI 测试相关的几篇文章中，我们分别介绍了通过 playwright-mcp，以及 midscene.js、magentic ui 等几个不同的 AI 浏览器工具，实现 AI 驱动自动化测试的方法介绍。而其实在这些不断涌现的新工具出现之前，还有一个更早推出（2024.11），也同样还在不断完善的AI浏览器驱动工具 Browser Use，其工具实现思路，为后来的相关工具提供了很多借鉴。 而经过半年多40多个版本的迭代，目前最新版本 0.2.5，工具功能也日臻完善。\n本文，我们就再来对这个 AI 浏览器做一个系统的介绍。\nbrowser-use简介 browser-use 的定位是提供一个简易且功能强大的，将不同AI Agent和浏览器连接起来的方案，实现基于AI的智能化浏览器自动化。\n它是一个基于Python的开源库，在github上已有超过 61K 的Stars，可以说是备受关注。\n主要依托 Playwright/Puppeteer 的浏览器控制能力和 AI 大模型的推理分析能力，完成让 AI 从资讯助手向辅助执行的转变。在其之后，mcp大行其道，包括后续的其他各种浏览器AI驱动，也都能看到 browser-use 方案的影子。\n实现原理 browser-use 的实现，其实是通过 Langchain 和 LLM 大语言模型实现的一个 AI Agent 智能体，来理解网页内容并进一步生成操作指令。项目底层依赖 Playwright 框架实现浏览器自动化操作，支持多浏览器（如 Chromium、Firefox 等），能够模拟真实用户的点击、输入、导航等行为。\n基于 AI 能力，系统能够自动识别网页中的可交互元素（如按钮、输入框等），并结合上下文的理解生成对应的交互逻辑，提升自动化效率，实现基于 AI 的浏览器智能。\n核心架构解析 browser-use 通过分层架构实现 AI Agent 与浏览器的深度集成，其核心架构不同分层的主要作用如下：\nAgent 层（决策中枢） 这一层，主要负责任务流程编排与决策制定。通过实现小型状态机管理任务流程， 并与 LLM（如 OpenAI）进行交互获取决策指令。\nController 层（指令转换器） 这一层负责将高级决策转化为具体浏览器操作指令， 支持 DOM 操作、页面导航等基础动作，也提供对多标签页交互逻辑的管理。\nDOM 解析引擎 在这一层对网页结构与内容实时解析，包括提供视觉识别能力（OCR 支持），完成对可操作的网页元素映射关系的构建。\nBrowser 接口层 在这一层，基于Playwright框架实际驱动浏览器行为，除了内置的无头模式控制，也可以通过指定浏览器路径和用户浏览器进行交互。\n架构图 部署安装 建议使用 python 包管理工具 uv 进行安装部署\n1 2 3 4 uv venv --python 3.11 .venv\\Scripts\\activate uv pip install browser-use playwright install --with-deps 工具需要使用对应大模型的API KEY, 定义在.env 环境配置文件中, 支持各大主流LLM:\n1 2 3 4 5 6 7 8 OPENAI_API_KEY= ANTHROPIC_API_KEY= AZURE_OPENAI_ENDPOINT= AZURE_OPENAI_KEY= GOOGLE_API_KEY= DEEPSEEK_API_KEY= GROK_API_KEY= NOVITA_API_KEY= 通过web界面使用 browser-use 本身也提供了一个 Web UI 界面来直接调用，它也需要单独安装， 在 venv下继续执行：\n1 2 3 4 5 git clone https://github.com/browser-use/web-ui.git cd web-ui uv pip install -r requirements.txt python webui.py --ip 127.0.0.1 --port 7788 启动界面 运行成功后，会看到如下 web-ui 的界面，Agent Settings 可以在界面上配置使用的LLM，Browser Settings 配置浏览器的交互方式，Run Agent 是实际调用大模型和浏览器完成自动化任务的交互界面和结果记录 LLM配置 这里使用的是本地部署的Ollama+Deepseek-r1:14b\n运行过程 实际调用的浏览器和运行日志：\n整个执行过程还会生成一个 gif 图： Python脚本调用 除了通过 Web-UI 来完成任务，当然更多的情况下是通过代码调用，比如如下代码通过 Deepseek的官方API调用，包括了输出格式的定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from langchain_deepseek import ChatDeepSeek from browser_use import Agent from pydantic import SecretStr, BaseModel, ValidationError, field_validator, ConfigDict, Field from dotenv import load_dotenv import os import asyncio from typing import List,Optional from browser_use import Controller import json # 统一模型输出定义 class PostItem(BaseModel): model_config = ConfigDict(extra=\u0026#34;ignore\u0026#34;) post_title: str post_url: str num_comments: int hours_since_post: int @field_validator(\u0026#39;num_comments\u0026#39;, \u0026#39;hours_since_post\u0026#39;, mode=\u0026#39;before\u0026#39;) def convert_numbers(cls, value): \u0026#34;\u0026#34;\u0026#34;确保数值字段转换为整数\u0026#34;\u0026#34;\u0026#34; if isinstance(value, str) and value.isdigit(): return int(value) return value or 0 class Posts(BaseModel): posts: list[PostItem] total: int # 结果解析函数 def parse_result(result: str | dict) -\u0026gt; Posts: \u0026#34;\u0026#34;\u0026#34;安全解析结果数据\u0026#34;\u0026#34;\u0026#34; try: if isinstance(result, str): data = json.loads(result) else: data = result print(\u0026#34;Parsed data:\u0026#34;, data) return Posts.model_validate(data) except (json.JSONDecodeError, ValidationError) as e: print(f\u0026#34;解析错误: {type(e).__name__}: {e}\u0026#34;) # 非json格式，直接返回结果 return result controller = Controller(output_model=Posts) load_dotenv() api_key = os.getenv(\u0026#34;DEEPSEEK_API_KEY\u0026#34;) # Initialize the model llm=ChatDeepSeek(base_url=\u0026#39;https://api.deepseek.com/v1\u0026#39;, model=\u0026#39;deepseek-reasoner\u0026#39;, api_key=SecretStr(api_key)) async def main(): # Create agent with the model agent = Agent( task=\u0026#34;测试saucedemo.com网站standard_user的登录功能, 使用不同密码(secret_sauce,空密码)，登录成功则验证完成，否则需要输出错误信息。测试结果需要包含以下信息：\\n1. 登录是否成功\\n2. 如果登录失败，错误信息是什么\\n\u0026#34;, llm=llm, use_vision=False ) history = await agent.run() result = history.final_result() parsed = parse_result(result) if parsed.posts: for post in parsed.posts: print(\u0026#39;\\n--------------------------------\u0026#39;) print(f\u0026#39;Title: {post.post_title}\u0026#39;) print(f\u0026#39;URL: {post.post_url}\u0026#39;) print(f\u0026#39;Comments: {post.num_comments}\u0026#39;) print(f\u0026#39;Hours since post: {post.hours_since_post}\u0026#39;) else: print(result) # 异步主函数 if __name__ == \u0026#34;__main__\u0026#34;: try: asyncio.run(main()) except Exception as e: print(f\u0026#34;程序运行时出错: {e}\u0026#34;) 执行也是通过playwright打开浏览器，效果和web-ui类似。\n程序输出如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 C:\\qiucao\\AI\\browser_use\u0026gt;python app.py WARNING [agent] ⚠️ DeepSeek models do not support use_vision=True yet. Setting use_vision=False for now... INFO [agent] 🧠 Starting an agent with main_model=deepseek-reasoner +rawtools +memory, planner_model=None, extraction_model=deepseek-reasoner INFO [mem0.vector_stores.faiss] Loaded FAISS index from /tmp/mem0_384_faiss/mem0.faiss with 0 vectors INFO [mem0.vector_stores.faiss] Loaded FAISS index from C:\\Users\\weiwe\\.mem0\\migrations_faiss/mem0_migrations.faiss with 1 vectors INFO [agent] 🚀 Starting task: 测试saucedemo.com网站standard_user的登录功能, 使用不同密码(secret_sauce,空密码)，登录成功则验证完成，否则需要输出错误信息。测试结果需要包含以下信息： 1. 登录是否成功 2. 如果登录失败，错误信息是什么 INFO [agent] 📍 Step 1 INFO [agent] 🤷 Eval: Unknown - Just started the task. No previous actions taken. INFO [agent] 🧠 Memory: Starting task: Test login functionality on saucedemo.com for user \u0026#39;standard_user\u0026#39; with two password cases. 0 out of 2 password tests completed. First need to navigate to login page. INFO [agent] 🎯 Next goal: Navigate to saucedemo.com login page to begin testing INFO [agent] 🛠️ Action 1/1: {\u0026#34;go_to_url\u0026#34;:{\u0026#34;url\u0026#34;:\u0026#34;https://www.saucedemo.com\u0026#34;}} INFO [controller] 🔗 Navigated to https://www.saucedemo.com INFO [agent] 📍 Step 2 INFO [agent] 👍 Eval: Success - Navigation to saucedemo.com completed successfully. Login page is loaded with required input fields visible. INFO [agent] 🧠 Memory: 0 out of 2 password tests completed. Starting first test case: username \u0026#39;standard_user\u0026#39; with valid password \u0026#39;secret_sauce\u0026#39;. Will verify login success by checking URL change to /inventory.html after submission. INFO [agent] 🎯 Next goal: Execute first login test with valid credentials and verify success INFO [agent] 🛠️ Action 1/3: {\u0026#34;input_text\u0026#34;:{\u0026#34;index\u0026#34;:0,\u0026#34;text\u0026#34;:\u0026#34;standard_user\u0026#34;}} INFO [agent] 🛠️ Action 2/3: {\u0026#34;input_text\u0026#34;:{\u0026#34;index\u0026#34;:1,\u0026#34;text\u0026#34;:\u0026#34;secret_sauce\u0026#34;}} INFO [agent] 🛠️ Action 3/3: {\u0026#34;click_element_by_index\u0026#34;:{\u0026#34;index\u0026#34;:2}} INFO [controller] ⌨️ Input standard_user into index 0 INFO [controller] ⌨️ Input secret_sauce into index 1 INFO [controller] 🖱️ Clicked button with index 2: INFO [agent] 📍 Step 3 WARNING [message_manager] Failed to parse model output: { \u0026#34;current_state\u0026#34;: { \u0026#34;evaluation_previous_goal\u0026#34;: \u0026#34;Success - First test case completed: Login with username \u0026#39;standard_user\u0026#39; and password \u0026#39;secret_sauce\u0026#39; was successful. Verified by URL change to /inventory.html and presence of product listings.\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;1 out of 2 password tests completed. First test successful. Next: Test with empty password. Need to logout before second test.\u0026#34;, \u0026#34;next_goal\u0026#34;: \u0026#34;Logout to return to login page for second test case\u0026#34; }, \u0026#34;action\u0026#34;: [ {\u0026#34;click_element_by_index\u0026#34;: {\u0026#34;index\u0026#34;: 0}}, // Open menu {\u0026#34;wait\u0026#34;: {\u0026#34;seconds\u0026#34;: 2}}, // Wait for menu animation {\u0026#34;click_element_by_index\u0026#34;: {\u0026#34;index\u0026#34;: 34}} // Logout (assuming logout appears at index 34 after menu opens) ] } Expecting value: line 8 column 48 (char 532) WARNING [agent] Failed to parse model output: content=\u0026#39;{\\n \u0026#34;current_state\u0026#34;: {\\n \u0026#34;evaluation_previous_goal\u0026#34;: \u0026#34;Success - First test case completed: Login with username \\\u0026#39;standard_user\\\u0026#39; and password \\\u0026#39;secret_sauce\\\u0026#39; was successful. Verified by URL change to /inventory.html and presence of product listings.\u0026#34;,\\n \u0026#34;memory\u0026#34;: \u0026#34;1 out of 2 password tests completed. First test successful. Next: Test with empty password. Need to logout before second test.\u0026#34;,\\n \u0026#34;next_goal\u0026#34;: \u0026#34;Logout to return to login page for second test case\u0026#34;\\n },\\n \u0026#34;action\u0026#34;: [\\n {\u0026#34;click_element_by_index\u0026#34;: {\u0026#34;index\u0026#34;: 0}}, // Open menu\\n {\u0026#34;wait\u0026#34;: {\u0026#34;seconds\u0026#34;: 2}}, // Wait for menu animation\\n {\u0026#34;click_element_by_index\u0026#34;: {\u0026#34;index\u0026#34;: 34}} // Logout (assuming logout appears at index 34 after menu opens)\\n ]\\n}\u0026#39; additional_kwargs={\u0026#39;refusal\u0026#39;: None, \u0026#39;reasoning_content\u0026#39;: \u0026#39;We are on the inventory page after successful login with the first password (secret_sauce). This indicates that the first test case (valid password) was successful.\\n Now, we need to test the second case: empty password. \\n However, we are currently logged in. We must first log out to return to the login page.\\n\\n Steps:\\n 1. Open the menu (index 0: button with text \u0026#34;Open Menu\u0026#34;)\\n 2. In the menu, there should be a logout option. We need to find the logout link.\\n\\n But note: the interactive elements provided are only for the current viewport. The menu is not open, so the logout link is not visible yet.\\n\\n After clicking the menu button, the menu will open and we can see the logout link. Then we can click it.\\n\\n However, the current action sequence can only include actions that are based on the current state (before opening the menu). So we can only plan to click the menu button now, and then in the next step we will see the updated elements including the logout link.\\n\\n Alternatively, we could use a longer sequence? But the problem is that after clicking the menu, the page changes (menu opens) so the state updates and we get new interactive elements. Therefore, we should only click the menu now and then in the next step we will see the logout link.\\n\\n But note: the task requires testing two cases. We have done one (with valid password) and now we need to do the second (empty password). We must log out first.\\n\\n Plan:\\n Step 1: Click the menu button (index 0)\\n Step 2: After the menu opens, we expect to see a logout link. Then click that logout link to return to the login page.\\n\\n However, the current response can only include one step because the state will change after clicking the menu. So we do:\\n\\n Action: [{\u0026#34;click_element_by_index\u0026#34;: {\u0026#34;index\u0026#34;: 0}}]\\n\\n Then in the next step, we will see the menu and the logout link, and then we can click logout.\\n\\n But note: the task history memory is now at step 3/100. We have to remember that we are in the middle of the second test case.\\n\\n We have to update the memory: \\n First test case: valid password -\u0026gt; successful login (we are on inventory page)\\n Now we are going to log out to test the second case.\\n\\n Let\\\u0026#39;s write the state accordingly.\u0026#39;} response_metadata={\u0026#39;token_usage\u0026#39;: {\u0026#39;completion_tokens\u0026#39;: 678, \u0026#39;prompt_tokens\u0026#39;: 4236, \u0026#39;total_tokens\u0026#39;: 4914, \u0026#39;completion_tokens_details\u0026#39;: {\u0026#39;accepted_prediction_tokens\u0026#39;: None, \u0026#39;audio_tokens\u0026#39;: None, \u0026#39;reasoning_tokens\u0026#39;: 495, \u0026#39;rejected_prediction_tokens\u0026#39;: None}, \u0026#39;prompt_tokens_details\u0026#39;: {\u0026#39;audio_tokens\u0026#39;: None, \u0026#39;cached_tokens\u0026#39;: 3072}, \u0026#39;prompt_cache_hit_tokens\u0026#39;: 3072, \u0026#39;prompt_cache_miss_tokens\u0026#39;: 1164}, \u0026#39;model_name\u0026#39;: \u0026#39;deepseek-reasoner\u0026#39;, \u0026#39;system_fingerprint\u0026#39;: \u0026#39;fp_393bca965e_prod0425fp8\u0026#39;, \u0026#39;id\u0026#39;: \u0026#39;68127967-53c3-4329-a9fe-01feb6090fc4\u0026#39;, \u0026#39;finish_reason\u0026#39;: \u0026#39;stop\u0026#39;, \u0026#39;logprobs\u0026#39;: None} id=\u0026#39;run-c6f0d672-4dd5-4ea7-b269-9c908f5aef4e-0\u0026#39; usage_metadata={\u0026#39;input_tokens\u0026#39;: 4236, \u0026#39;output_tokens\u0026#39;: 678, \u0026#39;total_tokens\u0026#39;: 4914, \u0026#39;input_token_details\u0026#39;: {\u0026#39;cache_read\u0026#39;: 3072}, \u0026#39;output_token_details\u0026#39;: {\u0026#39;reasoning\u0026#39;: 495}} Could not parse response. ERROR [agent] ❌ Result failed 1/3 times: Could not parse response. INFO [agent] 📍 Step 3 INFO [agent] 👍 Eval: Success - First test case completed successfully. Login with valid password \u0026#39;secret_sauce\u0026#39; succeeded as confirmed by URL change to /inventory.html and visible product listings. INFO [agent] 🧠 Memory: 1 out of 2 password tests completed (valid password successful). Remaining: test with empty password. Need to logout before next test. INFO [agent] 🎯 Next goal: Logout to return to login page for second test case INFO [agent] 🛠️ Action 1/2: {\u0026#34;click_element_by_index\u0026#34;:{\u0026#34;index\u0026#34;:0}} INFO [agent] 🛠️ Action 2/2: {\u0026#34;wait\u0026#34;:{\u0026#34;seconds\u0026#34;:2}} INFO [controller] 🖱️ Clicked button with index 0: Open Menu INFO [controller] 🕒 Waiting for 2 seconds INFO [agent] 📍 Step 4 INFO [agent] 👍 Eval: Success - Menu opened successfully after login. Logout option is visible at index 2. INFO [agent] 🧠 Memory: 1 out of 2 password tests completed (valid password successful). Need to logout for second test with empty password. Next: click logout button. INFO [agent] 🎯 Next goal: Logout to return to login page for second password test case INFO [agent] 🛠️ Action 1/1: {\u0026#34;click_element_by_index\u0026#34;:{\u0026#34;index\u0026#34;:2}} INFO [controller] 🖱️ Clicked button with index 2: Logout INFO [agent] 📍 Step 5 INFO [agent] 👍 Eval: Success - Successfully logged out and returned to login page. All interactive elements for testing are available. INFO [agent] 🧠 Memory: 1 out of 2 password tests completed (valid password successful). Remaining test: username \u0026#39;standard_user\u0026#39; with empty password. After submission, need to capture error message if login fails. INFO [agent] 🎯 Next goal: Execute second test case with empty password and capture results INFO [agent] 🛠️ Action 1/3: {\u0026#34;input_text\u0026#34;:{\u0026#34;index\u0026#34;:0,\u0026#34;text\u0026#34;:\u0026#34;standard_user\u0026#34;}} INFO [agent] 🛠️ Action 2/3: {\u0026#34;input_text\u0026#34;:{\u0026#34;index\u0026#34;:1,\u0026#34;text\u0026#34;:\u0026#34;\u0026#34;}} INFO [agent] 🛠️ Action 3/3: {\u0026#34;click_element_by_index\u0026#34;:{\u0026#34;index\u0026#34;:2}} INFO [controller] ⌨️ Input standard_user into index 0 INFO [controller] ⌨️ Input into index 1 INFO [controller] 🖱️ Clicked button with index 2: INFO [agent] 📍 Step 6 INFO [agent] 👍 Eval: Success - Second test case completed: Login failed as expected with empty password. Error message \u0026#39;Epic sadface: Password is required\u0026#39; is visible on page. INFO [agent] 🧠 Memory: 2 out of 2 password tests completed: 1) Valid password \u0026#39;secret_sauce\u0026#39; - login succeeded 2) Empty password - login failed with error. No remaining tests. INFO [agent] 🎯 Next goal: Compile final test results and complete task INFO [agent] 🛠️ Action 1/1: {\u0026#34;done\u0026#34;:{\u0026#34;text\u0026#34;:\u0026#34;测试结果：\\n1. 测试用例1 (密码: secret_sauce):\\n - 登录成功: 是\\n - 错误信息: 无\\n\\n2. 测试用例2 (密码: 空):\\n - 登录成功: 否\\n - 错误信息: \\\u0026#34;Epic sadface: Password is required\\\u0026#34;\u0026#34;,\u0026#34;success\u0026#34;:true}} INFO [agent] 📄 Result: 测试结果： 1. 测试用例1 (密码: secret_sauce): - 登录成功: 是 - 错误信息: 无 2. 测试用例2 (密码: 空): - 登录成功: 否 - 错误信息: \u0026#34;Epic sadface: Password is required\u0026#34; INFO [agent] ✅ Task completed INFO [agent] ✅ Successfully INFO [agent] 📝 Total input tokens used (approximate): 33168 INFO [agent] Agent run telemetry logged. 从以上输出，可见Browser-Use 将任务分解为了6步：\n开始任务，访问网站 https://www.saucedemo.com 输入正常用户 standard_user/secret_sauce，点击登录按钮 点击登出（未发现登出按钮，重试） 点击菜单后登出 使用空密码重新登录 测试完成，获取输出结果 总结 通过以上案例，可以看到，Browser-Use 可以有效借助 LLM根据我们输入的提示词，分解任务，实现对页面的有效解析并完成执行，获取结果。\n执行效率上来说，API调用相对还是比较慢，对于复杂任务，会耗时较长。而在任务开始后，我们并无法干预后续执行路径（除非强制中断），这也是后续如 Magentic UI 这样工具的重点优化方向。\n但 Browser-Use 的优点是已经较为成熟，对本地大模型和多种在线大模型都有良好支持，社区实践也较多，利用它辅助完成自动化测试也已有较多实践，包括系统提示词的优化。是我们利用AI辅助自动化测试的一个较好方向。\nMermaid 架构图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 graph TD A[AI Agent] --\u0026gt;|决策指令| B(Controller) B --\u0026gt;|DOM操作指令| C[DOM 解析引擎] C --\u0026gt;|网页内容| D[Browser 接口] D --\u0026gt;|浏览器交互| E[Chrome/Edge] subgraph 功能模块 B --\u0026gt; 多标签管理 C --\u0026gt; 视觉识别(OCR) D --\u0026gt; 真实用户行为模拟 end style A fill:#FFE4B5,stroke:#333 style E fill:#98FB98,stroke:#333 ","date":"2025-04-30T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/086-browser-use%E7%9A%84%E4%BD%BF%E7%94%A8/snap_20250529-1_hu_fb3bcb7e910691d3.png","permalink":"https://chengxiaqiucao.github.io/post/086-browser-use%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"AI智能驱动浏览器工具Browser Use详解"},{"content":"序言 Postman长期以来都是API测试领域居领先地位的测试工具。以其友好的工具界面，便捷的API接口请求编辑，强大的脚本支持和云端服务，以及丰富的生态，在接口开发和测试中，有极为广泛你的应用。\n但作为一个商用工具，它的很多高级功能都依赖云端服务，且收费不菲。虽然免费的基础版本同样功能强大，能满足大部分使用需求，但随着工具本身和云端服务的整合以及更多向协作平台方向发展，基础版本也需要注册并登录云端服务后才可完全使用。\n但这却限制了很多脱离互联网环境的应用需求，而且频繁的同步机制和连接稳定性要求也颇受诟病。\n很多受Postman这些限制困扰的同学也一直在寻找和Postman类似的替代工具，本文我们向大家介绍一个API接口测试明日之星，开源接口测试工具 Bruno\n从github的star趋势可以看到，Bruno诞生不久，但从2024年开始，已经开始得到广泛关注，star数量一路飙升，潜力无限！\nBruno简介 可以说 Bruno 从诞生之初针对的就是前述 Postman 的痛点。官方首页上强调的 Bruno 主要特性也重点说明了这几点：\n承诺开源和可扩展，并且专心做客户端，永不向“平台化”扩充产品。 基于Git实现协作和版本管理 离线使用，永不同步本地数据 😂😂😂 可以说，Bruno的出现，就是针对Postman作为一个客户端工具，过于强调平台化和云端功能的现状，提供的平替方案。\nBruno的优势 Bruno在官方网站上，也是专门针对 Postman ，将Bruno和Postman进行了详细比对（当然一家之言，免不得自吹，大家辩证看待）网址如下： https://www.usebruno.com/compare/bruno-vs-postman\n我整理了一下，主要包含如下几个维度：\n整体定位 Bruno Postman 开源、本地优先、注重隐私 最初是 API 客户端，现已发展为包含云协作功能的 API 平台 数据存储 Bruno Postman 集合直接存储在本地文件系统，使用名为 Bru 的纯文本标记语言 主要存储在 Postman 云端，需要账户登录（虽然可以导出，但核心工作流依赖云） 开放源码 Bruno Postman 完全开源 (MIT 许可证) 部分开源，核心平台和云服务是专有的 离线支持 Bruno Postman 完全支持离线工作，因为所有数据都在本地 核心功能（尤其协作）严重依赖在线连接和账户登录 协作方式 Bruno Postman 通过 Git 或任何版本控制系统进行协作，利用其文件存储特性 通过 Postman 内置的云同步和团队协作功能（通常需要付费计划） CLI命令行 Bruno Postman 提供名为 bru 的 CLI 工具，用于运行集合和测试 提供名为 Newman 的 CLI 工具，用于运行集合和集成到 CI/CD 脚本支持 Bruno Postman 支持声明式脚本（Bru Lang）和 JavaScript 进行自动化测试和脚本编写 支持 JavaScript 进行请求前脚本、测试脚本编写 交互界面 Bruno Postman 界面和功能相对更简洁，专注于 API 请求和测试的核心任务 功能更全面，但也可能更复杂，涵盖了 API 设计、文档、监控等更多方面 版本控制 Bruno Postman 可直接利用 Git 进行精细的版本控制 内置版本控制功能，但与 Git 的集成和灵活性不同 总体来说，Bruno针对Postman的主要痛点，都给出了对应的应对处理，如果使用Postman受限或更希望在非互联网线环境下进行接口测试，可以说Bruno就是最佳选择\nBruno的局限性 虽然Bruno已经受到了极大的关注，而且功能也足够丰富，但相比Postman这样老牌头部工具，功能上还是有一些局限性。这里总结起来，大致有如下几点：\n云端协作和同步 完全本地化和简洁、轻量，是Bruno重点突出的优势，但换一个角度来说，也是它主要的局限。\nBruno的团队协作以来Git来实现，对于熟悉Git使用的研发团队来说，当然足够强大，但如果团队对API的协作牵涉到混合团队时，比如包含客户、设计人员、产品经理等时，Git的使用门槛就相对更高了。Postman那样的基于云服务的团队功能则更易于接受，团队共享工作区、并可进行评论、共享。\n在API全生命周期管理上的欠缺 还是因为纯本地客户端的原因，Bruno很难像Postman那样实现针对API的全生命周期管理和支持，包括接口设计（OpenAPI、swagger等接口设计的导入）、交互式文档（API Documentation）、接口模拟（Mock Server）、健康监测（monitor）等，Postman都有对应的功能可以覆盖，而Bruno则无法涵盖如此丰富的场景。\n接口类型支持不如Postman丰富 虽然Bruno目前已经支持restful和GraphQL接口，已经能够满足我们绝大多数的接口测试协议要求。但相比Postman还有MQTT这样的物联网协议支持，在协议扩展上，还有待继续补充。\n生态系统不如Postman成熟 Postman 经过多年发展，已经围绕其平台构建了一个庞大的生态系统，包括大量的第三方工具集成（如很多第三方的 APM 工具、API 网关、CI/CD 工具等）都对Postman支持良好）。 经过多年积累，Postman社区繁荣，用户数量庞大，积累了海量的资源和教程。 Bruno 作为一个较新的工具，其原生集成和社区支持的插件相对较少\nAI测试能力的支持 Postman通过内置的 postbot 助手，借助AI能力，可以实现接口测试用例的自动生成，优化建议等典型的AI增强。而随着AI应用的越来越广泛，对AI的支持也是Bruno还需要重点补充的部分。\nBruno安装和应用基本示例 Bruno作为一个纯客户端，安装其实极为方便。访问官网，下载对应安装包即可(https://www.usebruno.com/downloads)。\nwin11下也可以利用内建的winget命令直接下载安装\n1 winget install bruno.bruno 安装后，桌面上会出一个bruno的小狗logo，类似Postman，双击就可打开Bruno客户端，界面其实和Postman颇为类似。下面我们以获取Github上一个开源项目的最近一次发布为例，看下Bruno中如何操作。\n首先建立一个collection，命名为 \u0026ldquo;github\u0026rdquo;, 并在其下创建一个目录，“repos”。 并可以在collection设置界面，添加github的访问Token。这里可以看到，Bruno支持的鉴权方式已经非常全面。 在 “repos” 目录下，新建一个Get请求，“getRelease”, 根据Github定义，对应请求接口 \u0026ldquo;https://api.github.com/repos/{{owner}}/{{repo}}/releases/latest\"， 这里我们使用了两个变量，和Postman类似，这里设置的变量可以通过{{var}} 来引用。 测试一下，成功获取了appium项目的最近一次发布信息 作为一个本地客户端，这里Bruno所有的请求和配置信息，其实都保存在本地，.bru文件中进行存储。\n以上就是关于Bruno的几个概要介绍，对于不希望受Postman在线限制的同学，Bruno就是最佳替代。\n欢迎继续关注秋草的后续博客文章，会陆续带来更多关于Bruno的深度使用总结和分享！\n","date":"2025-04-30T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/089-bruno%E4%BB%8B%E7%BB%8D/snap_20250420-2_hu_de9bb9f20c45a4ff.png","permalink":"https://chengxiaqiucao.github.io/post/089-bruno%E4%BB%8B%E7%BB%8D/","title":"github星标超3万！Postman最强平替Bruno你用了吗？"},{"content":"前言 之前在介绍Markdown文档中图片处理方法的文章 【本地Markdown编写的文档，发布到网上如何处理图片？】 中，介绍了可以使用 AutoHotKey 来辅助完成截图和链接的自动生成。有小伙伴私信问这个工具的具体用法。\n下文我们就比较系统地介绍下这个工具，了解通过ahk的脚本魔法，如何让重复操作一键完成！\nAHK简介 在追求效率的软件开发与技术工作中，重复性操作往往吞噬宝贵时间。AutoHotkey（AHK）作为一款轻量级、开源的Windows桌面自动化工具。可以通过编写简洁的脚本，将用户从繁琐、重复的键盘鼠标操作中解放出来，显著提升工作效率。\n理解AHK的关键在于其脚本语言。核心功能包括模拟键盘输入（Send）、鼠标操作（Click）、程序运行（Run）、条件判断（If）和循环控制（Loop）等。用户无需编译环境，脚本文件（.ahk）可直接运行，资源占用极低。\nAHK的应用场景极为广泛。简单如自动填写表单、快捷输入预设短语；进阶如批量重命名文件、自动化软件测试、定制专属工作流；甚至可开发带有图形界面（GUI）的小工具。其强大之处在于深度集成Windows系统，能够操作窗口、读写注册表、访问文件系统，实现高度的定制化自动化。\n简单来说，AutoHotKey 赋予了用户用脚本指挥电脑的能力。无论是开发者、办公人员还是追求效率的普通用户，都能通过它定制专属的“快捷键魔法”，将重复劳动转化为瞬间完成的自动化操作。\nAHK 核心语法与常用函数 **基础热键 热键定义：由一个热键后跟双冒号组成. 1 2 3 ^j:: ; Ctrl+J 热键 Send, Hello World! ; 发送文本 return 如果只有一行执行的操作， return 也可省略\n符号 描述 # Win 键 (Windows 徽标键)\n- 等待 Win 释放后发送文本（Vista+）\n- 可能导致额外模拟击键（详见 #MenuMaskKey) ! Alt 键\n- 可能导致额外模拟击键（详见 #MenuMaskKey) ^ Ctrl 键 + Shift 键 \u0026amp; 组合任意两个按键/鼠标按钮创建自定义热键 \u0026lt; 使用成对按键中的左侧键（如 \u0026lt;!a 仅左 Alt 触发） \u0026gt; 使用成对按键中的右侧键 \u0026lt;^\u0026gt;! AltGr 键（替代图形键）\n- 表示 AltGr 组合键（如 \u0026lt;^\u0026gt;!m）\n- 单独使用：LControl \u0026amp; RAlt * 通配符：即使附加修饰键按住也能触发\n- 示例：*#c（Win+C/Shift+Win+C 等均触发）\n- 强制使用键盘钩子 ~ 保留按键原生功能（不屏蔽操作系统事件）\n- 示例：~RButton（右键点击仍发送到窗口）\n- 影响所有组合行为\n- 强制使用键盘钩子 $ 强制使用键盘钩子，避免 Send 命令触发自身\n- 对鼠标热键无效\n- 替代方案：#InputLevel/SendLevel (v1.1.06+) UP 在按键释放时触发（非按下时）\n- 示例：^!r Up::（释放 Ctrl+Alt+R 触发）\n- 限制：\n1) 不适用于控制器按钮\n2) 需配合普通热键避免卡键 示例\n1 2 3 4 5 6 #a::Run Calculator ; Win+A 启动计算器 ^!+s::Send Hello World ; Ctrl+Alt+Shift+S 发送文本 ~RButton::MsgBox Right Click ; 保留右键原生功能的弹窗 LWin \u0026amp; R::Reload ; 左Win+R 重载脚本 *#c::Run cmd.exe ; 任何修饰键+Win+C 启动命令提示符 ^!r Up::MsgBox Released ; 释放组合键时触发 热字串 热字串：由一个冒号, 零个或多个选项, 另一个冒号, 缩写字符和双冒号组成. 1 :*:btw:: by the way ; 输入btw后按空格/回车替换 或者也可以通过热字串执行复杂些的操作\n1 2 3 4 :*:]d:: ; 此热字串通过后面的命令把 \u0026#34;]d\u0026#34; 替换成当前日期和时间. FormatTime, CurrentDateTime,, M/d/yyyy h:mm tt ; SendInput %CurrentDateTime% return 核心命令函数 常用的一些核心函数包括：\n函数名 类别 描述 FileExist 文件操作 检查文件/文件夹是否存在并返回属性（如 \u0026ldquo;D\u0026rdquo; 表示目录） GetKeyState 输入检测 检测键盘/鼠标按键状态，返回 1（按下）或 0（松开） InStr 字符串处理 查找子串在字符串中的位置，支持从左/右搜索 StrLen 字符串处理 获取字符串长度（字节数或字符数） SubStr 字符串处理 截取字符串指定位置开始的子串 WinActive 窗口控制 检测指定窗口是否活动，返回窗口句柄（HWND） WinExist 窗口控制 检测指定窗口是否存在，返回首个匹配窗口句柄 Format 数据处理 格式化字符串（类似 sprintf 功能） DllCall 系统交互 调用 Windows API 等外部 DLL 函数 Run 进程控制 启动程序/执行命令（已在初稿列出，此处补充完整描述） 示例:\n1 2 3 4 5 6 ; 组合使用示例 if WinActive(\u0026#34;ahk_exe chrome.exe\u0026#34;) \u0026amp;\u0026amp; GetKeyState(\u0026#34;Ctrl\u0026#34;, \u0026#34;P\u0026#34;) { FileAppend, %Format(\u0026#34;[%time%] Ctrl pressed in Chrome`n\u0026#34;)%, log.txt Send ^{t} ; 在Chrome中新建标签页 } 变量与表达式 变量无需声明，直接赋值（如 count := 10） 支持字符串拼接（. 运算符）与数学运算 实用案例说明 案例 1：截图自动生成 Markdown 图片链接 痛点：手动截图→保存→复制路径→插入 Markdown 繁琐 解决方案：一键完成截图并生成标准链接\n1 2 3 4 5 6 7 8 9 10 11 12 13 #s:: ; Win+S 快捷键 Run, %A_WinDir%\\System32\\SnippingTool.exe ; 启动截图工具 WinWaitActive, Snip \u0026amp; Sketch ; 等待窗口激活 Send, ^+n ; 模拟新建截图快捷键（Ctrl+Shift+N） WinWaitActive, ahk_class Microsoft.ScreenSketch ; 等待截图完成 Send, ^s ; 保存截图 WinWaitActive, Save As ; 等待保存对话框 FormatTime, CurrentTime,, yyyyMMdd_HHmmss ; 生成时间戳文件名 SendInput, %CurrentTime%.png{Enter} ; 输入文件名 Sleep, 1000 ; 等待保存完成 clipboard := \u0026#34;![](\u0026#34; . A_Desktop . \u0026#34;\\\u0026#34; . CurrentTime . \u0026#34;.png)\u0026#34; ; 生成MD链接 MsgBox, Markdown截图链接已复制到剪贴板！ return 效果：按 Win+S → 截图 → 自动保存为带时间戳的 PNG → 剪贴板生成 ![](路径) 格式链接。\n案例 2：一键执行复杂命令序列 痛点：部署环境需重复输入多条命令 解决方案：单键触发命令组合\n1 2 3 4 5 6 7 8 9 10 ^!d:: ; Ctrl+Alt+D Run, cmd.exe, C:\\MyProject ; 打开CMD并进入项目目录 WinWaitActive, ahk_class ConsoleWindowClass Send, git pull origin main{Enter} Sleep, 2000 ; 等待git pull完成 Send, mvn clean install{Enter} Sleep, 5000 ; 等待Maven构建 Send, docker-compose up -d{Enter} MsgBox, 环境部署命令已执行！ return 效果：一键完成代码拉取、项目构建、容器启动。\n案例 3：自动化测试数据生成 痛点：手动创建大量测试数据效率低下 解决方案：脚本批量生成结构化数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 F9:: testData := \u0026#34;\u0026#34; Loop, 100 { ; 生成100条数据 name := \u0026#34;User\u0026#34; . A_Index email := \u0026#34;user\u0026#34; . A_Index . \u0026#34;@test.com\u0026#34; age := Random(18, 60) ; 自定义Random函数生成随机数 testData .= name \u0026#34;,\u0026#34; email \u0026#34;,\u0026#34; age \u0026#34;`n\u0026#34; ; 拼接CSV格式 } FileAppend, %testData%, C:\\TestData\\users.csv ; 写入文件 Run, notepad.exe C:\\TestData\\users.csv ; 打开查看 return Random(min, max) { Random, rand, min, max return rand } 效果：按 F9 自动生成含用户名、邮箱、年龄的 100 条 CSV 测试数据。\n总结：为什么使用AutoHotKey？ 极简入门：语法接近自然语言，无需编译环境 资源友好：轻量级（安装包 \u0026lt; 3MB），后台占用可忽略 深度集成：无缝操作窗口、注册表、文件系统 生态丰富：官方论坛提供海量脚本库与插件支持 跨场景适用：从文本处理到 GUI 自动化全覆盖 进一步学习：\n官方文档：https://www.autohotkey.com/docs/ 脚本仓库：https://github.com/AutoHotkey 你的下一个自动化脚本，准备解决哪个痛点？\n","date":"2025-04-29T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/085-autohotkey/","title":"AutoHotKey：让效率倍增的桌面自动化利器"},{"content":"前言 自动化测试领域目前最火热的自动化框架非Playwright 莫属，而在 Playwright 中，对于自动化测试中极为关键的页面元素定位，相比传统的Selenium等工具, 它引入了一个新的元素定位方法 getByRole，也就是它充分利用了W3C 定义的 ARIA Roles对象, 来进行元素的识别。在提升元素识别灵活性及识别效率的同时，其实也同步对页面的无障碍合规进行了验证。 比如：\n1 2 3 4 5 6 7 8 9 10 11 // 定位名为\u0026#34;搜索\u0026#34;的按钮 await page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;搜索\u0026#39; }).click(); // 定位复选框并勾选 await page.getByRole(\u0026#39;checkbox\u0026#39;, { name: \u0026#39;同意条款\u0026#39; }).check(); // 定位文本输入框并填写内容 await page.getByRole(\u0026#39;textbox\u0026#39;, { name: \u0026#39;用户名\u0026#39; }).fill(\u0026#39;testuser\u0026#39;); // 定位下拉选择框并选择选项 await page.getByRole(\u0026#39;combobox\u0026#39;, { name: \u0026#39;国家\u0026#39; }).selectOption(\u0026#39;中国\u0026#39;); 而目前，AI 越来越多地参与到我们实际工作中，正如前文 【】中展示的，AI 通过 mcp server驱动页面完成自动化测试已经具备相当的落地可能。在这个文章后，很多小伙伴对于 AI 如何对页面元素进行识别和定位，并通过工具来驱动执行，实际应用后效果能否达到预期抱有较大的怀疑。\n其实这里，W3Cweb规范中的ARIA标准，对于将页面对象结构化展示给AI，便于AI对页面完成分析，有着重要意义。 本文，我们就来探讨一下ARIA标准，及其在AI驱动自动化测试中的重要作用。\n什么是ARIA？ 定义 WAI-ARIA (Web Accessibility Initiative – Accessible Rich Internet Applications)，即 web无障碍倡议-无障碍富互联网应用标准， 是一个让Web应用可以更好支持残障人士使用的规范。\n而ARIA Roles是W3C WAI-ARIA 规范中定义的一组属性，用于描述Web元素的功能和目的，帮助辅助技术（如屏幕阅读器）更准确地理解和传达页面内容。**ARIA Roles **通过role属性添加到HTML元素中，例如\u0026lt;div role=\u0026quot;button\u0026quot;\u0026gt;表示该div元素应被视为按钮。\n标准的演进及ARIA的优势 该标准经历了三个重要发展阶段：\n2008年：W3C首次发布ARIA 1.0 2014年：ARIA 1.1引入新角色如searchbox、switch 2021年：ARIA 1.2增加了comment、mark等数字内容相关Role 和传统 UI 自动化测试的比较：\n维度 传统UI测试 基于ARIA的测试 元素识别依据 DOM结构/视觉特征 语义角色/功能属性 维护成本 高(随UI变化频繁更新) 低(角色定义更稳定) 跨平台一致性 依赖渲染引擎 标准化行为 无障碍支持 需额外验证 内置支持 ARIA Roles类别 根据W3C规范，ARIA Roles可分为以下几大类：\nWidget Roles：描述交互式UI组件\nbutton：可点击的按钮 checkbox：复选框 radio：单选按钮 textbox：文本输入框 combobox：下拉组合框 slider：滑块控件 Document Structure Roles：描述页面内容结构\nheading：标题 (h1-h6的替代) list/listitem：列表和列表项 table/row/cell：表格结构 img：图像 Landmark Roles：标识页面主要区域\nbanner：页眉 navigation：导航区域 main：主要内容 search：搜索区域 contentinfo：页脚信息 Live Region Roles：动态内容更新区域\nalert：重要且需立即通知的信息 status：操作状态反馈 timer：计时器或计数器 除基础Role外， 现代Web应用常用的高级角色还包括：\n复合组件角色：\n1 2 3 4 5 6 7 \u0026lt;div role=\u0026#34;tree\u0026#34; aria-label=\u0026#34;文件浏览器\u0026#34;\u0026gt; \u0026lt;div role=\u0026#34;treeitem\u0026#34; aria-expanded=\u0026#34;true\u0026#34;\u0026gt;文档 \u0026lt;div role=\u0026#34;group\u0026#34;\u0026gt; \u0026lt;div role=\u0026#34;treeitem\u0026#34;\u0026gt;工作文档.docx\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 实时通信角色：\n1 2 3 \u0026lt;div role=\u0026#34;feed\u0026#34; aria-busy=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;article role=\u0026#34;article\u0026#34; aria-posinset=\u0026#34;1\u0026#34; aria-setsize=\u0026#34;10\u0026#34;\u0026gt;...\u0026lt;/article\u0026gt; \u0026lt;/div\u0026gt; 拖放操作角色：\n1 2 \u0026lt;div role=\u0026#34;draggable\u0026#34; aria-grabbed=\u0026#34;false\u0026#34;\u0026gt;可拖动项\u0026lt;/div\u0026gt; \u0026lt;div role=\u0026#34;droppable\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ARIA在 AI 驱动测试中的核心作用 语义理解增强 AI 测试系统通过ARIA角色建立的语义网络，能更准确地理解UI功能：\n1 2 3 4 5 6 7 graph TD A[原始DOM] --\u0026gt; B(视觉特征分析) A --\u0026gt; C(ARIA角色解析) C --\u0026gt; D[语义理解层] B --\u0026gt; D D --\u0026gt; E[组件功能分类] D --\u0026gt; F[操作意图推断] 典型应用场景：\n自动识别未标注的表单必填字段（通过aria-required） 发现动态内容更新的优先级（通过aria-live的polite/assertive） 识别复合组件的交互边界（如role=\u0026quot;dialog\u0026quot;的模态范围） 测试用例智能生成 基于ARIA的AI测试生成流程：\n角色图谱构建：\n1 2 3 4 5 6 7 def build_role_graph(page): graph = {} for element in page.query_selector_all(\u0026#39;[role]\u0026#39;): role = element.get_attribute(\u0026#39;role\u0026#39;) related = get_related_aria_attributes(element) graph[element] = {\u0026#39;role\u0026#39;: role, \u0026#39;attributes\u0026#39;: related} return graph 测试策略匹配：\n按钮类角色(button, switch) → 点击操作序列 输入类角色(textbox, spinbutton) → 输入验证测试 状态类角色(progressbar, timer) → 动态监控测试 边缘用例推导：\n当检测到role=\u0026quot;combobox\u0026quot;但缺少aria-controls时 发现role=\u0026quot;tablist\u0026quot;中子项未正确设置aria-selected 2.3 自愈测试维护 AI 系统利用ARIA实现的测试自愈机制：\n1 2 3 4 5 6 7 sequenceDiagram Test Case-\u0026gt;\u0026gt;+AI Engine: 定位失败(旧选择器) AI Engine-\u0026gt;\u0026gt;+DOM: 查询同角色元素 DOM--\u0026gt;\u0026gt;-AI Engine: 返回候选元素 AI Engine-\u0026gt;\u0026gt;+ARIA Analyzer: 验证名称/状态 ARIA Analyzer--\u0026gt;\u0026gt;-AI Engine: 最佳匹配结果 AI Engine-\u0026gt;\u0026gt;Test Case: 更新定位器 效果预期：\n选择器维护工作量减少 相比传统方法，降低误报率 跨平台测试一致性提升 ARIA与计算机视觉测试的协同 3.1 多模态测试融合 现代AI测试平台结合ARIA与CV的优势：\n检测维度 ARIA提供信息 CV补充信息 元素功能 明确角色定义 视觉样式验证 交互状态 aria-pressed等属性 实际渲染状态 层级关系 aria-owns等属性 空间位置关系 动态变化 aria-live区域 像素级变化检测 协同工作流示例：\n1 2 3 4 5 6 7 8 9 def validate_accessible_button(element): # ARIA验证 assert element.get_attribute(\u0026#39;role\u0026#39;) == \u0026#39;button\u0026#39; assert element.get_attribute(\u0026#39;aria-label\u0026#39;) is not None # CV验证 screenshot = element.screenshot() cv_result = analyze_button_visuals(screenshot) assert cv_result[\u0026#39;contrast_ratio\u0026#39;] \u0026gt;= 4.5 # WCAG AA标准 无障碍智能审计 AI驱动的ARIA审计系统架构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 [页面爬取模块] ↓ [ARIA属性提取器] ↓ [规则引擎] ├── WCAG 2.1规则集 ├── 自定义业务规则 └── 机器学习异常检测 ↓ [修复建议生成] ├── 自动修复方案 ├── 设计模式推荐 └── 代码补全提示 AI自动化测试应用场景 大语言模型(LLM)集成 ARIA可为LLM提供的结构化上下文：\n1 2 3 4 5 6 7 8 9 10 11 给定以下ARIA上下文： - 当前焦点元素: role=\u0026#34;combobox\u0026#34;, aria-expanded=\u0026#34;false\u0026#34; - 相关元素: * role=\u0026#34;listbox\u0026#34; (hidden) * role=\u0026#34;option\u0026#34; x3 (hidden) LLM生成的测试操作序列： 1. 触发combobox的展开操作 2. 验证listbox可见性变为true 3. 获取选项列表并选择第二项 4. 验证combobox的aria-activedescendant更新 无脚本测试自动化 基于ARIA和MCP结合，实现零代码测试：\n录制阶段：\n监听所有交互事件的ARIA角色变化 构建操作-状态转换图 回放阶段：\n1 2 3 4 5 6 7 8 def replay_by_aria(flow): for step in flow: target = find_element_by_role_state( step[\u0026#39;role\u0026#39;], step[\u0026#39;attributes\u0026#39;] ) execute_action(target, step[\u0026#39;action\u0026#39;]) validate_aria_states(step[\u0026#39;expected_states\u0026#39;]) 跨设备测试适配 ARIA角色在不同设备上的映射策略：\n桌面端角色 移动端等效模式 AI处理策略 tablist 底部导航栏 基于aria-orientation自动适配 tooltip 长按提示 交互超时自动调整 slider 触摸滑块 根据屏幕尺寸优化步长 发展方向 ARIA与Testing AI的深度结合： 角色驱动的自主探索式测试 基于角色相似性的迁移学习 和其他新测试技术整合： 1 2 3 4 graph LR A[ARIA语义] --\u0026gt; B[VR/AR测试] A --\u0026gt; C[语音交互测试] A --\u0026gt; D[物联网界面测试] 标准化演进： 正在制定的ARIA 2.0将增加：\n更细粒度的状态描述 增强的AI辅助属性 三维界面支持 结语 ARIA标准正在成为智能测试自动化的关键基础设施，其提供的丰富语义层使得AI系统能像人类一样理解Web应用的交互逻辑。随着W3C对标准的持续完善和测试工具链的进化，基于ARIA的AI驱动测试必将成为Web自动化测试领域的核心支柱。\nW3C ARIA Roles及其在Playwright自动化测试中的应用 作为自动化测试工程师，理解并正确应用W3C标准中的ARIA（Accessible Rich Internet Applications）Roles对于构建可访问的Web应用和编写可靠的自动化测试脚本至关重要。本文将详细介绍ARIA Roles的核心概念、分类、最佳实践，并重点阐述如何在Playwright测试框架中有效利用这些角色进行元素定位和验证。\n一、ARIA Roles概述 1.1 什么是ARIA Roles ARIA Roles是W3C WAI-ARIA规范中定义的一组属性，用于描述Web元素的功能和目的，帮助辅助技术（如屏幕阅读器）更准确地理解和传达页面内容。ARIA Roles通过role属性添加到HTML元素中，例如\u0026lt;div role=\u0026quot;button\u0026quot;\u0026gt;表示该div元素应被视为按钮。\n1.2 ARIA Roles的重要性 在Web自动化测试中，ARIA Roles提供了以下优势：\n增强元素语义：为自定义控件或非标准HTML元素提供明确的语义 提高测试可靠性：相比脆弱的CSS选择器或XPath，基于角色的定位更稳定 支持无障碍测试：验证应用是否符合无障碍标准(WCAG) 跨浏览器一致性：ARIA Roles在不同浏览器中表现一致，减少测试差异 二、ARIA Roles分类及常见角色 2.1 ARIA Roles主要类别 根据W3C规范，ARIA Roles可分为以下几大类：\nWidget Roles：描述交互式UI组件\nbutton：可点击的按钮 checkbox：复选框 radio：单选按钮 textbox：文本输入框 combobox：下拉组合框 slider：滑块控件 Document Structure Roles：描述页面内容结构\nheading：标题(h1-h6的替代) list/listitem：列表和列表项 table/row/cell：表格结构 img：图像 Landmark Roles：标识页面主要区域\nbanner：页眉 navigation：导航区域 main：主要内容 search：搜索区域 contentinfo：页脚信息 Live Region Roles：动态内容更新区域\nalert：重要且需立即通知的信息 status：操作状态反馈 timer：计时器或计数器 2.2 常用ARIA Roles示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!-- 按钮角色 --\u0026gt; \u0026lt;div role=\u0026#34;button\u0026#34; tabindex=\u0026#34;0\u0026#34; aria-pressed=\u0026#34;false\u0026#34;\u0026gt;自定义按钮\u0026lt;/div\u0026gt; \u0026lt;!-- 导航区域 --\u0026gt; \u0026lt;nav role=\u0026#34;navigation\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;首页\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;!-- 警告信息 --\u0026gt; \u0026lt;div role=\u0026#34;alert\u0026#34; aria-live=\u0026#34;assertive\u0026#34;\u0026gt; 您的操作已成功保存 \u0026lt;/div\u0026gt; \u0026lt;!-- 进度条 --\u0026gt; \u0026lt;div role=\u0026#34;progressbar\u0026#34; aria-valuenow=\u0026#34;75\u0026#34; aria-valuemin=\u0026#34;0\u0026#34; aria-valuemax=\u0026#34;100\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 三、Playwright中的ARIA应用 3.1 基于ARIA Roles的元素定位 Playwright提供了专门的getByRole()定位器方法，这是使用ARIA Roles进行元素定位的最佳方式。相比传统的CSS或XPath选择器，基于角色的定位更加稳定且语义化明确。\n基本语法：\n1 await page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;提交\u0026#39; }).click(); 常见角色定位示例：\n1 2 3 4 5 6 7 8 9 10 11 // 定位名为\u0026#34;搜索\u0026#34;的按钮 await page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;搜索\u0026#39; }).click(); // 定位复选框并勾选 await page.getByRole(\u0026#39;checkbox\u0026#39;, { name: \u0026#39;同意条款\u0026#39; }).check(); // 定位文本输入框并填写内容 await page.getByRole(\u0026#39;textbox\u0026#39;, { name: \u0026#39;用户名\u0026#39; }).fill(\u0026#39;testuser\u0026#39;); // 定位下拉选择框并选择选项 await page.getByRole(\u0026#39;combobox\u0026#39;, { name: \u0026#39;国家\u0026#39; }).selectOption(\u0026#39;中国\u0026#39;); 3.2 角色定位器的选项参数 getByRole()方法支持多种选项参数，可以更精确地定位元素：\n1 2 3 4 5 6 7 8 9 10 await page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;提交\u0026#39;, // 可访问名称 pressed: false, // 按钮状态(是否按下) expanded: true, // 是否展开(用于菜单等) disabled: false, // 是否禁用 checked: false, // 是否选中(复选框/单选按钮) selected: false, // 是否被选择(标签页等) includeHidden: false, // 是否包含隐藏元素 exact: true // 名称是否精确匹配 }); 3.3 验证ARIA属性和状态 Playwright不仅可以定位元素，还可以验证ARIA属性和状态：\n1 2 3 4 5 6 7 8 9 10 11 12 // 验证按钮是否禁用 await expect(page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;提交\u0026#39; })).toBeDisabled(); // 验证复选框是否选中 await expect(page.getByRole(\u0026#39;checkbox\u0026#39;, { name: \u0026#39;记住我\u0026#39; })).toBeChecked(); // 验证元素是否可见 await expect(page.getByRole(\u0026#39;alert\u0026#39;)).toBeVisible(); // 验证元素的ARIA属性值 const button = page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;展开\u0026#39; }); await expect(button).toHaveAttribute(\u0026#39;aria-expanded\u0026#39;, \u0026#39;false\u0026#39;); 四、Playwright的ARIA快照测试 Playwright提供了强大的ARIA快照功能，可以捕获和验证页面的无障碍树结构。\n4.1 ARIA快照基础 ARIA快照是页面无障碍树的YAML表示，包含元素的角色、名称、状态和层级关系：\n1 2 3 4 5 - banner: - heading \u0026#34;欢迎页面\u0026#34; [level=1] - main: - button \u0026#34;提交\u0026#34; - textbox \u0026#34;用户名\u0026#34; [placeholder=\u0026#34;请输入用户名\u0026#34;] 4.2 快照匹配断言 使用toMatchAriaSnapshot()进行快照验证：\n1 2 3 4 await expect(page.locator(\u0026#39;body\u0026#39;)).toMatchAriaSnapshot(` - heading \u0026#34;欢迎页面\u0026#34; [level=1] - button \u0026#34;提交\u0026#34; `); 4.3 部分匹配和正则表达式 快照支持灵活的部分匹配：\n1 2 3 4 5 6 7 8 9 // 只匹配角色不匹配名称 await expect(page.locator(\u0026#39;dialog\u0026#39;)).toMatchAriaSnapshot(` - dialog `); // 使用正则表达式匹配动态文本 await expect(page.locator(\u0026#39;body\u0026#39;)).toMatchAriaSnapshot(` - heading /订单 \\d+/ `); 4.4 生成和更新快照 1 2 # 使用--update-snapshots标志更新快照 npx playwright test --update-snapshots 或以编程方式生成：\n1 2 const snapshot = await page.locator(\u0026#39;#main\u0026#39;).ariaSnapshot(); console.log(snapshot); 五、ARIA测试最佳实践 5.1 角色使用原则 优先使用原生HTML元素：如\u0026lt;button\u0026gt;而非\u0026lt;div role=\u0026quot;button\u0026quot;\u0026gt; 避免冗余角色：如\u0026lt;nav role=\u0026quot;navigation\u0026quot;\u0026gt;是多余的，因为\u0026lt;nav\u0026gt;已隐含该角色 正确组合角色和属性：如role=\u0026quot;checkbox\u0026quot;应配合aria-checked使用 5.2 Playwright测试建议 优先使用ARIA定位器：比CSS/XPath更稳定可靠 结合可访问名称：使用name选项提高定位准确性 验证动态ARIA状态：如aria-expanded、aria-selected等 定期检查ARIA快照：确保页面结构符合无障碍标准 测试键盘导航：配合page.keyboard测试可访问性 5.3 常见问题解决 元素不可见：添加includeHidden: true或检查aria-hidden属性 名称不匹配：使用exact: false或正则表达式 动态内容：使用await expect().toHaveAttribute()等待状态变化 自定义控件：确保添加适当的ARIA角色和属性 六、ARIA在复杂组件中的应用 6.1 导航菜单测试 1 2 3 4 5 6 7 8 9 10 11 12 13 // 展开菜单 await page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;菜单\u0026#39; }).click(); // 验证菜单项 await expect(page.getByRole(\u0026#39;menu\u0026#39;)).toMatchAriaSnapshot(` - menu: - menuitem \u0026#34;首页\u0026#34; - menuitem \u0026#34;产品\u0026#34; - menuitem \u0026#34;关于我们\u0026#34; `); // 选择菜单项 await page.getByRole(\u0026#39;menuitem\u0026#39;, { name: \u0026#39;产品\u0026#39; }).click(); 6.2 标签页(Tabs)测试 1 2 3 4 5 6 7 8 9 10 11 12 // 验证标签页结构 await expect(page.locator(\u0026#39;.tabs-container\u0026#39;)).toMatchAriaSnapshot(` - tablist: - tab \u0026#34;基本信息\u0026#34; [selected=true] - tab \u0026#34;高级设置\u0026#34; - tabpanel: - textbox \u0026#34;用户名\u0026#34; `); // 切换标签页 await page.getByRole(\u0026#39;tab\u0026#39;, { name: \u0026#39;高级设置\u0026#39; }).click(); await expect(page.getByRole(\u0026#39;tab\u0026#39;, { name: \u0026#39;高级设置\u0026#39; })).toHaveAttribute(\u0026#39;aria-selected\u0026#39;, \u0026#39;true\u0026#39;); 6.3 模态对话框测试 1 2 3 4 5 6 7 8 9 10 11 12 13 // 打开对话框 await page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;删除\u0026#39; }).click(); // 验证对话框 await expect(page.getByRole(\u0026#39;dialog\u0026#39;)).toMatchAriaSnapshot(` - dialog \u0026#34;确认删除\u0026#34;: - heading \u0026#34;确认删除\u0026#34; [level=2] - button \u0026#34;取消\u0026#34; - button \u0026#34;确认\u0026#34; [disabled=false] `); // 操作对话框 await page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;确认\u0026#39; }).click(); 七、总结 作为自动化测试工程师，掌握W3C ARIA Roles并在Playwright测试中有效应用可以带来多重好处：\n提高测试稳定性：基于语义角色的定位比基于实现细节的定位更可靠 增强可访问性：确保应用符合WCAG标准，服务更广泛的用户群体 简化测试维护：当UI样式变化时，基于角色的测试通常不需要更新 支持跨平台测试：ARIA Roles在不同浏览器和设备上表现一致 通过结合Playwright的ARIA定位器、状态验证和快照测试功能，您可以构建健壮、可维护且关注可访问性的自动化测试套件。随着Web应用越来越复杂，ARIA Roles在自动化测试中的重要性将持续增长，成为现代Web测试工程师必备的核心技能之一。\n五、实施建议与挑战 5.1 采用路线图 基础阶段：\n在现有测试中逐步引入getByRole定位器 添加ARIA快照比对 进阶阶段：\n建立角色驱动的测试用例库 开发ARIA合规性监控 AI集成阶段：\n训练专用的角色分类模型 实现测试脚本自动生成 5.2 常见挑战解决方案 挑战1：动态角色分配\n解决方案：结合MutationObserver监听role变化 1 2 3 4 5 6 7 new MutationObserver((mutations) =\u0026gt; { mutations.forEach(m =\u0026gt; { if (m.attributeName === \u0026#39;role\u0026#39;) { updateAIElementRegistry(m.target); } }); }).observe(document, {attributes: true}); 挑战2：角色滥用检测\n解决方案：模式识别算法 1 2 3 4 5 def detect_role_misuse(element): valid_roles = get_valid_roles_for_tag(element.tag_name) current_role = element.get_attribute(\u0026#39;role\u0026#39;) if current_role not in valid_roles: suggest_native_element(element.tag_name, current_role) 挑战3：跨框架一致性\n解决方案：中间抽象层 1 2 3 4 [React/Vue/Angular组件] → [ARIA适配层] → [标准化角色树] → [AI测试引擎] ","date":"2025-04-27T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/084-aria%E4%BB%8B%E7%BB%8D/-20250417_hu_7d27678dc368538b.png","permalink":"https://chengxiaqiucao.github.io/post/084-aria%E4%BB%8B%E7%BB%8D/","title":"W3C ARIA Roles标准及其在AI驱动自动化测试中的作用"},{"content":" 本文根据知名测试博客 https://testguild.com/ 的最新博文翻译整理，谈到了在测试团队中系统实施、推进 AI 测试的路线图，很有参考价值，现分享给大家\nAI 测试自动化不再是可选项 在当今的软件测试领域，人工智能（AI）已不再仅仅是一种选择，而是一种重要的战略优势 。AI 驱动的测试工具能够将从测试用例生成到测试执行的各个环节实现自动化，从而使您的团队能够专注于交付更高质量的软件版本 。\nBlinq.io 首席执行官 Tal Barmeir 曾指出：“生成式 AI 的作用在于帮助我们真正解决大量测试需求积压且覆盖范围非常有限的问题——这是我们在所有行业中都普遍看到的现象。”\nAI 驱动的测试工具能自动化从测试用例创建到执行和维护的整个流程，将助力测试团队：\n将测试创建时间缩短高达 80% 将测试维护成本降低 40-60% 通过更快的发布周期加速产品上市时间 提高跨浏览器、设备和环境的测试覆盖率 释放宝贵的工程资源用于创新 本指南提供了一种结构化的方法来实施 AI 测试，旨在带来即时效益和长期的转型。\n阶段一（第 1-15 天）：制定您的 AI 测试策略 在深入研究具体的工具之前，首先需要明确您希望如何应用 AI ：\n辅助式 AI：增强以人工为主导的测试流程。 自主式 AI：由 AI 完全驱动的测试自动化，并有人工监督。 “大多数组织从辅助式 AI 开始。但很快他们就会意识到其价值有限，并尝试转向完全由 AI 主导。这种转变需要不同的工具、结构和思维模式。”\n对于 测试团队决策Leader 而言，关键的战略决策包括：\n自动化范围：您的团队是自动化现有测试用例，还是允许 AI 全权负责测试脚本的创建、执行和维护？\n集成要求：AI 测试将如何与您现有的 CI/CD 管道和开发工作流程集成？\n成功指标：将使用哪些 KPI 来衡量成功？（如测试覆盖率、执行时间、缺陷检测等）\n风险评估：哪些应用程序或功能最适合作为 AI 测试的初始实施对象？\n行动建议：在进行工具评估之前，请务必明确 AI 测试愿景、范围和成功标准 。\n阶段二（第 16-30 天）：重新定义 QA 角色和测试输入 AI 测试自动化并不会消除现有角色，而是会对其进行转型 。\n传统角色 AI 增强角色 主要职责 手工测试人员 提示词工程师 创建有效的测试提示，审查 AI 生成的测试 自动化工程师 AI 测试主管 监督 AI 测试的生成、执行和维护 QA 经理 AI 测试战略家 定义 AI 测试策略，衡量投资回报率，优化流程 “人们常常认为 AI 意味着失业。这并非事实。它真正做的是重新利用测试人员——手动测试人员成为提示工程师，自动化工程师成为 AI 工作的监督者。”\n扩展测试输入源 AI 测试平台能够从多种输入生成全面的测试用例 ，包括：\nJira 工单和用户故事 应用程序使用屏幕录像 自然语言需求 API 规范和文档 现有手动测试用例 这种灵活性使得 AI 测试无需严格遵循 BDD 框架或特定的测试用例格式，从而使各种成熟度级别的团队都能够使用 AI 测试 。\n阶段三（第 31-45 天）：评估 AI 测试工具 选择正确的 AI 测试工具，必须使其与您的基础设施、团队技能和长期愿景保持一致 。\n企业级 AI 测试平台的基本功能 开源测试代码生成：以标准框架（如 Playwright、Selenium 等）生成可维护的代码。 自愈能力：无需人工干预即可自动适应用户界面（UI）变化。 全面测试支持：涵盖功能、视觉、性能和安全测试。 企业集成：与您的 CI/CD 管道、测试管理和缺陷跟踪系统协同工作。 跨平台测试：支持 Web、移动、API 和企业应用程序（如 Salesforce、SAP 等）。 视觉测试：AI 驱动的视觉比较和异常检测。 不稳定测试管理：自动识别和解决不一致的测试。 “即使您停止使用某个供应商，您仍然拥有一个可以维护的代码项目。没有黑盒，没有供应商锁定。”\n决策框架：根据您的具体需求、现有基础设施和团队能力评估工具 。优先选择那些能够生成标准、可维护测试代码而非专有格式的平台 。\n阶段四（第 46-60 天）：为新的 AI 增强测试角色进行培训 测试自动化中引入 AI，将带来新的 AI 功能和职责，从而提升 QA 团队的角色 。\nAI 测试时代的关键技能 提示工程：创建有效的测试提示，以生成全面的测试覆盖。 AI 测试审查：评估和完善 AI 生成的测试脚本。 测试维护管理：监督自愈能力和测试稳定性。 测试优先级排序：确定每次发布中哪些测试能带来最高价值。 探索性测试：将人类创造力集中于边缘情况和复杂场景。 “旧技能是脚本编写和调试。新技能呢？编写提示、审查 AI 建议以及大规模管理代码。”\nQA 团队的培训资源： 关于 AI 测试概念和提示工程的内部研讨会。 供应商提供的特定 AI 测试平台培训。 在实际应用程序测试场景中的动手实践。 手动和自动化测试人员之间的交叉培训。 领导力重点：鼓励实验并创造一个学习环境，让团队可以通过实际应用发展 AI 测试专业知识 。\n阶段五（第 61-75 天）：试点并扩展 AI 测试覆盖范围 启动一个重点明确的试点项目，使用 10-20 个测试场景，以实现快速、可衡量的影响，并建立对 AI 测试能力的信心 。\n理想的试点项目特征： 具有稳定 UI 的中等复杂性应用程序。 用于比较的现有手动测试用例。 定期发布周期以展示 CI/CD 集成。 混合了回归、功能和视觉测试需求。 利益相关者乐于创新和流程变革。 实施清单： 选择试点应用程序并定义测试范围。 配置 AI 测试工具并与 CI/CD 集成。 创建初始测试提示并生成基线测试。 在多个环境中执行测试。 根据传统测试方法衡量结果。 记录经验教训和优化机会。 此阶段非常适合扩展跨浏览器、设备和语言的测试覆盖范围——利用 AI 模型的多语言能力高效测试国际应用程序 。\n阶段六（第 76-90 天）：衡量 KPI 并优化 跟踪关键绩效指标（KPIs），量化 AI 测试实施的影响并发现优化机会 。\n关键 AI 测试指标 ： 发布时间：整体测试周期时间的缩短。 测试覆盖率：功能和平台覆盖率的提高。 维护工作量：测试脚本维护时间的减少。 缺陷检测：缺陷识别率的提高。 资源利用率：QA 团队将重心转移到更高价值的活动。 “大多数领导者认为 AI 测试是为了削减成本。但最大的投资回报率实际上是更快的上市时间。”\n持续改进框架： 每周审查 AI 测试性能和准确性。 根据测试结果和遗漏场景完善提示。 将 AI 测试扩展到其他应用程序和测试类型。 记录最佳实践并在团队之间分享。 建立 AI 测试卓越中心。 这些见解将支持您的团队就测试覆盖率、发布准备情况和质量改进做出数据驱动的决策 。\n总结：您的 90 天 AI 测试实施路线图 阶段 时间线 重点 关键交付物 1 第 1-15 天 策略定义 AI 测试愿景、实施方法、成功指标 2 第 16-30 天 角色转型 更新的团队结构、技能要求、输入源 3 第 31-45 天 工具选择 AI 测试平台评估、选择标准、概念验证 4 第 46-60 天 团队培训 技能发展计划、培训资源、知识共享 5 第 61-75 天 试点实施 初始 AI 测试套件、与 CI/CD 集成、基线指标 6 第 76-90 天 衡量与优化 绩效分析、优化计划、扩展策略 QA 的未来：AI 驱动的测试领导力 借助正确的 AI 测试策略，您的 QA 组织不仅能跟上行业步伐，更将引领向更快、更可靠的软件交付转型 。您不仅仅是在自动化测试，更是在赋能团队，以增强和简化整个测试生命周期，以前所未有的速度交付更高质量的软件，同时降低风险和技术债务 。现在就拥抱 AI 测试，您将使您的组织处于质量工程的前沿，通过卓越的软件质量和加速创新创造可持续的竞争优势 。\n","date":"2025-04-26T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/083-ai%E6%B5%8B%E8%AF%95%E8%B7%AF%E7%BA%BF%E5%9B%BE/","title":"AI测试，测试团队的必由之路"},{"content":"去年流行的一个关于南京旅游网络梗：你一句春不晚，我就到了镇江南! 虽是揶揄，但作为古诗旧词中出现频率颇高的一个地方，三国时的京口、宋时之润州，长江要津，吴帝故都，镇江也确是一处赏玩胜地。\n镇江最有名的游玩处，莫过于“三山一渡”，三山都是5A景区，一渡也是4A，而且互相之间距离不远，很适合短途游玩。便排下一日行程，到此一游~\n金山 三山一渡，都位于镇江北面，所以坐高铁优先到镇江站。从北广场出站，先往金山。3公里左右，顺中山北路，共享单车15分钟左右可达。\n金山寺 金山景区最著名的就是金山寺了。是的，就是白蛇传里那个水漫金山的金山寺。而且真实历史上，金山寺还确实有个法海和尚。\n金山寺始建于东晋年间，香火绵延至今1700余年，是佛教禅宗四大名寺之一（另三座普陀寺、文殊寺、大明寺）。寺庙依山就势，各色建筑散布山上，形成独特的 “寺裹山”格局。金山寺还是佛教水陆大法会的源头，从梁武帝启建开始，历今1500多年了。\n金山寺的标志性建筑是寺中的慈寿塔，始建于南朝齐梁年间，后经多次重建。现存的八角七层塔是清朝光绪年间所建。\n天下第一泉 - 中泠泉 而除了金山寺外，景区中还有一眼号称“天下第一泉”的中泠泉，现在泉水石壁上这五字乃是清末状元（光绪年间）王仁堪在镇江知府任上所书。\n王仁堪在镇江任上三年，勤政爱民，民望甚佳，移任苏州知府不久，积劳成疾，英年早逝。此地还设有王仁堪祠以祭奠。\n芙蓉楼 而金山景区内，另一处穿越千年的名胜，还有芙蓉楼。便是王昌龄名诗中的这个芙蓉楼了\n1 2 3 4 5 6 芙蓉楼送辛渐 王昌龄 寒雨连江夜入吴，平明送客楚山孤。 洛阳亲友如相问，一片冰心在玉壶。 只是原芙蓉楼早已不存，现今芙蓉楼乃是1992年重建，匾额是江泽民总书记手书。\n湖光山色，双塔遥望，江风拂面，正是江南好时节~\n北固山 从金山风景区出来，顺长江路一路向西，4公里外，就是北固山景区。\n这里又是一处满满历史人文的名胜。三国故垒，更有历代文人墨客在此留下无数痕迹。\n古甘露寺 甘露寺，相传便是历史上“吴国太佛寺看新郎，刘皇叔洞房续佳偶”的发生地。刘备借荆州不还，周瑜献策让孙权以妹妹孙尚香招亲为名，诱刘备来镇江（其时镇江便是东吴都城）联姻，诸葛亮将计就计，弄假成真，也因此留下了“周郎妙计安天下，赔了夫人又折兵”这广为人知的谚语故事。\n苏东坡在游览此地后，也曾留下一首长诗《甘露寺》，以景抒怀，仰英雄而叹岁月和际遇无常。\n北固楼 而北固山之所以广为人知，离不开一首词：《永遇乐·京口北固亭怀古》\n1 2 3 4 5 6 7 8 9 10 11 12 永遇乐·京口北固亭怀古 辛弃疾 千古江山，英雄无觅，孙仲谋处。 舞榭歌台，风流总被，雨打风吹去。 斜阳草树，寻常巷陌，人道寄奴曾住。 想当年，金戈铁马，气吞万里如虎。 元嘉草草，封狼居胥，赢得仓皇北顾。 四十三年，望中犹记，烽火扬州路。 可堪回首，佛狸祠下，一片神鸦社鼓。 凭谁问：廉颇老矣，尚能饭否？ 其实辛弃疾当年游览北固山，作有两首词，另一首是 《南乡子·登京口北固亭有怀》\n1 2 3 4 5 6 7 8 9 10 南乡子·登京口北固亭有怀 辛弃疾 何处望神州？满眼风光北固楼。 千古兴亡多少事？ 悠悠。不尽长江滚滚流。 年少万兜鍪，坐断东南战未休。 天下英雄谁敌手？ 曹刘。生子当如孙仲谋。 毛主席老人家，很欣赏这两首词，所以北固楼中，还陈列有他老人家手书的这两阙词。\n北固楼上，看大江东去，遥望焦山，如何不兴无限江山之叹！\n多景楼 北固楼后旁，曾有名楼“多景楼”，位列古代长江三大名楼（和岳阳楼、黄鹤楼齐名）。曾有米芾手书 “天下江山第一楼”，历代文人如苏轼、曾巩、陆游、陈亮等都曾在此留下诗篇！\n六朝何事，只成门户私计！ 据说毛主席晚年读到此句，恸哭不止~~ 便是陈亮的《登多景楼》\n景区内除了山上的几处著名景点，山下还有太史慈、鲁肃的墓地，奉旨填词的柳永也长眠于此，只是墓地具体方位已失考！时间关系，未一一探访！\n焦山 北固山再往东4公里余，可到焦山景区。但焦山其实是长江江心一座孤山，要从景区大门轮渡过来。\n定慧寺 焦山因东汉焦光隐居山中而得名。山中古寺定慧寺，也是千年宝刹。\n康熙南巡曾至此，现在的寺名也是康熙所定，沿用至今。\n景区地标万佛塔，久历沧桑，岿然俯瞰长江\n碑林 而焦山最为著名之处，被称为“书法名山”，在于这里的碑林，存有历朝古碑五百余方，八十多处摩崖石刻。更有镇山之宝，有“大字之祖”之称的六朝石刻 “瘗鹤铭”。唐时下半部被雷击，崩塌江中，直到清康熙年间，历三个月打捞才得残碑五块。\n此外，这里收集了大量名家墨宝，王羲之、颜真卿、米芾、黄庭坚、苏轼等在此都可看到，群贤毕至，可谓书法爱好者的圣地。 西津渡 西津渡位于镇江城西的云台山麓，北邻长江，曾是连接江南江北的重要渡口，与扬州的瓜洲古渡隔江相对。古时，人们便坐船往返扬州与镇江，所以王安石诗云：““京口瓜洲一水间”。但随着近代长江改道，目前西津渡已经距离江岸300多米，再无船可渡，游人如织。可古巷石塔，青石台阶，依然在述说历史源流和人间烟火。\n昭关石塔 昭关石塔是目前全国唯一还保存完好的元代过街石塔，是藏传佛教的标志性建筑。\n游览当天，还碰到藏族团队，到此参观，石塔下载歌载舞，一派升平。\n镇江博物馆 镇江博物馆便在西津渡里，每i到一个城市，必看的去处，怎可少了博物馆。\n和其他博物馆大多按年代动线不同，这里不同馆主要按藏品材质分类，馆藏算不得丰富，但也不乏精品\n自然也包括这件人气很高的清宫\u0026quot;芙蓉石花鸟纹盖瓶\u0026quot;\n和南博那件 “芙蓉石蟠螭耳盖炉”，堪称双壁\n青铜人面纹錞于\n象牙八仙上寿臂搁\n玛瑙小鸡\n博物馆外，对面是广肇公所，由在镇江的粤商所建，孙中山曾在此地演讲，宣传革命\n一眼看千年，从这里路面下土质的不同分层，可以直观感受到这里不同朝代的历史留痕\n逛累了，去景区里的网红餐厅周家二小姐的菜打卡，满足味蕾后，暮色四合，华灯初上，便在暮春温润的晚风中，为这趟访古之旅画上句点罢。\n","date":"2025-04-24T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/082-%E9%95%87%E6%B1%9F/IMG_5999_hu_b7e5468061ede9c5.jpeg","permalink":"https://chengxiaqiucao.github.io/post/082-%E9%95%87%E6%B1%9F/","title":"一句春不晚，所到处，原是京口"},{"content":"在人工智能（AI）和大型语言模型（LLM）浪潮席卷全球的今天，软件测试领域正迎来一场深刻的变革。传统的测试方法正在与前沿的AI技术相融合，而**提示词工程（Prompt Engineering）**正是驾驭这场变革的核心技能。本指南将深入探讨提示词工程的理论、实践与高级技巧，并提供一系列面向软件测试岗位的具体案例，旨在帮助测试工程师和团队有效利用AI提升测试效率、覆盖率和深度。\n第一章：初识提示词工程——与AI高效对话的艺术 1.1 什么是提示词工程？ 提示词工程是一门旨在设计、构建和优化输入文本（即“提示词”）的学科，其目的是引导大型语言模型（LLM）如GPT-4、Claude等，生成我们期望的、高质量且相关的输出。如果说LLM是一个强大的、拥有海量知识的引擎，那么提示词就是控制这个引擎方向盘和油门。\n对于软件测试而言，提示词工程不仅仅是“向AI提问”，它是一种战略性的沟通方式。通过精心设计的提示词，测试人员可以驱使AI完成一系列复杂的测试任务，例如：\n生成测试用例：基于需求文档、用户故事或代码片段，自动创建功能、边界、异常等各类测试用例。 创建测试数据：生成多样化、符合特定格式和业务规则的测试数据。 编写自动化脚本：辅助编写或直接生成Selenium、Cypress、Playwright等框架的自动化测试脚本。 分析测试结果：对大量的测试日志和报告进行摘要、分类和根本原因分析。 模拟用户行为：创建符合特定用户画像的交互场景，用于用户验收测试（UAT）或探索性测试。 掌握提示词工程，意味着测试工程师可以将繁琐、重复性的工作交由AI处理，从而将更多精力投入到更具创造性和战略性的测试活动中。\n1.2 核心理念：清晰、具体、有上下文 成功的提示词工程遵循一个核心原则：Garbage In, Garbage Out (GIGO)。你提供给AI的信息质量直接决定了其输出的质量。因此，一个优秀的提示词通常具备以下特点：\n清晰明确 (Clear \u0026amp; Specific)：避免使用模糊、笼统的语言。直接告诉AI你想要什么。 提供上下文 (Contextual)：为AI提供充足的背景信息，如被测功能描述、相关代码、用户画像、业务规则等。 指定角色 (Role Assignment)：让AI扮演一个特定的角色，例如“你是一位资深的软件测试专家”，这有助于模型以更专业的视角和口吻进行回应。 明确输出格式 (Format Specification)：清晰地定义你希望得到的输出格式，如JSON、CSV、Markdown表格、项目列表等。 迭代优化 (Iterative Refinement)：很少有提示词能一次就达到完美。准备好根据AI的反馈进行多次尝试和调整。 第二章：提示词工程术语宝典 为了更好地理解和应用提示词工程，熟悉以下关键术语至关重要。\n术语 (Term) 中文解释 说明 Prompt 提示词 用户提供给LLM的输入文本，用于引导其生成回应。 Zero-shot Prompting 零样本提示 在不提供任何示例的情况下，直接要求LLM完成任务。适用于模型已经熟练掌握的任务。 Few-shot Prompting 少样本提示 在提示词中提供少量（通常是1-5个）示例，向LLM展示期望的输入输出格式和风格。 Chain-of-Thought (CoT) Prompting 思维链提示 指导LLM在给出最终答案前，先进行一步一步的逻辑推理。通过加入“让我们一步一步地思考”等短语来触发。 Role Prompting / Persona 角色提示/人设 为LLM设定一个特定的角色或身份（如“资深安全测试工程师”），以影响其回应的风格、口吻和专业深度。 Context Window 上下文窗口 LLM在一次对话中能够记住和处理的信息量（以token计算）。超出此窗口的信息将被遗忘。 Token 令牌 LLM处理文本的基本单位，可以是一个单词、一个字符或一个词根。 Hallucination 幻觉 LLM生成看似合理但实际上是虚假或与事实不符的信息的现象。 Temperature 温度参数 一个控制输出随机性的参数（通常在0到1之间）。较低的温度使输出更具确定性和一致性，较高的温度则更具创造性和多样性。 Self-Consistency 自我一致性 一种高级技术，通过多次生成（使用较高的温度）并对结果进行“投票”，选出最一致的答案，以提高复杂推理任务的准确性。 ReAct (Reasoning and Acting) 推理与行动 一种高级框架，让LLM不仅能进行推理，还能执行某些“行动”（如调用外部API、执行代码），并将行动结果融入下一步的推理中。 Delimiter 分隔符 使用特殊字符或标签（如```, ###, \u0026lt;tag\u0026gt;）来清晰地分隔提示词的不同部分（如指令、上下文、示例）。 第三章：软件测试中的提示词工程实践 本章将通过具体的案例，展示如何在软件测试的各个阶段应用提示词工程。\n3.1 案例一：基于用户故事生成测试用例 (功能测试) 假设我们有一个电商平台的用户故事：“作为一个已登录用户，我希望能够将商品添加到购物车中，以便稍后一次性结算。”\n一个糟糕的提示词 👎:\n为添加购物车功能写测试用例。\n这个提示词过于模糊，没有提供任何上下文，AI可能会生成一些非常通用的、价值不高的用例。\n一个优秀的提示词 (采用Few-shot和角色提示) 👍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 指令 你是一位经验丰富的电商软件测试专家。请根据以下用户故事和业务规则，为“添加商品到购物车”功能生成一套全面的功能测试用例。 # 角色 - 你非常注重细节，能够考虑到各种边界情况和异常场景。 - 你生成的测试用例应包含：用例ID、测试标题、前置条件、测试步骤、预期结果和用例类型（正面/负面）。 - 输出格式应为Markdown表格。 # 上下文：用户故事 “作为一个已登录用户，我希望能够将商品添加到购物车中，以便稍后一次性结算。” # 上下文：业务规则 1. 用户必须是登录状态才能添加商品。 2. 购物车最多可以容纳50件不同的商品。 3. 单个商品的最大购买数量为99。 4. 已下架或库存为0的商品不能添加到购物车。 5. 添加成功后，页面右上角的购物车图标应实时更新商品数量。 # 示例 (Few-shot) 以下是一个参考示例： | 用例ID | 测试标题 | 前置条件 | 测试步骤 | 预期结果 | 用例类型 | | :--- | :--- | :--- | :--- | :--- | :--- | | TC-CART-001 | 验证登录用户可以成功添加一件商品到购物车 | 用户已登录；购物车为空 | 1. 浏览到一个有库存的商品详情页。\u0026lt;br\u0026gt;2. 点击“添加到购物车”按钮。 | 1. 页面提示“商品已成功添加到购物车”。\u0026lt;br\u0026gt;2. 购物车图标数量更新为1。 | 正面 | # 任务 现在，请基于以上信息，为该功能生成至少10个详细的测试用例，覆盖正面、负面和边界场景。 AI可能的输出:\nAI将会遵循指令，以指定的Markdown表格格式，生成包括验证未登录用户、添加商品达到上限、添加无库存商品、验证数量输入边界值（0, 1, 99, 100）等一系列高质量的测试用例。\n3.2 案例二：生成特定格式的测试数据 (数据驱动测试) 在进行数据驱动测试时，我们常常需要大量符合特定格式和规则的数据。\n场景：测试一个用户注册表单，该表单对用户名、密码和邮箱格式有特定要求。\n一个优秀的提示词 (采用指令和格式规范) 👍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 角色 你是一个测试数据生成器。 # 任务 请为用户注册功能生成20组测试数据，并以CSV格式输出。 # 数据要求 数据应包含三列：`username`, `password`, `email`。 # 列定义和规则 1. `username`: * 必须是6-15个字符。 * 只能包含小写字母和数字。 * 请包含有效和无效的用户名（例如，过短、过长、包含特殊字符）。 2. `password`: * 必须是8-20个字符。 * 必须包含至少一个大写字母、一个小写字母、一个数字和一个特殊字符（!@#$%^\u0026amp;*）。 * 请包含符合规则的强密码和不符合规则的弱密码。 3. `email`: * 必须是有效的电子邮件格式。 * 请包含一些常见的邮箱提供商（如gmail.com, outlook.com, yahoo.com）以及一些格式无效的邮箱（例如，缺少@符号，域名无效）。 # 输出格式 请严格按照以下CSV格式输出，包含表头： ```csv username,password,email AI可能的输出: AI将生成一个CSV格式的文本块，包含20行数据，其中混合了有效的和刻意构造的无效数据，可以直接用于自动化测试脚本或手动测试。\n1 2 3 4 5 6 7 username,password,email validuser1,ValidPass1!,test.user1@gmail.com short,WeakPass1,test.user2@outlook.com toolongusername123,AnotherGoodP@ss,test.user3@yahoo.com invalid-user,Weak1,invalid-email user.123,StrongerP@ssword123,test.user4@gmail.com ... (and so on) 3.3 案例三：辅助编写自动化测试脚本 (测试自动化) 对于测试自动化工程师来说，AI可以成为一个强大的编程助手。\n场景：需要为前面提到的“添加购物车”功能编写一个使用Selenium和Python的自动化测试脚本。\n一个优秀的提示词 (采用思维链和代码生成) 👍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 角色 你是一名资深的自动化测试工程师，精通Python和Selenium WebDriver。 # 任务 请为“验证登录用户可以成功添加一件商品到购物车”这个测试场景，编写一个完整的、可执行的Python Selenium自动化测试脚本。 # 指令与思考过程 (Chain-of-Thought) 让我们一步一步地完成这个任务： 1. **设置环境**：导入必要的Selenium库，初始化WebDriver（请使用Chrome浏览器），并设置隐式等待。 2. **登录操作**：首先，编写一个函数`login(username, password)`，导航到登录页面，输入用户名和密码，然后点击登录按钮。请使用ID选择器定位元素。 3. **导航到商品页**：登录后，导航到一个具体的商品页面。假设商品页面的URL是 \u0026#34;[http://example.com/product/123](http://example.com/product/123)\u0026#34;。 4. **执行添加操作**：定位“添加到购物车”按钮（假设其ID为`add-to-cart-button`）并点击。 5. **断言验证**： * 添加一个显式等待，等待成功提示信息出现（假设其CSS选择器为`.success-message`）。 * 获取该提示信息的文本，并断言其内容为“商品已成功添加到购物车”。 * 获取购物车图标旁边的数量元素（假设其ID为`cart-item-count`）的文本，并断言其值为 \u0026#34;1\u0026#34;。 6. **清理**：最后，关闭浏览器`driver.quit()`。 7. **代码结构**：请将所有操作封装在一个主函数或测试类中，并添加注释来解释关键步骤。 # 请输出完整的Python代码。 AI可能的输出:\nAI会根据这个详细的、分步的指令，生成一个结构清晰、注释完整、包含所有必要操作和断言的Python Selenium脚本。这种方式远比“给我写个Selenium脚本”这样的简单请求要高效和准确得多。\n第四章：高级提示词工程技巧 当你掌握了基础后，可以运用更高级的技巧来应对复杂的测试挑战。\n4.1 思维链 (Chain-of-Thought) 的深化应用 对于需要复杂逻辑推理的任务，如根本原因分析 (Root Cause Analysis)，深化CoT的应用至关重要。\n场景：一个API测试失败，返回了500错误，你需要分析可能的原因。\n提示词:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 角色 你是一名顶级的站点可靠性工程师（SRE），正在诊断一个API故障。 # 上下文 - **API端点**: `/api/v1/users/{userId}/profile` - **问题**: 在高并发负载测试期间，该端点偶尔返回 HTTP 500 内部服务器错误。 - **日志片段**: ```log ERROR: Connection pool exhausted. Could not get a connection from the pool. ... Caused by: java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30000ms. # 任务 请使用“思维链”方法，一步一步地分析这个问题的潜在根本原因，并为每个原因提出具体的调查步骤和解决方案建议。请像专家一样思考，从多个层面（应用层、数据库层、配置层）进行分析。 **思考开始：** 1. **日志分析**: 日志明确指出了“Connection pool exhausted”（数据库连接池耗尽）。这是最直接的线索。 2. **为什么连接池会耗尽?** - **原因A: 连接未被释放。** 应用代码中是否存在某个逻辑分支，在查询数据库后没有正确关闭连接（`connection.close()`）？ - **原因B: 连接池太小。** `HikariCP`的`maximumPoolSize`配置是否对于当前的并发负载来说过低？ - **原因C: 查询本身过慢。** 是否存在慢查询，导致连接被长时间占用，在高并发下迅速耗尽了连接池？ - **原因D: 数据库性能瓶颈。** 数据库服务器本身是否达到了CPU、内存或IO的瓶颈，导致查询响应变慢，从而间接导致连接池耗尽？ 3. **如何调查?** - **针对原因A**: 审查处理`/api/v1/users/{userId}/profile`请求的所有代码路径，特别是异常处理块，确保`finally`语句中正确关闭了连接。 - **针对原因B**: 检查应用的配置文件（如`application.properties`或`yml`），查看`spring.datasource.hikari.maximum-pool-size`的值。监控连接池的实时使用情况。 - **针对原因C**: 开启数据库的慢查询日志，分析在问题发生时间点是否有慢查询记录。对该API涉及的SQL语句进行`EXPLAIN ANALYZE`。 - **针对原因D**: 检查数据库服务器的监控仪表盘（CPU使用率、内存、磁盘I/O、活跃连接数）。 4. **解决方案建议?** - ... # 输出 请根据以上的思维链，整理成一份正式的故障分析报告。 这种CoT提示词不仅引导AI得出结论，更重要的是强迫它展示一个结构化的、逻辑清晰的分析过程，这对于复杂的诊断任务非常有价值。\n4.2 自我一致性 (Self-Consistency) 用于探索性测试 在需要创造性和发散性思维的探索性测试中，可以利用Self-Consistency来生成更多样化的测试想法。\n场景：为一个新的“在线文档协作”功能设计探索性测试的思路。\n提示词:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 角色 你是一个极具创造力和破坏性的软件测试员，擅长找到用户意想不到的Bug。 # 任务 请为“在线文档实时协作”功能，生成5个不同的、创造性的探索性测试思路（charter）。我需要的是多样化的、非常规的想法。 # 指令 1. 我将多次运行此提示。 2. 请你思考并生成5个测试思路，专注于并发操作、网络延迟、数据冲突和非常规用户交互。 3. 请以项目列表的形式输出。 (你可以将模型的`temperature`参数调高，例如0.8，然后多次运行这个提示词) 运行1的可能输出:\n模拟断网重连: 两个用户同时编辑，其中一个用户突然断网，进行大量修改后再重连，观察数据如何合并。 疯狂光标移动: 多个用户在同一行疯狂地输入、删除、移动光标，测试渲染性能和同步的准确性。 \u0026hellip; 运行2的可能输出:\n权限动态变更: 当一个用户正在编辑时，管理员突然将其权限从“可编辑”降为“只读”，观察其客户端的行为。 混合富文本与纯文本: 一个用户粘贴复杂的富文本（带格式、图片），另一个用户同时在附近输入纯文本，检查格式是否错乱。 \u0026hellip; 通过多次生成并综合所有独特的想法，测试人员可以获得一个远比单次请求更丰富、更全面的探索性测试清单。\n第五章：总结与展望 提示词工程正迅速成为软件测试工程师的核心竞争力之一。它不是要取代测试人员的思考，而是要增强他们的能力，将他们从重复劳动中解放出来，去完成更需要智慧和洞察力的任务。\n成功的关键在于实践。从今天起，尝试将本文介绍的技巧应用到你的日常工作中。从小任务开始，比如用AI帮你润色缺陷报告，或者为你正在测试的功能头脑风暴一些边缘案例。随着你对模型“脾气”的了解加深，你将能够构建出越来越强大的提示词，真正实现与AI的高效协同，将软件测试的效率和质量提升到一个全新的高度。\n未来的软件测试，将是人类智慧与人工智能深度融合的时代，而提示词工程，正是开启这扇大门的钥匙。\n","date":"2025-04-20T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/080-%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B/","title":"提示词工程权威指南：赋能软件测试的艺术与科学"},{"content":"前言 随着AI大模型在软件测试领域的广泛应用，提示词工程（Prompt Engineering）已成为测试工程师提升效率的关键技能。通过精准的提示词设计，我们可快速生成测试用例、优化测试场景、生成自动化脚本、以至实现智能化的测试覆盖。\n那么如何更有效地在利用大模型时，让大模型更高效地协助我们得到期望的结果，好的提示词能让我们事半功倍。下文就总结下，对测试工程师而言，怎么编写出好的提示词框架\n拆分复杂需求，准确描述问题 AI大模型的效果高度依赖输入提示词的清晰度，也就是尽可能减少二义性。所以在输入提示词时，应尽可能将复杂任务拆解为具体需求，例如：\n场景化的描述：明确测试目标（如“生成登录功能的边界值测试用例”），而非模糊指令（如“帮我写测试用例”）。 约束条件：添加格式要求（如“以表格形式输出”）、优先级（如“仅包含高风险场景”）或技术限制（如“不涉及第三方接口”）。 示例引导：可以提供示例数据或模板，帮助模型理解期望的输出结构。 利用结构化框架，提升输出稳定性 通过定义结构化的提示词框架，可以约束模型行为，并减少随机性干扰：\n角色设定：指定模型扮演专业角色（如“你是一位资深测试专家，擅长设计高覆盖率的测试场景”）。 分步指令：将复杂任务分解为多步骤（如“第一步：分析需求文档；第二步：识别关键路径；第三步：生成用例”）。 思维链（Chain-of-Thought）：虽然目前很多模型都提供了深度思考能力，但通过提示词引导模型的分析，可以简化模型的思考推理方向。例如“请先分析用户操作流程，再重点针对异常场景生成测试用例”。 渐进式的迭代优化，持续改进提示词 大模型通常会保留对话上下文，针对每次反馈的结果，应不断校正，逐渐向最佳输出靠拢\n反馈修正：对模型输出中的错误及时指正（如“第2条用例未覆盖超时场景，请补充”），并要求重新生成。 参数调整：控制输出长度（如“请用50字以内描述”）、温度系数（Temperature）以平衡模型的创造性与准确性。 交叉比对：目前开放大模型有很多，能力不一，对于分析的结果差别也比较大。可以综合判断，提取最优结果。 常见的一些校正场景：\n问题 原因 改进方法 输出过于宽泛 需求描述模糊 添加具体场景、格式、优先级约束 结果重复或冗余 未明确限制输出范围 排除不需要的场景(如指定“仅输出未覆盖的边界值场景”) 技术术语错误 模型缺乏领域知识 提供术语表或指定角色（如“金融系统测试专家”） 案例分析 基于以上原则，以我们要测试 https://www.saucedemo.com 这个网站的购物流程为例，要用大模型帮助我们生成一系列测试用例，提示词框架可以按下面的方式设定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 假设你是一名经验丰富的软件测试工程师，负责对电商网站 https://www.saucedemo.com/ 的核心购物流程进行端到端的功能测试。 任务： 为以下用户场景生成详细的、高优先级的正向和反向测试用例。重点关注从商品选择到成功下单的完整流程。 被测网站: https://www.saucedemo.com/ 测试用户凭据: •标准用户 (Standard User): standard_user / secret_sauce •有问题的用户 (Problem User): problem_user / secret_sauce (用于观察特定错误行为) 核心购物流程步骤: 1. 用户登录 2. 浏览商品列表 (Inventory Page) 3. 选择至少两件不同商品并添加到购物车 4. 查看购物车 (Cart Page) 5. 在购物车页面验证商品信息（名称、数量、价格）和总价 6. 进入结账信息页面 (Checkout: Your Information) 7. 填写有效的结账信息（姓、名、邮政编码） 8. 进入结账概览页面 (Checkout: Overview) 9. 在概览页面验证商品信息、总价（含税） 10.完成购买 (Checkout: Complete!) 11.验证订单成功信息 测试用例要求: •正向测试用例: 覆盖使用标准用户成功完成购物流程的每个步骤，确保功能按预期工作。 •反向测试用例: •尝试在结账信息页面输入无效数据（例如，姓、名、邮编为空或格式错误）。 •尝试在购物车为空时进行结账。 •(可选)使用 problem_user 登录，观察并记录在购物流程中可能出现的异常行为，特别是商品图片、添加购物车或结账环节。 输出要求: •每个测试用例应包含：用例 ID (TC_SAUCE_SHOP_XXX)、测试描述、前置条件（如已登录并添加商品）、测试步骤（清晰、可执行）、预期结果、实际结果（预留填写）、状态（预留填写）、优先级（高/中/低）。 •优先生成高优先级的测试用例。 输出格式: 请将测试用例以 Markdown 表格形式输出，包含以下列：用例 ID, 测试描述, 前置条件, 测试步骤, 预期结果, 优先级。 约束说明: •假设税率为 8%。 •关注 UI 元素的交互和页面跳转的正确性。 •如果对某些特定元素的 ID 或 Class 不确定，可以使用通用的描述，例如“点击添加到购物车按钮”或“输入姓名字段”。 以上提示词比较好地对应了相关的提示词框架原则：\n明确的角色：\u0026ldquo;假设你是一名经验丰富的软件测试工程师\u0026hellip;\u0026rdquo; 清晰的任务：\u0026ldquo;为以下用户场景生成详细的、高优先级的正向和反向测试用例。重点关注从商品选择到成功下单的完整流程\u0026rdquo; 充分的上下文信息: 被测URL、用户信息、用例侧重点、税率假设 指定输出格式：\u0026ldquo;请将测试用例以Markdown表格形式输出，包含以下列：用例ID, 测试描述, 前置条件, 测试步骤, 预期结果, 优先级。\u0026rdquo; 明确的具体要求和约束：用例和输出的具体要求， 引导思考方向：使用problem_user生成异常用例 最终通过这样的提示词，通过Deepseek，我们会得到如下一份生成的用例：\n高优先级核心购物流程测试用例 用例ID 测试描述 前置条件 测试步骤 预期结果 优先级 正向测试用例 TC_SAUCE_SHOP_001 标准用户成功登录并进入商品列表页 无 1. 访问 https://www.saucedemo.com/ 2. 输入用户名 standard_user 和密码 secret_sauce 3. 点击登录按钮 登录成功，跳转至商品列表页（Inventory Page） 高 TC_SAUCE_SHOP_002 添加两件不同商品到购物车并验证数量 用户已登录 1. 在商品列表页选择两件不同商品，分别点击“添加到购物车”按钮 2. 检查购物车图标显示数量为2 购物车图标数量更新为2，且两件商品均显示在购物车页面 高 TC_SAUCE_SHOP_003 购物车页面验证商品信息和总价（不含税） 用户已添加两件商品到购物车 1. 点击购物车图标进入购物车页面 2. 核对商品名称、数量、单价 3. 计算总价（商品1价格 + 商品2价格） 商品信息正确，总价显示为两件商品价格之和 高 TC_SAUCE_SHOP_004 完成有效结账信息并验证含税总价 用户已进入结账信息页面 1. 在结账信息页面输入有效姓、名、邮编（如：John/Doe/12345） 2. 点击“继续”按钮 3. 在概览页面验证总价（总价 = 商品总价 * 1.08） 跳转至结账概览页面，总价含8%税且计算正确 高 TC_SAUCE_SHOP_005 完成购买并验证订单成功信息 用户已进入结账概览页面 1. 点击“完成”按钮 显示“THANK YOU FOR YOUR ORDER”成功信息，返回商品列表页 高 反向测试用例 TC_SAUCE_SHOP_006 结账信息页面姓名为空时提交表单 用户已进入结账信息页面 1. 留空姓名字段，输入有效邮编（如：12345） 2. 点击“继续”按钮 提示“First Name is required”，阻止跳转 高 TC_SAUCE_SHOP_007 结账信息页面邮编格式错误（如非数字） 用户已进入结账信息页面 1. 输入有效姓、名，邮编为“ABC12” 2. 点击“继续”按钮 提示“Postal Code is invalid”，阻止跳转 高 TC_SAUCE_SHOP_008 购物车为空时尝试结账 用户已登录且购物车为空 1. 点击购物车图标进入购物车页面 2. 点击“结账”按钮 提示“Cart is empty”或阻止跳转至结账页面 高 Problem User 测试用例 TC_SAUCE_SHOP_009 Problem User 添加商品时图片显示异常 Problem User 已登录 1. 浏览商品列表页 2. 检查商品图片是否加载正确（如：图片错位、无法显示） 商品图片显示异常（如空白图、错误图片） 中 TC_SAUCE_SHOP_010 Problem User 结账时总价计算错误 Problem User 已添加商品到购物车 1. 完成结账流程至概览页面 2. 验证总价是否等于商品总价 * 1.08 总价计算错误（如未含税或计算值偏差） 中 补充说明 优先级分配：核心流程（登录、添加商品、结账）和关键异常场景（空字段、无效数据）设为高优先级。 Problem User：用于验证特定异常行为（如UI渲染错误或逻辑漏洞）。 实际结果/状态：执行时需根据实际观察填写（如“通过”、“失败”或“阻塞”）。 税率计算：假设商品总价为 $X，含税总价应为 X * 1.08，保留两位小数（如 $21.99 * 1.08 = $23.75）。 ","date":"2025-04-16T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/079-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BA%E8%AF%8D/","title":"高效使用AI大模型：测试工程师提示词编写框架"},{"content":"引言 \u0026ldquo;每天都是开不完的会！一多半时间就是在听个别人争吵！\u0026rdquo; “什么事都喜欢拉一大票人开会，真正发言的倒没几个！” “一个需求改动，计划10分钟的会能聊上两小时！”\n在快节奏的软件研发工作中，会议是信息同步、决策制定、问题解决不可或缺的一环。但我们很多时候，感受到的却是会议的低效！据统计，一名软件工程师平均每周要花 12小时 在各种会议上，但其中60%的会议被证明低效甚至无效 。\n要如何让会议真正成为协作工具而非时间黑洞？本文，我们将通过介绍高效会议的5P法，拆解会议提效的核心逻辑，摆脱“会海”！\n何为5P法？ 会议5P法，其实就是我们在召开会议中，需要关注的5个主要方面。把这5方面处理好，那么会议就不会陷入漫无目的、冗长低效的泥潭中。\nPeople：谁该来参会？ 案例： 需求澄清会上，只有产品经理和几个核心开发参与了，但测试人员和UI/UX设计师缺席。结果，开发过程中发现需求理解与测试预期不一致，UI/UX设计也与功能实现有偏差，导致后期大量返工。\n低效会议的常见问题之一就是 “该来的人没来，不该来的人坐一堆”。所以确保邀请了所有关键且必要的干系人，同时避免无关人员的参与，是会议成功的第一步。\n重点考虑如下几点：\n必要性： 只邀请那些能提供关键信息、参与决策或受会议结果直接影响的人。 代表性： 如果团队较大，可以邀请各职能的代表参加。 角色清晰： 明确每个人的发言重点和责任。 比如上例需求澄清会中，我们可以确定以下People角色参会：\n产品负责人 (Product Owner): 阐述需求背景、用户故事、业务价值。 开发团队代表 (Development Team Lead/Members): 从技术实现角度提问，评估可行性。 测试团队代表 (Test Lead/QA Engineer): 从可测试性角度提问，思考测试场景。 UI/UX设计师 (UI/UX Designer): 明确用户交互和界面设计细节。 (可选) 架构师 (Architect): 若需求涉及复杂系统架构调整。 Purpose：为什么开这个会？ 案例： 敏捷回顾会变成了“吐槽大会”或“表扬大会”，大家七嘴八舌，但没有聚焦于如何改进下一个迭代的工作流程和协作方式。会议是召开了，但到下一个迭代，存在的问题依旧没有改观。\n没有目标的会议，就像失去导航的海上孤舟，很容易迷失航向，难以保证最后驶向何方，最后不了了之。\n只有所有参会者都了解会议的目的，才能统一大家的认知，确保讨论不偏离主旨。\n而这里目标的设定，也应该注意：\n目标应具体、可衡量、可达成、相关性强且有时间限制 (SMART原则)。 一次会议尽量聚焦于1-2个核心目标，避免议题过多导致失焦。 确保所有参会者对会议目标有共同的理解。 比如上面迭代的回顾会，我们就可以将目标进行明确：\n主要目标： 检视上一个迭代中哪些做得好，哪些方面存在问题，并为下一个迭代制定具体的改进措施。 具体子目标： 识别出影响团队效率最高的1-2个障碍点，并制定解决方案； 确定一项需要继续保持的优秀实践。 Process：会议应该怎么开？ 案例：测试用例评审会。在会议开始后，大家才拿到厚厚一沓打印好的测试用例，逐条阅读，临时提问。主讲人讲解也缺乏重点，评审人员思路发散，导致会议超时严重，评审效果极差。\n如果Purpose是确保航向，那么Process就是会议这艘船的海图。一个清晰的流程能够引导会议有序进行，确保每个议题都得到充分讨论，并能在预定时间内达成目标。\n包括会议的议程、时间分配、讨论规则、决策方式等约定。\n还是以上面案例来说明，在会前我们就可以约定Process：\n结构化议程： 会前准备 (5-10分钟，或会前完成)： 主持人简述评审范围、目标和用例背景。强调测试用例已提前共享，默认参会者已预先阅读。 重点/疑点用例讨论 (30-40分钟)： 针对预先收集的疑问或标记的重点用例进行集中讨论。限定每个复杂用例的讨论时间。 总结与确认 (10-15分钟)： 汇总评审意见，明确修改负责人和截止日期。确认用例覆盖度是否达成共识。 明确讨论规则： 例如，鼓励建设性意见，避免打断发言，意见不一时如何决策（如少数服从多数，或特定角色最终决定）。 时间控制： 为每个议程环节设定预估时间，并严格执行。 Product：会议的成果是什么？ 案例：版本发布计划会。在会议中，大家讨论了许多关于新版本的功能设想和潜在风险，但没有形成明确的发布范围、优先级和责任人。会后大家对“新版本到底要做哪些功能”依然模糊不清。\n首先澄清一个误区，并不是会议开完，产生了会议纪要就叫做会议有了输出。 一个会议真正的成果应该是可转化为下一步行动的共识，并且是可追溯的。它可以是决策、行动计划、解决方案、共识记录、更新的文档等。没有明确的产出，会议就等于白开。\n以上面案例来说，明确的交付物可以是：\n确定的发布范围： 一份清晰的功能列表 (Features List) 或用户故事 (User Stories)，并且有优先级的区分。 初步的时间表： 关键里程碑和预计的发布日期。 明确的责任分工： 每个主要模块或任务的负责人。 已识别的风险及应对措施： 记录潜在风险和初步的缓解计划。 会议纪要： 包含以上所有内容，并明确后续的跟踪事项。 是会议成果的书面记录 Pitfall：预计的风险是什么？ Pitfall指的是“在会议过程中，可能会遇到哪些潜在的问题或障碍？我们如何预防或应对？”\n一些常见的会议风险点及应对思路 议题过于发散，讨论跑题：\nPitfall: 参会者可能对某个细节过度深究，或引入不相关的议题。 应对 (结合Purpose \u0026amp; Process): 主持人需时刻谨记会议核心目标，温和地将讨论拉回正轨。可以设置“停车场”（Parking Lot）机制，记录临时想到的但与当前议题无关的点，会后再讨论。 关键人物缺席或迟到：\nPitfall: 核心决策者或信息提供者未能按时参与，导致会议无法有效推进。 应对 (结合People): 提前与关键人物确认时间，发送会议提醒。若临时缺席，评估是否可以继续，或调整议程，或重新安排会议。 少数人主导发言，其他人沉默：\nPitfall: 可能导致信息不全面，决策有偏。 应对 (结合Process): 主持人应有意识地邀请沉默的参会者发言，或采用轮流发言、匿名收集意见等方式，确保每个人都有贡献的机会。 准备不足，信息不对称：\nPitfall: 参会者未提前阅读材料，导致会上花费大量时间同步基础信息。 应对 (结合Purpose \u0026amp; Product): 提前将会议材料（如需求文档、设计稿、待评审用例）清晰地发送给参会者，并明确要求他们会前阅读和准备。 没有明确的行动计划和跟进：\nPitfall: 会议讨论热烈，但没有落实到具体行动，最终不了了之。 应对 (结合Product): 会议结束前，务必总结行动项、责任人和截止日期，并明确后续如何跟踪进展。 总之，提前思考潜在的风险，并准备好应对策略，可以有效避免会议被意外情况打断或偏离轨道，确保会议顺利进行并达成预期目标。\n总结 通过以上结合案例的5P法介绍，要高效地完成一个会议，通过5P法，可以有效避免会议失控。它的核心逻辑其实就是：\n“用结构化的方法去对抗人性的随意”\nPeople (合适的与会人)： 确保正确的人在场。 Purpose (明确的目标)： 清楚为何而来，去往何方。 Process (清晰的流程)： 规划好路径，有序前行。 Product (期望的产出)： 带着成果离开。 Pitfall (预估的风险点)： 规避障碍，顺利抵达。 我之前介绍敏捷四会的相关文章中，相关的实践也反映了5P法的核心逻辑，推荐大家可以参照阅读~\n","date":"2025-04-15T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/078-%E4%BC%9A%E8%AE%AE5p/snap_20250515_hu_469125c6e0aadd25.png","permalink":"https://chengxiaqiucao.github.io/post/078-%E4%BC%9A%E8%AE%AE5p/","title":"高效会议5P法，别让会议偷走你的时间"},{"content":"过去数周间，模型上下文协议（Model Context Protocol，MCP）快速崛起为第三方数据与工具接入LLM对话系统的实际标准。互联网短时间已充斥着各类炫酷应用案例，想象空间极为广阔。但这个协议背后却也暗藏一些微妙的安全隐患与功能的局限性。\n背景 MCP的本质是构建\u0026quot;智能助手插件生态\u0026quot;的桥梁，让用户能为各种支持了MCP协议的大模型和AI客户端提供本地扩展能力，让这些基于LLM的智能界面可以通过MCP的\u0026quot;工具调用\u0026quot;执行非文本操作，MCP协议实际上是标准化了LLM和本地数据、工具的对接方式。\n比如在前文【】中，我们只是在 Cursor 中告诉大模型: \u0026ldquo;访问www.saucedemo.com网站，使用problem_user登录，验证该网站完整流程并记录发现的问题\u0026rdquo; , Cursor 就会通过playwright-mcp 这个 mcp server来调用playwright框架完成浏览器的调用、访问、浏览、测试、记录问题等一系列活动，完成跟手工测试工程师类似的测试活动\n所以通过MCP，它的核心价值就是突破了原来AI大模型文字型咨询助手的角色，转变为实际的执行者角色，更能够直接操作本地的工具和数据，为大模型提供了万能插口。\n潜在的隐忧 但我们在看到MCP巨大潜力的同时，也要看到，MCP作为刚起步不久的一个基础协议，尚不能称为尽善尽美，要看到还有如下一些隐忧：\n隐患一：协议本身的安全性 认证机制 MCP的初始版本未定义认证规范，导致各MCP服务器可自行其是，从繁琐的验证到敏感数据裸奔，可谓乱象丛生。虽后续推出认证方案，但实现复杂度引发新的争议。\n恶意代码本地执行风险 协议支持通过标准输入输出运行MCP服务器，这样虽然降低使用门槛，却也为恶意代码传播提供了温床。如果技术小白执行第三方恶意MCP代码引发本地设备安全故障，已成新型攻击手段。\nMCP对用户输入的信任 很多Mcp Server会直接执行用户的输入指令。当用户意图经LLM转译并对系统产生作用时，传统安全模型面临严峻挑战：用户输入指令与攻击系统的边界不再清晰。\n隐患二：交互设计上的限制 MCP协议更多是面向LLM交互，但针对用户来说，交互方式谈不上易用、友好。\n缺少针对不同等级的操作风险分级 很多助手工具会提供全局的操作确认机制，但针对很多无害工具养成的“自动确认”习惯，往往会导致一些严重误操作的发生，比如本地重要文件的删除、邮件误发等情况。\n成本控制能力 与传统协议不同，LLM场景下依据不同token的返回量会产生数额不等的费用，而用户服务成本高度依赖MCP工具的词元效率，而目前协议中并没有对返回长度的限制以强化成本控制。\n牺牲结构化数据的优势 为适配LLM偏好，MCP偏向采用类似人类可读的方式，如纯文本/图片/音频片段传输，而牺牲结构化数据优势。比如类似像地图、滴滴叫车等服务，需确保位置准确性、行程细节反馈、实时状态更新等需求的话，现有协议难堪重任。目前解决这类问题还需要在工具层做一些变通的额外设计\n隐患三：LLM的安全性 大模型本身安全性的探讨，目前还悬而未决，而引入MCP连接更多的数据、工具让这个问题更为凸显。\nMCP让提示词注入能力更强悍 LLM 通常有两层指令：系统级提示词（控制助手的行为和策略）和用户级提示词（由用户提供）。通常，以前提到提示词注入通常指恶意的用户输入。而MCP 模型一个相当大的漏洞是允许第三方提供的工具被信任为助手系统级提示的一部分，从而赋予它们更大权限来覆盖代理行为。\n敏感数据泄露 除了恶意地通过恶意工具劫持外，MCP也可能让用户在无意中泄露敏感数据。即便用户严格确认每个操作，数据仍可能通过\u0026quot;合理\u0026quot;的方式外泄出去。比如你的指令：“帮我解释一下个人病历记录”，助手可能会启动一个医疗检索类的多租户MCP工具，并把个人隐私信息泄露到服务提供商。\n包括MCP Server也很容易通过伪装提示词和实际的工具实现，劫持、更改用户的意图。\n隐患四：打破企业中的传统数据权限控制 与直接泄露敏感数据不同，企业在将大量内部数据通过MCP连接到LLM以后，可能会让普通员工访问或推断出无权访问到的数据。\n举例来说，如果一个企业的所有内部文档都接入LLM，员工通过助手：\n“根据所有我有权限访问的文档和公司的任免通知，推断尚未宣布的重大事件如裁员行动”\n或者一个经理级别的人：\n“我看到内部wiki上有一条匿名的针对XXX的负面评价，内容是XXXX，请分析XX团队中成员的发言记录并推断最可能是谁写的这条评价”\n隐患五：LLM自身的能力局限 对于大规模的MCP集成，LLM本身的负载能力很可能无法承受。Google推出的A2A协议(Agent to Agent) 可能是解决手段，另当别论。\nMCP的能力发挥依赖于被助手集成的LLM 一个事实是并非工具越多，数据越多，结果越准确，恰恰相反，同类的数据和工具越多，会导致最终输出的精确性越差。随着MCP Server的数量越来越多，集成的工具越来越多，AI助手的性能也将显著下降，并且请求和分析的成本也会增加。\n工具实现和用户预期的落差 很多MCP Server在实现上其实是编写调用本地已有工具的函数方法，MCP Server的能力其实主要受这些函数方法的制约。如果用户对具体的函数实现没什么了解，只是按通常的人为沟通思路和LLM交互，很可能难以获得满意的结果。\n“请为我查找最近所有博客中包含AI测试相关的文章”，这个指令其实需要本地MCP Server具备全文检索本地文本内容的能力，但如果集成的MCP Server仅仅包含了文件查找的功能，自然得不到相应的结果。\n结论和展望 MCP的诞生顺应了AI时代的数据整合需求，其日常应用价值毋庸置疑。但我们也需要清醒认知：MCP协议还在成长期，我们在拥抱应用的同时，也需要认识到其中的风险， 将LLM与数据的结合，会放大既有风险，也催生了新型的威胁。\n本文大部分观点参考了Shrivu的博客内容 (阅读原文)\n","date":"2025-04-14T15:28:24+08:00","permalink":"https://chengxiaqiucao.github.io/post/076-mcp%E5%A4%A7%E6%B5%81%E8%A1%8C%E8%83%8C%E5%90%8E%E7%9A%84%E9%9A%90%E5%BF%A7/","title":"Mcp大流行背后的隐忧"},{"content":"\n4月9日，Google重磅发布了A2A(Agent to Agent) 协议，为 AI Agent能力开放和标准化，又添了一把火。那么这个 A2A协议 到底做什么？和之前火爆的MCP Server又是什么关系？是不是会产生标准之争？ 本文我们就来了解下这个新进出炉的A2A协议，以及它的应用场景。\nA2A与MCP A2A，即 Agent to Agent 协议，是由 Google刚刚推出的一个AI基础开源协议，旨在实现 AI Agent之间的通信和互操作性。通过为代理提供标准化的协作方式，即无论其底层框架或供应商如何，不同 AI Agent都能够安全地进行信息交换和协作，并可以跨各种企业平台和应用程序工作。\n这个协议提供的 Agent 和 Agent 之间的一个通用通信标准。\n它和近期大火的 MCP (Model Context Protocol)（前文介绍 【】）其实并不是竞争关系。Google官方在发布声明中也重点说到，这个协议其实是针对MCP协议的补充。\nMCP 是 AI 公司 Anthropic（claude母公司）去年底推出的开放协议，它旨在标准化大语言模型（LLM）与外部数据源、工具之间的交互接口。\n随着 OpenAI 等主流大模型宣布支持MCP接入，MCP目前很有潜力成为 AI 应用领域的一个基础规范，近期各种MCP Server雨后春笋般纷纷涌现，也证明这个协议得到了广泛认可。\n所谓三流企业做产品、二流企业做品牌、一流企业做标准，Google 很敏锐地捕捉到了 AI Agent 应用标准拼图中，MCP之外很重要的一块。\n就是MCP定义了 LLM 和 Agent 之间的连接，可以利用 Agent 为LLM扩充能力，以后也肯定会出现类似App Store这样的Agent商店，整合各类不同的Agent。\n但对于后续大规模的的AI应用，将会集成很多Agent共同协作，这些Agent之间的交互就是目前缺失的一块拼图。A2A起到的就是这个作用。很类似于微服务系统中的服务间通信协议。\nA2A的设计原则 官方给出了A2A协议的设计原则：\n拥抱代理能力：A2A 致力于使代理能够以自然、非结构化的模式进行协作，即使它们不共享内存、工具和上下文。我们正在实现真正的多代理场景，而不将代理局限于单一的“工具”。\n基于现有标准： 该协议建立在现有的流行标准之上，包括 HTTP、SSE、JSON-RPC，这意味着它更容易与企业日常使用的现有 IT 堆栈集成。\n默认安全：A2A 旨在支持企业级身份验证和授权，在启动时与 OpenAPI 的身份验证方案相同。\n支持长时间运行的任务： 设计 A2A 时就考虑到了灵活性，并支持各种场景，使其能够出色地完成各种任务，从快速任务到深度研究，这些任务可能需要数小时甚至数天的时间（如果人工参与）。在此过程中，A2A 可以为用户提供实时反馈、通知和状态更新。\n与模态无关： 代理世界不仅限于文本，这就是我们设计 A2A 来支持各种模态（包括音频和视频流）的原因。\n主要功能 能力发现： 代理可以使用 JSON 格式的“代理卡”来宣传其能力，从而允许客户端代理识别能够执行任务的最佳代理并利用 A2A 与远程代理进行通信。\n任务管理： 客户端与远程代理之间的通信以任务完成为导向，代理负责执行最终用户的请求。此“任务”对象由协议定义，并具有生命周期。它可以立即完成，或者，对于长时间运行的任务，每个代理可以进行通信，以彼此保持同步，了解任务的最新完成状态。任务的输出称为“工件”。\n协作： 代理可以互相发送消息来传达上下文、回复、工件或用户指令。\n用户体验协商： 每条消息包含“部分”，即完整形成的内容片段，例如生成的图像。每个部分都有指定的内容类型，允许客户端和远程代理协商所需的正确格式，并明确包含对用户 UI 功能（例如 iframe、视频、Web 表单等）的协商。\nA2A、MCP、LLM之间的关系：\n协议说明 该协议目前在github开源，主要是一个json schema的格式说明文件 ( 关于 json schema 的介绍，参见【】)，具体定义可查看源文档。\n这里说明下其中包含的主要部分及其作用：\n1. AgentAuthentication 这部分定义了支持的认证方式，例如 OAuth 或 API 密钥。\n2. AgentCapabilities 用于标识 Agent 的能力范围，例如是否支持实时通信。\n3. AgentCard 提供 Agent 的核心信息，例如它的功能和技能，便于被发现\n4. AgentProvider 标识提供者的组织或公司信息。\n5. AgentSkill 描述 Agent 的技能，例如可以执行的任务或功能。\n6. 错误定义 包含了一些预定义的Error， PushNotificationNotSupportedError、InvalidParamsError、JSONParseError 分别指示通知不支持、参数无效、Json解析等错误类型\n7. FileContent \u0026amp; FilePart 用于传递文件相关的数据，例如上传或下载操作。\n案例 a2aprotocol.net 提供了一个 A2A 和 MCP 协作的案例场景说明\n在测试领域的应用，像 【】一文后，有小伙伴提到的更丰富场景，将用例解析、Playwright执行、问题收集并汇报等集成起来，这个就可以由不同Agent来完成，分别负责用例的生成、Playwright执行、向禅道Jira等提交等工作，这里除了Agent之间的工作流，像用例、Bug等在不同Agent之间的传输，就可以用A2A协议来实现。\n相关实践，还有待相关Agent的丰富，后续本号也会持续跟踪！\n","date":"2025-04-11T11:36:52+08:00","image":"https://chengxiaqiucao.github.io/post/075-google%E6%8E%A8%E5%87%BAa2a%E5%8D%8F%E8%AE%AE/Pasted-20250411_hu_84815bad32fc133b.png","permalink":"https://chengxiaqiucao.github.io/post/075-google%E6%8E%A8%E5%87%BAa2a%E5%8D%8F%E8%AE%AE/","title":"Google推出A2A协议"},{"content":"本文来自 TestGuild 1 月份对今年测试发展趋势的分析，目前看判断还是客观准确的，现将译文分享给大家。\n随着我们进入2025年，我认为以下自动化测试趋势将深刻影响软件测试的未来。\n目录 1. AI Agent：测试新浪潮 2. AI右移：理解用户 3. 全民皆QA：人机协同 4. 测试者角色进化：适应未来 5. DevOps与SRE整合：持续质量 6. 端到端（E2E）自治质量平台 7. Playwright：首选自动化工具 8. 2025年测试者必备编程语言 总结：2025年自动化测试成功之道 AI Agent：测试新浪潮 我认为2025年将见证AI辅助测试的持续扩展。\n原因何在？\nAI在测试中的应用呈指数级增长：调查显示，截至2024年，72.3%的团队正在积极探索或采用AI驱动的测试工作流，而几年前这一技术尚处于早期采用阶段。这一趋势标志着我们TestGuild自动化测试调查历史上最快的技术采用曲线。\n在2024年多模态AI（通过专用算法处理多种数据类型）基础上，新兴趋势是代理型AI。\n首先，您可能会问：什么是代理型AI？\n这类系统能自主运作，处理以往需要人工干预的任务。它们能进行通信、维持长期状态，并根据交互独立决策，实质上是充当高能效测试助手团队。\n仍不清楚？让我们通过示例说明。\n代理型AI自动化测试工作流示例 设想一个真实场景：代理型AI为大型电商平台自主管理全量回归测试套件。\n不同于依赖预设脚本和固定排期，该代理型AI系统将执行以下操作：\n优先级判定：分析近期代码变更和功能发布，根据修改风险等级排序回归测试 测试选择与适配：动态选取合适测试用例，基于风险评估从完整套件中筛选子集 测试执行与环境管理：跨多环境（浏览器/操作系统/设备）调度执行测试。若测试失败，自动触发诊断测试收集详细信息，甚至尝试自动修复简单问题 结果分析与报告：分类故障严重程度，识别模式，根据常见错误模式提出修复建议 反馈循环与持续改进：通过经验积累不断自我优化 此设想并非天方夜谭。调查数据显示，团队不仅追求任务自动化，更依赖AI自主决策——这正是代理型AI的核心：\n决策能力：AI工具日益被信任用于优化测试覆盖率和维护 自主性：对AI驱动流水线和框架的兴趣表明团队需要最小化人工干预的解决方案 性能表现：聚焦采用AI的工具框架，显示向动态学习适应系统的转变 转型速度超乎预期：网络研讨会投票显示56%团队处于AI采用\u0026quot;调研阶段\u0026quot;，38%企业将AI视为缓解测试人才短缺的解决方案。\n行业巨头观点与此一致（笔者将其延伸至自动化测试领域）：\n微软CEO萨提亚·纳德拉近期提及AI\u0026quot;代理\u0026quot;将革新SaaS，通过处理复杂任务、持续学习和跨系统无缝连接实现突破。斯坦福研究者关于AI代理模拟人类行为的实验，同样印证代理型AI改变测试方式的潜力。\nAI右移：理解用户 理解真实用户行为已成为2025年质量策略的核心要素。通过分析生产环境用户交互，团队能发现模式、预测问题，确保软件满足用户期望。AI整合使团队探索出质量提升新路径。\n调查数据显示，对预测模型和用户行为分析的关注度显著提升，团队聚焦利用AI发现长尾用例，优化用户旅程理解。Gojko Adzic设想工具直接集成至平台，提供体验分析和预测模型，主动预判问题。这在管理海量用户数据（含长尾用例）时价值凸显，AI在数据模式识别中发挥关键作用。\n这种右移方法通过强调部署后质量保障，与传统左移方法论形成互补。潜在收益包括：\n通过主动监控减少用户报障 通过优化高价值用户流提升功能采用率 基于真实使用模式的数据驱动决策改善测试覆盖 全民皆QA：人机协同 随着代理型AI和端到端自治质量平台（后文详述）的采用，2025年软件测试将发生剧变。低代码/无代码工具结合AI，使测试突破传统壁垒，让业务分析师、开发者甚至非技术背景的利益相关方都能参与质量保障。网络研讨会投票显示**74%**参与者自认AI新手，凸显降低使用门槛的工具需求。\n直观的低代码解决方案通过自动化测试创建和缺陷检测等复杂任务，降低学习曲线，加速工具采用。调查显示**32.3%**团队积极尝试无代码测试方案。\n同时，人类监督仍不可或缺。正如Tobias Müller所言：\u0026ldquo;重点已非是否信任AI，而是设定边界并信任所设规范。\u0026ldquo;结合人类经验与AI的团队展现出更优缺陷检测和更快测试周期，证明人机协同的重要性。\n测试者角色进化：适应未来 测试者正转型为融合传统技能与AI、DevOps、自动化知识的复合型角色。调查数据印证这一转变：\n45%团队强调AI技能需求 51.8%优先考虑DevOps知识 72.3%聚焦自动化专长 DevOps与SRE整合：持续质量 测试与DevOps及站点可靠性工程（SRE）实践的整合，是2025年最显著的自动化测试趋势。随着企业日益重视持续交付和运营韧性，测试正进化为主动的、贯穿软件生命周期的质量保障活动。\n调查数据显示显著转变：截至2024年，**51.8%**团队采用DevOps实践（2022年仅16.9%）。这种增长印证测试与DevOps/SRE工作流的深度整合，以保障高速交付下的软件质量。\n这种整合超越传统QA，转变为提升全生命周期的持续活动，帮助企业：\n加速反馈循环：CI/CD管道嵌入测试，即时发现问题 实施主动质量保障：工作流整合性能测试与监控，提前识别风险 促进团队协作：质量共担机制改善QA、开发与运维团队协作 调查数据清晰支持此趋势。从流水线自动化到性能监控，团队正采用与卓越运营目标一致的持续质量实践。若您的组织尚未整合测试与DevOps/SRE，2025年正是转型良机。\n端到端（E2E）自治质量平台 E2E平台正成为测试战略核心。这些平台整合测试、可用性、性能、无障碍访问和安全性于统一框架，应对更广泛的质量问题。通过AI自动化测试生命周期，团队反馈缺陷检测和测试覆盖显著提升。\n调查数据显示显著增长：\n安全测试从2021年8.2%增至2024年39.5% 性能测试采用率达41% API测试从2021年13.1%增长至2024年46.2% 这些指标反映企业对综合质量平台管理全测试需求的依赖度提升。\nPlaywright：首选自动化工具 正如笔者去年预测，Playwright已成为众多测试者首选工具。根据Playwright超越Cypress（未来展望）文中分析，这一预测已被验证。\n当前进展？凭借卓越的多功能性、可靠性和性能，Playwright在2025年持续巩固其领先地位。TestGuild 2024年调查及社区反馈显示其显著增长。\n测试工具偏好呈现重大转变（2018-2024数据分析）：\nPlaywright：45.1%采用率使其成为增长最快工具，优势包括跨浏览器支持、API测试能力和高效工作流 Selenium：曾为市场领导者，现采用率下降至22.1%，因团队追求更高效稳定方案 Cypress：坚守前端测试领域，保持14.4%稳定用户群 Playwright用户普遍反馈：\n更快测试执行：加速反馈循环，改进开发生命周期 更低测试波动性：产出更稳定可靠的测试结果 除初始的UI浏览器自动化功能外，Playwright已进化支持API测试等高级能力，成为现代测试需求的综合解决方案。\n2025年测试者必备编程语言 根据TIOBE编程社区指数，Python连续两年蝉联榜首。这与我预期一致——Python凭借简洁性、强大库支持及在AI/机器学习领域的主导地位，仍是2025年测试者首选语言。无论您是初学自动化还是资深测试专家，Python都是衔接当下挑战与未来自动化测试可能性的桥梁。\n总结：2025年自动化测试成功之道 2025年将成为软件测试关键转折年，为拥抱变革者提供空前机遇。AI成熟度、团队协作与工具演进的融合，标志着质量保障新纪元的开启。\n成功不仅需要关注趋势，更需行动：\n拥抱代理型AI：探索自主AI代理如何优化工作流，降低人工干预 采用右移测试实践：平衡传统左移方法与部署后监控，确保软件符合真实用户期望 投资技能发展：为团队配备AI、自动化与DevOps知识以保持竞争力 测试与DevOps/SRE整合：打破孤岛，将质量保障融入交付各阶段 善用综合工具：从Playwright到Python，选择满足当前需求并面向未来的工具 这些趋势预示着质量保障方式的根本转变。随着测试、开发与运维界限的模糊，现代测试者角色正进化为战略要职。欲深度掌握变革趋势，欢迎参加年度Automation Guild大会，与行业领袖共同塑造测试未来。\n2025创新之路已铺就，您是否已准备好引领变革？\n","date":"2025-04-09T23:00:28+08:00","permalink":"https://chengxiaqiucao.github.io/post/074-%E6%9C%80%E6%96%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E8%B6%8B%E5%8A%BF2025/","title":"转译：2025自动化测试八大趋势"},{"content":"前言 MCP协议是由AI公司 Anthropic（claude的母公司）于2024年11月推出的一个针对AI能力的开放协议，旨在标准化大语言模型（LLM）与外部数据源、工具之间的交互接口。其核心设计目标：\n解耦与标准化：将LLM与外部系统的集成从定制化开发转变为基于统一协议的通用连接，类似硬件领域的USB-C接口。 去中心化：通过允许开发者自主构建MCP Server，分散AI能力，避免单一厂商垄断知识和服务。 安全可控：通过权限验证和本地化部署，确保数据隐私与操作安全。 而 MCP Server 则是MCP的关键组件，提供如下三种功能：\n资源（Resources）：类似文件的数据，可以被客户端读取，如 API 响应或文件内容。 工具（Tools）：可以被 LLM 调用的函数（需要用户批准）。 提示（Prompts）：预先编写的模板，帮助用户完成特定任务。 通过这些能力，MCP Server可以为AI应用提供更加丰富的上下文操作私有数据或特定应用的能力，从而增强 LLM 的实用性。\n在上一篇文章 【】中，我们已经对 MCP Server有了基本认识，并且提供了一个基本的查询本地桌面的案例，并利用AI编辑器Cursor实现了这个MCP server的调用。\n微软官方推出Playwright-mcp MCP Server目前的很多应用中，调度浏览器操作是一个极为高频的场景，基于Playwright这个新锐浏览器工具，也已经有第三方先行推出了MCP Server\n而现在，微软官方也终于推出了Playwright-mcp，可以和Vscode copilot无缝结合使用\nPlaywright-mcp 部署 因为Playwright-mcp刚刚推出，目前 vscode中对它的集成主要还是在vscode的先览版vscode insider中。所以我们可以从vscode官网先下载一个vscode insider 安装好vscode insider后，在github项目主页上，直接点击对应按钮即可进行安装\n打开vscode 后，选择 install server，这时会自动配置好mcp server的配置文件，点击start，将mcp server运行起来，这样其实就完成了部署\n点击copilot对话框中，显示的tools按钮，可以看到目前集成的tools，主要对应playwright的15种主要操作行为\n用playwright-mcp无代码完成浏览器操作和验证 下面我们就看看效果吧。\n打开copilot，输入指令：\n导航到https://www.saucedemo.com, 用账号standard_user和密码secret_sauce登录，并确认登录成功，product页面正常显示\n继续执行，得出结果，用例执行成功\n可以看到，这里我们没有编写任何代码，就利用Playwright的mcp完成了对登录用例的执行。\n当然实际工作中，通过mcp server的集成，更多是为了我们方便地调用浏览器完成任务执行提供了更多便利！\n基于MCP-Server，相信还有更多、更丰富的实践可以帮助到我们！\n上一篇文章中，我们介绍了通过vscode insiders 集成微软官方的playwright mcp并执行测试的一个基本效果。\n有小伙伴提问是否能在 Cursor 中使用？这里我也进行了尝试，答案是可以成功集成，但有点小坑。 这里就跟大家分享下配置过程，以及Cursor中集成mcp以后的强大能力。让 AI 帮助我们完成大部分基本的功能测试已经不再遥远\n在Cursor中启用playwright-mcp 预置安装 首先，当然要先安装mcp server以及对应的依赖，这里mcp和playwright都是基于nodejs的。所以通过下面命令先安装\n1 2 3 npm install -g @playwright/mcp@latest npm install -g @playwright@latest npx playwright install --with-deps Cursor配置 完成安装后，进入 Cursor 的设置页面，在其MCP部分，添加 MCP server配置，参照Playwright官网的介绍， 添加mcp sever配置：\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;mcpServers\u0026#34;: { \u0026#34;playwright\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;npx\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;@playwright/mcp@latest\u0026#34; ] } } } 但这时，cursor中的mcp server实际并不能正常运行，会显示 Clint closed\nwindows系统安装，要规避两个坑 第一个坑：npx 包加载路径应该加入搜索路径\n也就是要将全局安装的相关包，放到nodejs的搜索路径中。做法是在windows系统的环境变量中，把npm包目录加入path中，并放到nodejs之前\n第二个坑：修改mcp命令行调用命令\ncursor中调用npx，其实是通过命令行调用的，但windows系统下，直接通过命令行调用npx，cursor本身并不能拿到调用状态，所以这里要用 cmd /c 命令调用, 获取命令句柄\n也就是上面的配置文件，修改成：\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;mcpServers\u0026#34;: { \u0026#34;playwright\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;cmd /c npx\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;@playwright/mcp@latest\u0026#34; ] } } } 修改以上配置后，重新加载cursor，这时会启动一个命令行窗口，其实就是playwright-mcp，不要关闭，然后可以看到 Cursor中mcp也正常启动了\n让 playwright-mcp 代替我们执行测试 我们在Cursor中输入一个基本的任务指令：\n访问www.saucedemo.com网站，使用problem_user登录，验证该网站完整流程并记录发现的问题\n以下是完整执行过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 我将帮您访问 Sauce Demo 网站并使用 problem_user 账号进行完整测试流程验证。让我们开始吧。 首先，让我访问网站： Called MCP toolbrowser_navigate 让我使用 problem_user 账号登录： Called MCP toolbrowser_type 现在输入密码： Called MCP toolbrowser_type 点击登录按钮： Called MCP toolbrowser_click 让我们开始测试并记录问题。首先我注意到以下问题： 1. 商品图片问题： 所有商品的图片都显示相同的图片（狗的图片），这明显是一个bug，因为每个商品应该显示其独特的产品图片。 让我尝试添加商品到购物车： Called MCP toolbrowser_click 让我点击购物车图标查看购物车： Called MCP toolbrowser_click 让我们返回商品列表并尝试使用排序功能： Called MCP toolbrowser_click 让我尝试使用排序功能： Called MCP toolbrowser_click Called MCP toolbrowser_select_option 基于测试过程，我发现了以下问题： 1. 图片显示问题： - 所有商品的图片都显示为相同的狗图片，而不是各自的产品图片 - 这影响了用户对产品的视觉识别 1. 购物车功能问题： - 点击商品图片或标题时，没有正确跳转到商品详情页，而是直接跳转到了一个固定的商品页面 - 这影响了用户浏览和选择商品的体验 1. 排序功能问题： - 选择不同的排序选项（如按价格从低到高）后，商品列表顺序没有发生变化 - 排序功能完全失效 1. 导航问题： - 点击商品时总是跳转到同一个商品页面，而不是所点击的具体商品 - 这严重影响了用户的购物体验 1. 按钮状态问题： - 某些商品的\u0026#34;Add to cart\u0026#34;和\u0026#34;Remove\u0026#34;按钮状态显示不一致 - 这可能导致用户对购物车中的商品状态产生混淆 这些问题严重影响了网站的基本功能和用户体验。problem_user 账号确实展示了多个需要修复的问题，这些问题涵盖了UI显示、功能操作和用户体验等多个方面。 是否需要我继续测试其他功能，比如结账流程？ 请继续测试 好的，我将继续测试结账流程。首先让我们添加一些商品到购物车，然后进行结账： Called MCP toolbrowser_click 现在让我们点击购物车图标进入购物车页面： Called MCP toolbrowser_click 我发现点击购物车图标又出现了一个问题 - 它把我们带到了商品详情页而不是购物车页面。让我们尝试点击页面右上角的购物车图标： Called MCP toolbrowser_navigate 让我们继续结账流程，点击Checkout按钮： Called MCP toolbrowser_click 让我们填写个人信息： Called MCP toolbrowser_type Called MCP toolbrowser_type Called MCP toolbrowser_type 点击Continue继续： Called MCP toolbrowser_click 我发现了一个新的问题：虽然我们输入了姓氏，但系统显示\u0026#34;Last Name is required\u0026#34;的错误。这说明在输入字段上存在问题。让我们再次尝试输入姓氏： Called MCP toolbrowser_type 基于测试过程，我发现了以下新的问题： 1. 购物车导航问题： - 点击商品列表页面的购物车图标会错误地导航到商品详情页 - 必须手动输入购物车URL才能访问购物车页面 1. 结账表单问题： - 姓氏（Last Name）输入框存在严重问题 - 即使输入了姓氏，系统仍然显示\u0026#34;Last Name is required\u0026#34;错误 - 这个问题阻止了用户完成结账流程 1. 购物车商品显示问题： - 购物车中显示的商品数量与实际添加的商品数量不一致 - 一些未添加的商品也出现在购物车中 这些问题与之前发现的问题一起，严重影响了整个购物流程： - 用户无法正常浏览商品（图片问题） - 无法正确添加商品到购物车（购物车功能问题） - 无法使用排序功能（排序失效） - 无法正常访问购物车（导航问题） - 无法完成结账流程（表单验证问题） 这些问题使得 problem_user 账号几乎无法完成正常的购物流程。每个主要功能都存在不同程度的问题，这可能是为了测试目的而特意设置的。 是否需要我继续测试其他功能，比如菜单栏的功能？ 完成测试，请退出登录并汇总发现的问题 好的，让我们先点击菜单按钮然后退出登录： Called MCP toolbrowser_click Called MCP toolbrowser_click 现在我来汇总使用 problem_user 账号测试发现的所有问题： ### 1. 商品展示问题 - 所有商品图片显示为相同的狗图片，而不是各自的产品图片 - 这严重影响了用户对产品的视觉识别和购物体验 ### 2. 导航问题 - 点击商品图片或标题时，总是跳转到固定的商品页面，而不是所点击的具体商品 - 点击购物车图标错误地导航到商品详情页，而不是购物车页面 - 必须手动输入购物车URL才能正确访问购物车页面 ### 3. 商品排序功能问题 - 选择不同的排序选项（如按价格从低到高）后，商品列表顺序没有任何变化 - 排序功能完全失效，无法帮助用户按需要的方式浏览商品 ### 4. 购物车功能问题 - 购物车中显示的商品与实际添加的商品不一致 - 一些未添加的商品也出现在购物车中 - \u0026#34;Add to cart\u0026#34;和\u0026#34;Remove\u0026#34;按钮状态显示不一致，造成用户混淆 ### 5. 结账流程问题 - 姓氏（Last Name）输入框存在严重问题 - 即使输入了姓氏，系统仍然显示\u0026#34;Last Name is required\u0026#34;错误 - 这个验证问题完全阻止了用户完成结账流程 ### 6. 用户体验影响 - 以上问题的综合效果导致： - 用户无法正确浏览和选择商品 - 无法管理购物车内容 - 无法完成购物流程 - 整体购物体验严重受损 ### 7. 功能可用性评估 - 基本功能几乎都存在问题 - 用户无法完成正常的购物流程 - 这个账号可能是专门用于测试目的，展示了各种可能的问题场景 这些问题涵盖了电子商务网站的核心功能，包括商品展示、导航、购物车管理和结账流程。每个环节都存在不同程度的问题，使得整个购物体验变得极其困难和令人沮丧。这些问题的存在可能是为了测试目的，帮助开发人员和测试人员理解各种可能的错误场景。 可以看到，通过 Cursor + Playwright-mcp ，AI 已经可以通过我们交代的基本指令，主动帮助我们去覆盖主要的功能测试场景并发现和记录问题。假以时日，完全可以很大程度上替代掉比较基础功能测试任务，而测试人员则可以更关注在高价值的深度问题挖掘上。当然，另一方面，基础功能测试人员，确实也要有相当的危机意识，技能提升和扩展边界刻不容缓。\n欢迎关注秋草的测试技能体系化进阶提升课程，公众号回复 大纲 了解课程详细目录\n","date":"2025-04-02T16:38:33+08:00","image":"https://chengxiaqiucao.github.io/post/072-%E5%BE%AE%E8%BD%AF%E5%B7%B2%E5%8F%91%E5%B8%83playwright-mcp/Pasted-20250402_hu_8194eb3024fd37a6.png","permalink":"https://chengxiaqiucao.github.io/post/072-%E5%BE%AE%E8%BD%AF%E5%B7%B2%E5%8F%91%E5%B8%83playwright-mcp/","title":"微软已发布Playwright Mcp"},{"content":"\n引言 在AI技术高速演进的2025年，大模型的局限性日益凸显：它们虽拥有强大的推理能力，却难以直接访问私有数据或调用外部工具。这一痛点催生了一项革命性技术——MCP（Model Context Protocol，模型上下文协议），而作为其核心组件的MCP Server，正成为AI行业的下一个风口。本文将深入解析MCP Server的技术本质、行业价值，并结合实际案例探讨其应用前景。\n一、何为MCP？MCP的前世今生 1. MCP的定义与设计目标 MCP是由AI公司Anthropic（claude母公司）于2024年11月推出的开放协议，旨在标准化大语言模型（LLM）与外部数据源、工具之间的交互接口。其核心设计目标：\n解耦与标准化：将LLM与外部系统的集成从定制化开发转变为基于统一协议的通用连接，类似硬件领域的USB-C接口。 去中心化：通过允许开发者自主构建MCP Server，分散AI能力，避免单一厂商垄断知识和服务。 安全可控：通过权限验证和本地化部署，确保数据隐私与操作安全。 2. 从Langchain到MCP的技术演进 在MCP之前，开发者依赖如Langchain等中间层框架连接LLM与工具，但这些方案存在两大瓶颈：\n碎片化：不同厂商的API标准不统一，集成成本高； 封闭性：OpenAI等厂商的插件生态受限于自身平台，难以跨模型复用。 MCP通过协议层的抽象，将工具调用、数据访问等能力封装为标准化接口，使任何支持MCP协议的LLM均可无缝接入第三方服务。\n3. MCP的生态现状 现阶段，MCP生态已初具规模：\n头部公司支持：除了发起公司的claude，包括AI行业领军的OpenAI，在国内百度、腾讯等也均宣称支持MCP 开发者众多：因开发门槛低，当前公开的各类MCP Server已呈爆炸式增长态势，短短数周已有数千个公开Server，涵盖数据库、设计工具、支付系统等领域。 商业价值显现：a16z等机构已绘制MCP市场地图，预测其可能催生“Agentic AI领域的Stripe”级公司。 二、MCP Server有何作用？为什么它可能是AI行业的下一个风口？ 1. MCP Server的核心功能 MCP Server是MCP协议的具体实现，承担以下关键角色：\n工具代理：将外部API（如GitHub、PostgreSQL）转化为LLM可理解的标准化工具描述，例如将“创建GitHub Issue”抽象为函数调用。 数据网关：安全访问本地或云端数据，例如通过文件系统MCP Server让LLM读取桌面文件。 流程编排：支持多工具串联调用，例如先查询数据库再生成报告。 2. 成为风口的三大驱动力 （1）技术趋势：从“胖模型”到“瘦模型+生态” 传统“胖模型”试图将所有知识内化于参数中，导致训练成本高且时效性差。MCP架构下，LLM专注于语言理解，知识扩展与工具调用由MCP Server网络实现，形成“瘦模型+分布式能力”的新范式。\n（2）经济模型：创作者经济的AI化 MCP允许个人开发者通过构建MCP Server（如鸟类知识库）获得收益分成，形成去中心化的知识经济网络。例如，基于以太坊的OpenMCP.Network可通过智能合约实现调用量自动结算。\n（3）行业需求：企业私有化AI落地的刚需 企业可通过MCP Server将内部系统（如CRM、ERP）安全暴露给LLM，无需将敏感数据上传至云端。NineData等公司已推出数据库MCP Server解决方案，支持本地化数据管理。\n三、作为软件测试从业者，我们如何应用MCP Server？ 1. 测试场景的MCP化改造 （1）模拟外部依赖 通过构建Mock MCP Server，替代真实支付、第三方API等依赖项，实现测试环境隔离。例如，模拟支付宝接口返回异常响应，验证系统容错能力。\n（2）数据驱动测试 将测试用例存储在数据库或文件中，通过MCP Server动态读取并执行。例如：\n1 2 3 4 @mcp.tool() def load_test_cases(): \u0026#34;\u0026#34;\u0026#34;从指定目录加载JSON格式测试用例\u0026#34;\u0026#34;\u0026#34; return json.load(open(\u0026#34;test_cases.json\u0026#34;)) 测试框架可自动获取用例并生成测试报告。\n（3）AI辅助测试 利用LLM通过MCP Server调用测试工具，例如：\n自动生成测试脚本：根据需求描述生成Selenium代码； 智能分析日志：结合ELK Stack的MCP Server定位缺陷根源。 2. 测试从业者的技能升级建议 掌握MCP Server开发：学习Python/TypeScript的MCP SDK，构建定制化测试工具。 熟悉主流MCP生态：关注GitHub上的Awesome MCP Servers列表，了解测试相关服务（如PostgreSQL、JIRA集成）。 四、MCP Server的简单实现案例：桌面文件查询服务 1. 环境准备 安装Python MCP SDK：pip install mcp 创建项目目录：mkdir mcp-demo \u0026amp;\u0026amp; cd mcp-demo 2. 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 from mcp.server.fastmcp import FastMCP import os mcp = FastMCP() @mcp.tool() def list_desktop_files(): \u0026#34;\u0026#34;\u0026#34;获取当前用户桌面文件列表\u0026#34;\u0026#34;\u0026#34; return os.listdir(os.path.expanduser(\u0026#34;~/Desktop\u0026#34;)) if __name__ == \u0026#34;__main__\u0026#34;: mcp.run(transport=\u0026#39;stdio\u0026#39;) 此代码定义了一个MCP Server，提供list_desktop_files工具，允许LLM查询用户桌面文件。\n3. 客户端配置与测试 在Cursor编辑器的mcp.json中添加配置：\n1 2 3 4 5 6 7 { \u0026#34;mcpServers\u0026#34;: { \u0026#34;desktop\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;python server.py\u0026#34; } } } 启动服务后，我们可直接提问：“我的桌面有哪些文件？”，Cursor将通过MCP协议调用服务并返回我当前桌面上的文件清单，并按类型进行分类。\n结语 MCP Server正在重塑AI与物理世界的交互方式。对开发者而言，它是降低集成成本的利器；对企业而言，它是激活数据价值的钥匙；对测试从业者而言，它是自动化演进的新引擎。尽管生态仍处早期，但其标准化、去中心化的设计理念，已为AI行业的下一站指明了方向。正如Anthropic所言：“MCP不是终点，而是Agentic AI时代的起点。”\n","date":"2025-04-01T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/073-ai%E4%B8%8B%E4%B8%80%E7%AB%99-mcpserver/","title":"AI下一站 MCPServer"},{"content":"\n很多企业会把承担测试的工程师称为QA（quality assurance），但QA和Tester其实是两个不同的岗位，但不可否认，测试工程师的主要职责也是面向质量的，是通过评估质量状态来帮助团队进行质量改进的。\n但即便这样，测试工程师的工作就一定是对质量改进有帮助的吗？在实际工作中，有些误区反而会让测试人员的工作对质量产生负面影响。\n这里秋草梳理总结了测试人员可能伤害质量的十大误区，以及对应的正确做法。\n1. 测试的职责是发现并汇报Bug，但不是确认 误区：经常有开发同学和测试同学就某个问题是否应该报Bug进行争论， “需求中没要求”， “这个问题不影响用户使用” 等等是经常出现的理由。很多测试同学也确实会因为这些原因不再报这些问题，甚至在报Bug前会去和开发确认能不能报。\n这是一个对质量伤害极大的误区。测试的价值在于评估质量状态，而评估的关键在于独立性。质量没有对错，只有好坏。需求中没定义的行为，不代表就是不需要的；不影响用户使用也不代表就是好的实现。测试是站在评估质量的视角，指出缺陷或者提出优化建议都是分内工作。开发则负责分析、认定并解决缺陷。如果开发和测试在认定上有分歧，还有PO或业务分析师、CCB成员可以进行仲裁。\n但对于测试人员来说，汇报一切觉得有问题或者质量不好的产品行为则是工作义务。有意或无意去隐瞒或掩盖缺陷，才是对产品质量真正的伤害。\n2. 发现Bug只是开始，还应为修复Bug提供尽可能多的上下文 误区：有的测试同学会认为我发现了问题，并且也进行了报告，那么工作就已经完成，后续修复过程与我无关，只需修复后进行验证即可\n测试是整个软件产品研发生命周期中的一个环节，最终是为产品整体质量服务的。而Bug本身其实对产品是无价值的，因为只有解决掉的Bug才会对产品质量有帮助。 从这个角度来说，虽然报告Bug是测试人员的主要工作，但对产品来说，最终解决Bug才是目的。所以测试作为产品研发的一环，即便解决Bug不是测试直接负责，但我们也应该为解决Bug提供必要的支撑。\n这部分在之前地文章 【】中有详细探讨，大家有兴趣可以参阅\n3. 测试不只是验证需求 误区：测试只要将需求中明确定义的部分进行验证无误即可，未定义的部分无需测试\n这里和第一个误区有些关联，是很多开发和测试争论bug的前提。在前文 【】中我们对测试目标的认识误区中，也说过这一点。就是测试除了验证需求之外，还有更多探索性工作应该覆盖。测试并不止是检查。\n而除此之外，这里我还想更要强调产品的整体性、系统性。特别是在敏捷研发模式下，这个误区很容易被扩大。\n在敏捷中，敏捷迭代的输出是Increment（产品增量），这个对开发工作是成立的。但测试工作是面向整个产品系统的，并不能只覆盖增量部分。需求也是增量的，所以当然不能仅覆盖增量部分的需求，这就是为什么回归测试是测试中必须包含的范畴，也是自动化测试越来越受重视的根本原因。（关于敏捷相关的分析介绍可以参看之前敏捷系列）\n4. 测试无止境，好钢用在刀刃上 误区：要想更多发现Bug，尽量探索、发散，并利用Bug的集群效应，尽可能多地发现Bug\n还是在 【】一文中，我们也澄清过，测试的目标也并不是为了发现更多Bug。而且测试其实无止境的，测试最终的目的是对整个产品或系统提供一个可靠、完整的质量状态评估。而这个质量状态是否客观准确，跟Bug的多少其实并不一定是一个正相关的关系。\n测试在尽可能发现Bug的同时，还是认识到，我们是要系统地对质量进行评估，但测试又是无法穷尽的，所以必须要把有限的时间进行科学地分配，优先关注高优先的部分，比如新功能、代码出现变更、高风险模块这些都是应该优先进行测试并重点保证的部分。\n精准测试、基于风险的测试RBT等都是这种思路下，把我们的测试资源、时间优先放到高价值部分的实践。\n5. 测试工作不是提测才开展，从产品需求讨论就已经开始 误区：测试应该在产品提测以后才能正式展开，Bug也应该在提测以后才应该报告\n在当今，以上误区当然是不正确的，因为不管是测试左移还是各种测试理论都强调了测试早期参与的重要性。\n但理论归理论，实际实践中，测试通常还是在提测以后才真正开展工作。\n一方面是产品前期，测试的存在感低，参与度低，容易被忽视；\n另一方面，很多测试团队的考核重Bug数量，这其实更加消磨了测试早期参与的积极性，导致测试并不太愿意在早期协助团队暴露产品的问题。\n但从产品交付角度，越是后期，问题修复的成本就越高。所以从产品管理来说，摒弃以Bug考核的导向，引导测试前期的积极参与，测试可以发挥其对问题的敏感度，从需求讨论开始就能识别、考虑到很多异常场景，并帮助团队提前规避。\n6. 设计和架构讨论，测试不应是小透明 误区：架构和系统设计、详细设计是开发团队的任务，测试无需了解或参与讨论，等待产品开发完成后根据需求进行测试即可\n和上一条类似，测试左移并不只是说测试更多了解需求，同样也要求测试参与到设计、甚至编码环节。\n还是要谈测试的目标：是要尽可能准确评估出产品的质量状态。而质量必然是和产品的具体实现紧密相关的，对产品的实现细节了解得越清晰，那么在测试时就越能够有的放矢，也包括可以在设计、编码阶段就提前帮助团队规避质量问题。\n相反，如果对设计、代码完全是黑盒，很可能遗漏掉一些关键的测试场景导致问题泄露。\n不了解云应用的负载均衡机制实现，只在单节点上验证，就无法验证负载均衡失效导致的问题 不了解系统的缓存实现机制，就难以针对性地去构建缓存命中场景 不了解界面的响应式适配实现，就难以高效地进行完成兼容性测试 不了解接口的校验机制，就难以构造有效的接口测试数据 以上种种，都是测试不应该游离于设计环节之外，认为产品设计不属于测试范畴而忽略对这个环节的参与\n7. 独立的测试环境是充分测试的前提 误区：测试执行只需要关注产品本身，可以在集成环境甚至开发环境上进行测试，并不影响测试效果\n确实，测试的对象是产品本身。但测试环境其实是能否对产品进行全面、高效测试的一个关键制约。\n软件测试和探索过程中，对产品的使用，通常是很多不同的操作、交互的相互叠加。而在发现产品问题时，对问题的判断，一个重要的前提就是产品本身的相关前置条件、关联因素是清晰、明确的。而要保证这一点，一个独立、无干扰的测试环境就尤为必要。如果使用开发环境来进行测试，在测试同时，开发人员同时也在环境上进行调测、变更，不仅会增加大量无效问题的出现，也是对测试、问题定位等资源的极大浪费。\n除此之外，测试中，不可避免还有各种异常场景的营造，而一个独立的测试环境，更便于测试人员调整不同的测试场景，比如：\n修改网络配置，营造代理访问、内外部IP、弱网等场景 修改系统时间、定时任务触发、模拟不同时段数据等场景 模拟资源不足、空间占满、海量或巨大文件等场景 产品中的部分限制因素，开启Debug模式、不同的鉴权设定、各种配置变更 这些测试都是建立在一个独立、可控的测试环境基础上的。\n8. 自动化测试代码也是程序，像对待产品一样对待测试代码 误区：编写自动化测试，就是为了替代部分手工测试的执行，完成自动化代码部分的编写，让它能执行并覆盖相关用例即可\n自动化测试的目的确实是为了代替很多人工测试工作，达到效率提升的目的。但自动化测试的实施并非一锤子买卖，它也是一个长期的过程。而且自动化测试，本身也是通过程序代码来实现，是程序就会有bug，因此对自动化测试脚本、工具本身的质量保证和维护也是测试人员的重要工作。\n并不是我们编写出一个可跑的自动化脚本就是进行了自动化。对自动化脚本同样要像软件产品一样经过需求分析、设计、编码、测试以及后续的维护这样的生命周期。\n所以自动化测试本身也是一个较大投入，要让相关脚本长期发挥作用并真正起到提升执行效率的目的，那么对自动化测试代码的良好设计和持续维护就必不可少。\n9. CI/CD管道同样也是测试的职责 误区：CI/CD作为现在很多研发团队的基础设施，通常会有专门的DevOps工程师负责搭建、维护，作为测试人员，负责其中自动化测试部分脚本的编写即可\n诚然，整个CI/CD管道中，和测试直接相关的部分主要就是自动化测试。但还是那句话：测试作为整个研发过程的一分子，是不可能独立于研发过程之外的。特别是敏捷研发中，更加强调团队的整体性，团队整体对研发过程负责。\n所以CI/CD管道建立、运作和保持畅通的过程，并不存在明显的测试只需要负责自动化测试环节的说法。\n作为质量视角的专业人员，在CI/CD管道建设中，我们也可以发挥更多的作用：\n定义管道中各个环节流转的质量门禁，将测试左移反映到CI/CD管道中 代码变更的管控和识别，这部分对于测试阶段的精准测试，意义重大 包括开发环境、集成环境、测试环境以至线上生产环境的监控，特别是很多质量相关指标的收集实现 可视化，包括自动化测试报告、各种数据跟踪的状态呈现等 10. 珍惜所有了解终端用户使用场景的机会 误区：作为研发团队成员，测试无须主动接触终端用户。和用户对接更多是销售、售后、客服团队的工作\n测试工作面向质量，而质量的最终判断，其实是终端用户。所以很多团队都强调，测试是终端用户的代言人，是要站在用户视角来使用、体验产品并提前发现问题的角色。\n因此，从这个意义上，测试其实应该更多地去接触用户，了解用户使用产品的不同场景，诉求以至偏好。\n所以，在有机会接触用户的场景下，测试应该是主动而非抗拒。作为测试，这方面的机会还是比较多的，充分利用和用户接触的机会，丰富我们对于产品所属行业的理解并应用到我们的测试工作中来。\n用户问题支持。在一些反馈到研发团队的客户问题，需要提供技术支持时，作为测试，是经常会要直接面向客户的，这时也是我们直观了解用户对产品使用场景和面临问题的地方。 对外测试。很多用户在选择产品前，都会有针对产品的验收测试。这些测试往往在客户方进行，但产品测试人员往往会作为产品方来提供支持或实施测试，也就是外场测试。这也是一个很好的深入了解用户场景的窗口 客户拜访。有的企业在产品研发初期或过程中，会安排和终端客户的拜访、访谈，有时也会邀请研发团队参与，虽然大多情况下是系统分析师、架构等角色参与更多，但测试也会参与到此类拜访中，这是在初期就深入了解产品应用场景的一个绝佳机会。 行业报告。除了直接和终端客户的沟通外，关注产品所属行业的行业报告、资讯和趋势分析等资料，同样也是一个深入理解产品所处行业和用户的上佳渠道。 以上就是对测试人员伤害质量十大误区的梳理总结，欢迎大家讨论补充。 另外秋草关于测试技能体系化提升的课程，可以回复 “大纲” 或在公众号菜单中查看课程目录。\n","date":"2025-03-28T15:59:08+08:00","permalink":"https://chengxiaqiucao.github.io/post/071-%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E4%BC%A4%E5%AE%B3%E8%B4%A8%E9%87%8F%E7%9A%84%E5%8D%81%E5%A4%A7%E8%AF%AF%E5%8C%BA/","title":"测试人员伤害质量的十大误区"},{"content":"当下时代，AI浪潮呼啸而至，未来已来已不是一句空话。和AI相关的话题、讨论也成了科技圈的“流量密码”，从自动驾驶到智能客服，每个行业似乎都在蹭这波AI的热度。\n但作为测试从业者，我们在面对 AI 的快速发展时，大家更关心的可能是：AI在软件测试里到底能干啥？真的能帮我们提高产出、效率吗？或者发展下去，AI会否彻底替代测试岗位？\n本篇我们就来探讨下这个话题\nAI在软件测试不同阶段中的角色 AI测试，归根到底，还是希望它承担部分或者辅助、提升原来的测试工作，也就是说，AI本身，并不会改变软件研发的测试生命周期规律。\n所以，我们可以从软件测试生命周期的不同阶段，测试工作职责范围的角度，来看AI可以发挥哪些作用。\n需求分析阶段 这个阶段，我们可以基于AI的自然语言处理技术，对原始需求文档进行梳理，输出包括业务流程图、操作流图、数据流向等分析结果。\n同时也可以结合更多关联的本地数据，如历史Bug数据、测试日志、项目数据等，识别测试的优先级并构建风险模型，识别风险。并基于这些分析结果，帮助我们更合理地制定测试计划。\n测测试用例设计阶段 在软件设计和开发阶段，测试人员通常也会同步完成测试设计，这个阶段，我们可以利用 AI 帮助我们基于需求文档和需求分析阶段的成果，完成测试用例的生成，基于AI可以完成更多更充分的正向、反向用例以及各种边界条件以扩大覆盖范围。\n测试准备阶段 这阶段，最主要的工作是测试环境的搭建部署，可以利用AI能力结合CI平台实现测试服务器、数据库的环境智能化管理和资源的动态调配等工作。\n测试执行阶段 执行阶段，可以基于各种风险评估、依赖关系及业务影响等因素动态调整测试顺序，优先覆盖更高风险的模块，实现缺陷尽早暴露的目的。\n另外，也可以通过AI增强如日志分析、图像比对等能力，提升我们的测试执行效率和缺陷发现能力。\n测试报告阶段 在测试的收尾部分，利用AI针对各种过程数据的综合分析，可以帮助我们出具多维度的测试报告，为项目决策者提供结构化的测试状态分析。\n现阶段 AI 如何赋能软件测试 目前的AI的发展，已经可以在很多典型的测试场景下提供更多支持，以下梳理了可以通过AI赋能的一些典型场景\n智能数据生成：创建多样化数据集，覆盖常规场景与边缘用例 自动化测试：自动适应UI变更，保证自动化测试脚本稳定性 精准回归测试：基于代码变更智能选取关联测试用例 流程克隆：学习测试工作流后自动执行相似流程 动态等待机制：智能判断页面加载状态后执行操作 日志智能分析：分析、识别错误日志中的潜在问题模式 负载/性能测试：模拟真实用户行为、诊断性能瓶颈 持续测试监控：实时监测应用状态并预警异常 探索性测试支持：在探索测试过程中提供智能化建议 预测性分析：基于历史数据预测版本发布风险 引入AI的优势 AI 可以通过持续地学习、训练并不断提升，因此引入AI后，可以在以下诸多方面建立起优势：\n成本优化：可以降低人工成本，优化资源配置，加速产品上市 稳定可靠：确保测试的标准化执行与结果一致性 缺陷早筛：提前暴露问题，缩短修复周期 快速反馈：多环境并行测试，缩短反馈链路 高质量用例：自动生成单元测试、回归测试、API测试等多样化用例 应用AI依然存在巨大的挑战 人工智能还是“人工智障” AI的训练数据如果有偏差，结果可能离谱到让你怀疑人生。如果AI的训练结果不理想，那么AI的应用可能不仅无法提升效率，反而还会浪费大量额外的资源去校正它的执行结果。\n数据依赖症 AI 对于优质训练数据和各种参数调整的高要求，往往对具体行业的实际落地应用形成很大制约。\n维护成本比想象中高 不止是数据资源的投入，对本地数据集的模型训练也需要投入大量时间与资金，包括设备资源也是较大的开支。另外现阶段AI人才的缺口，也让AI应用的人力成本高出一大截\n经验和直觉，AI永远学不会 经验丰富的老测试人通过各种蛛丝马迹可以嗅出产品中一些隐性的缺陷，这种类似第六感的“玄学”，AI必然难以复制。\n助手还是对手？ “AI这么发展，测试工程师是不是要失业了？” 其实大可不必惊慌！\nAI的本质还是工具，就像通过自动化测试取代部分手工的校验一样，它只会改变部分工作方式，而非淘汰岗位。未来的测试人员更像是“AI训练师+策略指挥官”——我们需要做的其实就是：\n教会AI理解业务逻辑（比如什么是“正确的订单状态流转”）； 设计更聪明的测试策略（比如如何平衡自动化与探索性测试）； 解读AI的结果并决策（比如某个异常到底是Bug还是误报）。 AI就像扫地机器人，能帮你清理地面，但遇到顽固污渍（复杂业务场景）、家具布局变化（需求变更），还是得你亲自出马。\n结语：AI不是终点，而是新起点 AI在软件测试中的应用还处于起步期，我们可以看到它的巨大潜力，但还不到能完全信赖并放弃原有模式的时候。作为测试人员，与其焦虑“会不会被取代”，不如主动拥抱变化：学点机器学习基础知识，了解主流AI测试工具，甚至参与训练自己的模型。\n毕竟，未来的软件测试江湖，最吃香的肯定不是“最会点鼠标的人”，而是“最会和AI打交道的人”。你说呢？\n部分前文也探讨过AI的发展，参考阅读\nAI时代，程序员还有没有出路\n测试职业和其发展前景\n","date":"2025-03-25T21:38:36+08:00","permalink":"https://chengxiaqiucao.github.io/post/070-ai%E6%97%B6%E4%BB%A3%E7%9A%84%E6%B5%8B%E8%AF%95/","title":"AI时代的软件测试，助手还是对手？"},{"content":"随着 AI 技术的快速发展，从 ChatGPT 到 Deepseek 的爆发，AI已经可以切实起到辅助我们日常工作的作用。\n除了在具体的像辅助编程、文案编写等方面，我们也可以充分利用 AI 的强大逻辑能力和海量基础数据，帮助我们针对工作中的一些困境，提出切实可行的改进方案。\n但要想 AI 帮助我们给出有可操作性的解决方案，提示词的框架设计和提供给AI的上下文信息是极为关键的。一个良好的提示词框架，可以帮助我们快速得到极为有价值的参考。\n面对的困境案例 这里以一个比较普遍的敏捷团队质量困境的案例来说明：\n作为一个测试工程师，在一个运行Scrum框架的敏捷团队中负责质量保障，团队成员还包括SM、PO、2个Android开发（其中小李负责了App的整体系统设计），1个后端开发，1个非全职的视觉设计。团队产品是一个物联网智能手环产品的配套Android App。但因为存在和硬件团队的配合、需求经常变化、视觉设计不及时、提测不及时、Bug积压等问题，导致产品质量不乐观。目前App已经运行了多个迭代，按计划上线时间越来越近，如何针对当前的质量困境提出改进方案？\n设计提示词框架 要 AI 帮助我们给出有可行性的改进方案，首先我们要合理地设计提示词框架，以便最终给出的方案更贴合团队现状以及具备可操作性。\n那么设计的提示词框架要点：\n给定的角色，让 AI 确定从什么角度去提出改进方案 当前的现状，也就是充分的背景信息上下文 AI 应该具体分析的内容或它的任务应该是什么 希望 AI 提供的具体输出，包括格式要求，应包含的要素等 相关的一些制约因素，这对方案是否可行会有重要影响 现在针对上述困境，希望AI 能帮助我提供一份针对团队的整体质量提升方案，可以在回顾会上进行讨论。基于以上思路，通过向 Deepseek输入提示词框架，得到如下输出：\n质量改进方案（面向迭代回顾会） 1. 总体质量目标 \u0026ldquo;在2个迭代内将自动化测试覆盖率提升至40%，缺陷修复响应时间缩短50%，回归测试时间压缩30%，建立需求变更与测试联动的质量防线\u0026rdquo;\n2. 具体改进举措 举措 执行人 执行计划 效果评估方法 需求冻结机制\n- 每个迭代前3天锁定核心功能需求\n- 硬件对接需求由PO与硬件团队联合评审后形成接口文档 PO、硬件团队负责人 迭代计划会签署需求基线文档\n硬件接口文档通过Confluence共享 需求变更次数减少50%\n接口文档版本变更记录可追溯 自动化用例分级策略\n- L0级（核心业务流）：强制全自动化\n- L1级（高频使用场景）：优先自动化\n- L2级（边缘场景）：手动验证 测试工程师\n（主导）\nAndroid开发工程师\n（辅助） 使用Allure标记用例等级\n每日构建优先执行L0用例 L0用例100%通过率作为提测准出条件\n自动化执行时间减少40% 开发自测责任制\n- 开发提交代码需附带单元测试（覆盖率≥60%）\n- 接口测试由后端工程师在Swagger维护 Android开发工程师\n后端工程师 单元测试纳入代码评审检查项\nPostman接口用例与代码库联动 提测版本冒烟测试通过率提升至80%\n接口缺陷率下降30% 硬件兼容性Mock服务\n- 基于硬件协议开发模拟器\n- 自动化测试与真实设备解耦 测试工程师\n（主导）\n硬件团队提供协议文档 使用Python开发蓝牙协议模拟器\nJenkins构建时自动启动Mock服务 硬件依赖导致测试阻塞次数清零\n自动化稳定性提升至95% 缺陷分级管理\n- P0级缺陷：2小时内响应\n- P1级缺陷：当前迭代必须修复\n- 遗留缺陷需PO签字确认风险 测试工程师\n（分类）\n开发工程师\n（修复） Jira配置自动化缺陷流转规则\n每日站会同步TOP3缺陷进展 缺陷平均修复周期缩短至8小时\n积压缺陷数量下降60% 3. 风险及应对 风险 应对方案 开发人员抵触单元测试 - 由小李（系统设计师）示范编写单元测试\n- 将测试覆盖率纳入DoD完成标准 硬件协议频繁变更 - 要求硬件团队提前3天通知协议变更\n- Mock服务设计版本兼容机制 UE设计延迟影响UI测试 - 与UE设计师约定：视觉稿交付同时提供UI元素ID规范\n- 使用截图对比工具容差10%像素差异 4. 外部支持需求 类型 具体需求 工具 - 申请BrowserStack移动云测试平台license\n- 采购Xray测试用例管理插件License 人员 - 硬件团队指定协议对接接口人\n- DevOps工程师优化CI/CD流水线 培训 - 邀请单元测试专家开展TDD工作坊\n- Appium高级用法内部培训 5. 效果评估节点 节点 检验标准 迭代5中期 - L0级自动化用例覆盖所有核心业务流程\n- 单元测试覆盖率≥40% 迭代5结束 - 自动化覆盖率≥25%\n- 回归测试时间≤8小时/次 迭代6结束 - 自动化覆盖率≥40%\n- 生产环境致命缺陷数为0 执行要点说明：\n每日质量看板：在团队作战室悬挂自动化执行率/缺陷趋势图 质量门禁机制：代码合并请求必须通过L0用例+SonarQube检测 测试左移实践：测试工程师参与需求评审时即输出测试要点矩阵 该方案需团队全员签署质量承诺书，建议在迭代回顾会上通过\u0026quot;5Why分析法\u0026quot;就当前质量问题达成改进共识。\n可以看到，得到了一份极有针对性且有相当可行性的改进方案。我们根据目前的团队现状，进行微调其实就可以纳入实施。\n所以善用 AI 提示词框架，不仅可以帮助我们在具体事务上获取帮助，对于这种整体改进方面的举措，AI 也能提供巨大助力。\n回复 “提示词框架” 可获取上文的提示词完整示例。关于 AI 在工作中的更多应用实践，也欢迎大家留言或入群探讨！\n","date":"2025-03-19T22:44:42+08:00","image":"https://chengxiaqiucao.github.io/post/069-%E4%BC%98%E5%8C%96ai%E6%8F%90%E7%A4%BA%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E5%9B%A2%E9%98%9F%E6%8F%90%E5%8D%87/%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%A1%86%E6%9E%B6_hu_238e6f8c1f0255b2.png","permalink":"https://chengxiaqiucao.github.io/post/069-%E4%BC%98%E5%8C%96ai%E6%8F%90%E7%A4%BA%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E5%9B%A2%E9%98%9F%E6%8F%90%E5%8D%87/","title":"Deepseek提示词框架助力团队改进现状，效能提升"},{"content":"在之前的文章\n用deepseek+vscode自动完成测试脚本\n我们介绍了vscode的AI插件，可以帮助我们完成自动化测试用例的生成。\n而目前Deepseek 官方的API其实也重新开放，对于我们深度利用Deepseek等大模型打造贴合实际工作应用的场景，提供了更多可能性。\n下面我们就以 Deepseek 官方API的集成为例，完成在代码中通过调用大模型，实现测试用例自动生成，并完成执行的实践。\n首先从Deepseek官网进入它的API开放平台\n进入以后，申请一个APIkey，目前Deepseek的定价还是比较低的，而且特定时段还有较大折扣\n有了这个API Key以后，我们就可以在代码中进行调用了\n目前Deepseek API 是兼容了openai 的 api 接口\n通过以下代码，结合Python标准库inspect，我们可以直接让deepseek针对我们的被测代码，实现用例的生成。\n当然我们也可以将对应的需求文本传输给deepseek，原理类似\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import inspect from openai import OpenAI # 引入deepseek api client = OpenAI(api_key=\u0026#34;\u0026lt;your_deepseek_api_key\u0026gt;\u0026#34;, base_url=\u0026#34;https://api.deepseek.com\u0026#34;) # 被测函数，计算BMI def calculate_bmi(weight, height): if height \u0026lt;= 0 or weight \u0026lt;= 0: raise ValueError(\u0026#34;身高、体重必须大于0\u0026#34;) bmi = weight / (height ** 2) if bmi \u0026lt; 18.5: return \u0026#34;竹竿！\u0026#34; elif 18.5 \u0026lt;= bmi \u0026lt; 24.9: return \u0026#34;正常人\u0026#34; elif 25 \u0026lt;= bmi \u0026lt; 29.9: return \u0026#34;壮士！\u0026#34; else: return \u0026#34;肥宅！\u0026#34; # 通过inspect获取函数源代码 function_code = inspect.getsource(calculate_bmi) # 根据获取的代码，定义提示词 the_prompt = f\u0026#34;\u0026#34;\u0026#34; 请针对以下代码生成基于pytest框架的测试用例：{function_code} 尽可能使用参数化测试，包含各种异常场景 \u0026#34;\u0026#34;\u0026#34; # 调用deepseek api 使用V3模型，获取返回 response = client.chat.completions.create( model=\u0026#34;deepseek-chat\u0026#34;, messages=[ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a python testing assistant\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: the_prompt}, ], max_tokens=1024, temperature=0.7 stream=False ) print(response.choices[0].message.content) 通过以上代码，我们可以获取deepseek V3 返回的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 为了测试 `calculate_bmi` 函数，我们可以使用 `pytest` 框架，并结合 `pytest.mark.parametrize` 来实现参数化测试。以下是一个完整的测试用例，涵盖了正常情况和异常情况。 ```python import pytest # 导入要测试的函数 from your_module import calculate_bmi # 正常情况的测试用例 @pytest.mark.parametrize(\u0026#34;weight, height, expected\u0026#34;, [ (60, 1.75, \u0026#34;正常人\u0026#34;), # 正常BMI (50, 1.75, \u0026#34;竹竿！\u0026#34;), # 低BMI (80, 1.75, \u0026#34;壮士！\u0026#34;), # 高BMI (100, 1.75, \u0026#34;肥宅！\u0026#34;), # 超高BMI ]) def test_calculate_bmi_normal(weight, height, expected): assert calculate_bmi(weight, height) == expected # 异常情况的测试用例 @pytest.mark.parametrize(\u0026#34;weight, height, expected_exception\u0026#34;, [ (0, 1.75, ValueError), # 体重为0 (60, 0, ValueError), # 身高为0 (-10, 1.75, ValueError), # 体重为负数 (60, -1.75, ValueError), # 身高为负数 ]) def test_calculate_bmi_exceptions(weight, height, expected_exception): with pytest.raises(expected_exception): calculate_bmi(weight, height) ` `` ### 解释： 1. **正常情况测试**： - 使用 `pytest.mark.parametrize` 来测试不同的体重和身高组合，验证函数返回的BMI分类是否正确。 - 测试用例包括正常BMI、低BMI、高BMI和超高BMI的情况。 2. **异常情况测试**： - 测试函数在输入无效值（如体重或身高为0或负数）时是否抛出 `ValueError` 异常。 - 使用 `pytest.raises` 来捕获预期的异常。 ### 运行测试： 确保你已经安装了 `pytest`，然后在终端中运行以下命令来执行测试： ```bash pytest test_bmi.py ` `` ### 注意： - `your_module` 是包含 `calculate_bmi` 函数的模块名，请根据实际情况替换。 - 测试文件通常命名为 `test_*.py` 或 `*_test.py`，以便 `pytest` 自动识别并运行测试。 而为了进一步直接利用生成的结果，我们其实可以针对这里的输出，提取出markdown格式文本中的代码，写入一个测试文件，然后调用执行即可\n具体代码如下，利用正则表达式（正则表达式详细介绍，可参见前文 搞定正则表达式，告别新手村！）提取代码部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 用户配置 run_tests = True # 配置是否运行测试 # 如果需要运行测试，则将测试用例写入文件并执行 if run_tests: # 创建测试文件 test_file_name = \u0026#34;test_calculate_bmi.py\u0026#34; with open(test_file_name, \u0026#34;w\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;) as test_file: test_file.write(f\u0026#34;import pytest\\n\\n\u0026#34;) test_file.write(f\u0026#34;from ai_test import calculate_bmi\\n\\n\u0026#34;) pattern = r\u0026#39;```python([\\s\\S]*?)```\\n\u0026#39; test_code = re.findall(pattern, test_cases, re.DOTALL) test_file.write(test_code[0]) # 使用pytest执行测试 result = subprocess.run([\u0026#34;pytest\u0026#34;, test_file_name], capture_output=True, text=True) # 输出测试结果 print(\u0026#34;测试结果:\u0026#34;) print(result.stdout) print(\u0026#34;错误信息:\u0026#34;) print(result.stderr) # 可选：删除测试文件 # os.remove(test_file_name) 通过这种方式，我们就完成了通过deepseek自动生成用例并立即执行，输出结果的尝试。\n当然，案例比较简单，只是一个通过AI全自动完成单元测试的初步试验，具体应用还须更进一步地深入探索！\n","date":"2025-03-19T14:05:03+08:00","permalink":"https://chengxiaqiucao.github.io/post/068-%E4%BB%A3%E7%A0%81%E4%B8%AD%E9%9B%86%E6%88%90deepseekapi%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95/","title":"代码中集成deepseekAPI执行测试"},{"content":"软件测试中，8 种 ”能做，但不应该做“ 的工作 在软件测试中，我们常常会面临一个问题：很多工作确实是我们可以去做到的，似乎做这些事也理所当然，但很多时候，这些事情往往收效甚微。从过度自动化到频繁运行不必要的回归测试，不一而足。\n随着技术发展，测试人员手中拥有的工具让我们可以完成更多事情，但并不意味每个选择都是明智的。有些工作，盲目地去做，往往会影响真正重要的产出、效率、可维护性等要求。\n本文列举了在测试工作中八个“能做，但不应做”的工作。有时候，退一步可能是更聪明的选择。\n1. 自动化所有测试 可以做到： 现代的测试自动化工具让我们几乎可以自动化任何测试用例，从用户界面的每一次点击到API的每一次调用，技术上来说，都可以通过自动化来进行驱动。\n但不应该： 仅仅因为可以实现自动化测试，却并不意味它是最佳选择。比如：\n某个产品的用户界面非常动态，设计师每周都会进行调整。如果你选择将所有测试都自动化，每次UI改动后，相关的自动化测试都可能面临失效的风险。\n这种情况下，手动测试可能更有效。\n2. 自动化脚本中使用过于复杂的定位器 可以做到： Selenium, Playwright 等自动化工具中，借助XPath和CSS选择器，我们能够精确定位到页面中最深层的元素。\n但不应该： 过于复杂的定位器往往会让测试变得脆弱。比如：\n使用复杂的XPath去定位一个菜单，但当开发团队重构HTML结构后，往往导致多个测试失败，团队不得不花费大量时间修复。\n这时，其他方法可能对自动化用例的稳定性更为有效，比如和开发团队约定增加元素的 test-id 属性。\n3. 每次提交都运行完整的回归测试 可以做到： 在现代CI/CD管道中，每次代码提交都可以轻松触发完整的回归测试。\n但不应该： 但实际上，这种做法往往是过度的。想象一下，一个小的代码修复导致整个回归测试运行，而这个过程可能需要几个小时，甚至更长时间。\n如果在没有将自动化覆盖率提升到一定程度的团队，这种提交后进行完整回归更是噩梦。更好的做法，其实还是及时掌握变更内容，并根据变更和影响实现精准测试。\n4. 在API测试中过度模拟 可以做到： 模拟API响应可以大幅提高测试速度，消除对外部服务的依赖。\n但不应该： 然而，过度模拟会让我们失去与真实环境的连接。大量的Mock API 确实可以提升调试和验证效率，但却背离了真正的测试需要。真实场景下的测试是不可或缺的，就像我们不能预知所有的异常一样\n5. 为琐碎问题撰写极其详细的缺陷报告 可以做到： 借助辅助测试工具，我们可以捕捉到类似很多细小的UI层、提示信息等缺陷，也可以按照用例规范编写极为详尽的缺陷报告。\n但不应该： 并不是每个小问题都值得进行事无巨细地全面报告。发现Bug的目的最终是为了解决bug而不是bug本身，况且Bug的价值也有高下主次之分。我在 【】中其实对好的缺陷报告进行过分析，缺陷报告的价值是作为和开发沟通的渠道，报告八股文本身并无价值。\n6. 在没有人工监督的情况下使用AI生成测试用例 可以做到： AI的发展，其实已经可以做到，利用AI工具，基于需求文档快速生成大量测试用例，覆盖大量场景。\n但不应该： 然而，现阶段的AI，特别是针对特定的业务，缺乏人类的上下文理解以及各种内部沟通获取的综合信息，因而可能导致用例冗余或遗漏关键测试用例。\n7. 在测试中过多地使用断言 可以做到： 结合自动化工具和AI，我们确实可以做到在一个测试中验证大量字段、属性和UI元素。\n但不应该： 然而，过多的断言只会让测试变得巨大且复杂，难以调试。当部分断言失败，往往需要耗费大量的精力去排查\n8. 在每个可能的设备和浏览器组合上执行测试 可以做到： 针对兼容性测试，现代的跨浏览器和跨设备测试工具让我们能够在许多操作系统和设备上运行测试。\n但不应该： 测试所有可能的组合既不必要也不切实际。重点是覆盖用户实际使用的关键场景。而且开发技术的发展如响应式编程等，也大大减少了兼容性问题的风险。\n结语 在软件测试中，“有能力做” 却并不总意味着是最佳选择。我们需要在技术能力和实际可行性之间找到平衡。通过避免这些“因为可以做到”的陷阱，去建立一个精简、高效且真正有价值的测试集，对产品的质量保障更有意义。\n欢迎关注秋草，持续带来更多软件质量相关技术干货！\n","date":"2025-03-18T16:49:04+08:00","permalink":"https://chengxiaqiucao.github.io/post/067-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%8F%AF%E5%81%9A%E4%BD%86%E4%B8%8D%E5%BA%94%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E9%99%B7%E9%98%B1/","title":"软件测试中\"可做但不应做\"的一些陷阱"},{"content":" 前言 在进行软件测试，比如针对一个电商网站，你是否遇到过这些问题？\n动态加载的商品列表：部分商品因缺货、促销结束或未登录状态被隐藏。 悬浮显示的促销标签：仅当用户鼠标悬停时才会展示优惠信息。 广告弹窗干扰：某些弹窗可能遮挡核心功能，但测试时需要确保主流程不受影响。 这些场景的共同点是：页面元素可能存在于DOM中，但用户实际不可见， 比如设置CSS属性（display: none、visibility: hidden）。传统测试方法需要手动判断元素可见性，遍历或预先这对具体对象进行分支判断，比较复杂。\nPlaywright 最新版本提供了一个简化方法 在最新更新的 Playwright V1.5.1 版本更新中，针对locator.filter()方法新增了visible选项，可以极大简化这部分操作。（目前针对node.js有此更新，Python语言尚未支持）\n其核心作用是：\n仅筛选页面上用户实际可见的元素，自动忽略因CSS（如display: none）或布局原因隐藏的元素。\n技术原理：\nPlaywright通过计算元素的布局边界、透明度、层叠上下文等属性，判断元素是否在视口内且对用户可见。这与真实用户视角完全一致，避免因操作隐藏元素导致测试失败。\n场景实战：过滤可见商品 假设我们测试一个中文电商平台的**“限时秒杀”页面**，其HTML结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;限时秒杀\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;seckill-list\u0026#34;\u0026gt; \u0026lt;!-- 可见商品 --\u0026gt; \u0026lt;div data-testid=\u0026#34;product-item\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;【爆款】无线蓝牙耳机\u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;促销价: ¥199\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;立即抢购\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div data-testid=\u0026#34;product-item\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;智能手环\u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;促销价: ¥299\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;立即抢购\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 隐藏商品（已抢光或未开始） --\u0026gt; \u0026lt;div data-testid=\u0026#34;product-item\u0026#34; class=\u0026#34;product\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;家用投影仪\u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;促销价: ¥899\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;已售罄\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div data-testid=\u0026#34;product-item\u0026#34; class=\u0026#34;product\u0026#34; style=\u0026#34;opacity: 0;\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;空气炸锅\u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;price\u0026#34;\u0026gt;促销价: ¥399\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;未开始\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 需求场景 用户访问“限时秒杀”页面时，仅展示可抢购的商品（前两项），隐藏已售罄或未开始的商品。我们需要验证：\n页面中用户可见的商品数量是否正确。 “立即抢购”按钮仅对可见商品生效。 新旧方案对比 旧方法：手动遍历+可见性检查 1 2 3 4 5 6 7 8 9 10 11 12 13 // 旧方案示例 import { test, expect } from \u0026#39;@playwright/test\u0026#39;; test(\u0026#39;验证可见商品数量\u0026#39;, async ({ page }) =\u0026gt; { await page.goto(\u0026#39;https://mall.example.com/seckill\u0026#39;); const allProducts = await page.getByTestId(\u0026#39;product-item\u0026#39;).all(); let visibleCount = 0; for (const product of allProducts) { if (await product.isVisible()) { visibleCount++; } } expect(visibleCount).toBe(2); // 断言可见商品为2个 }); 痛点：\n需要手动遍历所有元素，代码冗余。 若商品数量动态变化（如分页加载），维护成本高。 新方案：一行代码过滤可见元素 1 2 3 4 5 6 7 8 9 10 // 新方案示例 import { test, expect } from \u0026#39;@playwright/test\u0026#39;; test(\u0026#39;验证可见商品数量\u0026#39;, async ({ page }) =\u0026gt; { await page.goto(\u0026#39;https://mall.example.com/seckill\u0026#39;); const visibleProducts = page.getByTestId(\u0026#39;product-item\u0026#39;).filter({ visible: true }); // 断言可见商品数量为2 await expect(visibleProducts).toHaveCount(2); // 断言所有可见商品均可点击“立即抢购” await expect(visibleProducts.getByText(\u0026#39;立即抢购\u0026#39;)).toHaveCount(2); }); 优势：\n代码简洁：无需循环，直接通过链式调用过滤。 实时匹配：自动响应页面动态变化（如AJAX加载新商品）。 精准断言：结合Playwright的软断言（Soft Assertions），可同时验证多个条件。 扩展应用：电商测试中的常见场景 场景1：验证悬浮显示的促销标签 某些商品的“限时折扣”标签仅在鼠标悬停时显示。通过visible: true可确保仅操作实际可见的元素：\n1 2 3 4 5 // 鼠标悬停后，验证促销标签可见 const productCard = page.getByTestId(\u0026#39;product-card\u0026#39;).filter({ visible: true }).first(); await productCard.hover(); const discountTag = productCard.getByText(\u0026#39;限时5折\u0026#39;); await expect(discountTag).toBeVisible(); 场景2：过滤弹窗干扰 若页面存在广告弹窗，可通过visible: true跳过隐藏的弹窗元素：\n1 2 3 4 5 // 关闭可见的弹窗（忽略已隐藏的） const activePopup = page.getByTestId(\u0026#39;popup\u0026#39;).filter({ visible: true }); if (await activePopup.isVisible()) { await activePopup.getByText(\u0026#39;关闭\u0026#39;).click(); } 结语 通过这个 Playwright 更新的实用功能，可以较大简化我们在进行自动化测试时编写的复杂度，也可以看到，作为势头正劲的新一代web测试工具，Playwright的不断升级优化还是很贴合实际且社区活跃，值得重点关注！\n秋草也推出了一个 基于Pytest+Playwright的自动化框架实战课程，有兴趣的同学可关注：\n","date":"2025-03-16T13:32:58+08:00","image":"https://chengxiaqiucao.github.io/post/066-playwright%E6%96%B0%E7%89%88%E6%9C%AC%E7%AD%9B%E9%80%89%E5%8A%9F%E8%83%BD/playwright_logo_hu_73c74ac3fbcd168.png","permalink":"https://chengxiaqiucao.github.io/post/066-playwright%E6%96%B0%E7%89%88%E6%9C%AC%E7%AD%9B%E9%80%89%E5%8A%9F%E8%83%BD/","title":"Playwright新版本筛选功能"},{"content":" 很多想往测试方向转的非IT从业者，道听途说软件测试门槛低，就算不会写代码也可以进入这个行业工作。那么是不是这样呢？\n应该说：\n没代码能力，要从事软件测试，实际上可以做，但实际上又不能做。\n实际上可以做 软件测试并不是一个建立在代码能力上的技术，所以说实际上可以做。\n软件测试是通过测试，暴露出产品中的质量问题，其实是一个发现未知的技能。所以更关键的是试验、探索、观察、推理、设问、建模这些方面的能力；而有代码能力，更多是能去帮助自己理解产品的实现过程，或者可以通过代码帮助自己扩展测试手段、去提升测试效率，从这个意义上，代码能力是一个辅助能力，用来辅助测试工作，但它并不是决定测试工作是否能完成的的关键！\nJames Bach在论文 《testing and checking》 中，阐述了 测试 和 检查 的关系\n测试是一个更大范围的概念，而检查只是测试的子集，并且检查还分为人工检查和借助机器（工具）来检查。\n而代码能力，影响的部分，更多是在利用工具检查这部分。\n所以早年，很多测试工作做得出色的测试专家，其实并不长于编码，但多半是相关业务领域的业务专家，且有出色的测试思维，也就是上面说到的类似侦探那样的观察、推理等能力。\n所以说，实际上，没有代码能力，并不影响是否能把测试工作做到出色。\n实际上不能做 但是，我们还要说，没有代码能力，实际又不能做。\n上面我们也说了，早年，还存在不会代码的测试专家。时移事易，当下的现状其实不一样了。随着行业发展，测试这个行当的方向可以说已经脱离了原先轨道。挺可悲可叹！\n原因多种：\n敏捷研发等强调快速交付的研发模式流行 在敏捷研发模式中，其实已经不再有专门的测试角色，更多强调团队成员是多面手，各种研发任务可以一专多能，包括开发和测试！测试人员作为团队一份子，自然也就不能仅仅只能做测试，必要时也要能接手开发，至少包括单元测试、集成测试等原来开发范畴的工作也要去承担。当然代码能力就是满足这个条件的硬性要求了\n对自动化测试能力的强制要求 也是因为敏捷，持续集成等研发模式的需要，自动化测试成为其中必不可少的环节。而作为自动化测试的基础能力，代码能力自然也就是必然。\n但这里必须要指出，像自动化测试这种，为了“快速完成测试”，按上图测试和检查的关系，实际上并不是真正的“测试”，更多是“检查”。一味强调代码能力，某种意义其实是对测试工作要求的弱化，也就是更多只要求了“检查”，而不是“测试”\n人才市场供大于求 最后，还是行业环境。在早年互联网兴起阶段，人力缺口大，很多“验证” 工作也是由不需要代码能力的初级或者0基础小白去人工完成，人工“检查”比重更大。\n但行业下行时，企业压缩成本，导致人才市场供大于求。所以入行门槛自然会抬高，从业要求也水涨船高，对工具“验证”的期望也更高，所以代码能力，自动化测试、工具开发等等几乎已经就成了必备技能。\n再叠加当下敏捷研发等研发模式的流行，对自动化测试的要求，可以说，没有代码能力，在当前环境下，实际上已经很难说还可以从事测试工作，无门可入。\n结语 所以，目前情况下，对于测试工作，虽然没代码能力，不代表不能完成测试工作，但不具备代码能力却已很难搭上车\n所以，作为个体，时代洪流下，能做的就是不要逆时而行，踏实去构建顺应潮流的个人能力。 但还是要理解这个工作的核心要求是什么，厚积薄发，吹尽黄沙始到金！\n","date":"2025-03-15T00:04:55+08:00","image":"https://chengxiaqiucao.github.io/post/065-%E6%B2%A1%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B%E8%BF%98%E8%83%BD%E5%90%A6%E4%BB%8E%E4%BA%8B%E6%B5%8B%E8%AF%95%E5%B7%A5%E4%BD%9C/Pasted-20250316_hu_2747a21241c6353f.png","permalink":"https://chengxiaqiucao.github.io/post/065-%E6%B2%A1%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B%E8%BF%98%E8%83%BD%E5%90%A6%E4%BB%8E%E4%BA%8B%E6%B5%8B%E8%AF%95%E5%B7%A5%E4%BD%9C/","title":"没代码能力还能否从事测试工作"},{"content":"前言 在本系列上一篇 【】，我们介绍了 Linux 三剑客中的 grep 命令用法。而实际上，在三剑客中，grep 只能算是小弟，它的作用更多只是通过正则表达式的加持，实现针对文本的模式查询。 而三剑客中，真正重量级的命令是 sed 和 awk, sed 其实是 stream editor（流编辑器） 的缩写，因此，sed 命令它其实是能够起到文本编辑器的作用。本篇我们就来介绍这个 伪装成Linux命令的编辑器 sed\nsed 命令概述 sed命令的语法如下：\n1 sed -命令参数 \u0026#39;操作指令\u0026#39; 文本文件或管道输入 sed 是一个行编辑器，这里的操作指令会按行来对文本进行处理\n命令参数 它的命令参数主要有如下一些：\n命令参数 含义 -n 关闭默认输出 -r 支持正则表达式扩展 -i 直接对源文件进行操作 -e 指定操作指令（默认开启，可指定多个） -f 从文件读取操作指令 默认输出 1 2 sed \u0026#39;/root/p\u0026#39; /etc/passwd # 其实会显示passwd文件中所有行，其中包含root用户的行重复显示 1 2 sed -n \u0026#39;/root/p\u0026#39; /etc/passwd # 加上-n参数，才会关闭sed本身的默认输出，这样才是通过p指令显示匹配的行 修改原文件 实际工作中，-i 参数是一个比较危险的参数，因为这个参数会直接修改原文件\n1 2 3 sed -i \u0026#39;/root/q\u0026#39; /etc/passwd # 这个操作会导致passwd文件中只包含有root用户这一行，因为指令q会在匹配到行后直接退出 # 而sed这时的输出内容会直接写入原文件 比较安全的做法，可以在使用-i参数时指定一个备份文件, 也就是在 -i 后指定一个备份文件的后缀名\n1 2 sed -i.bak \u0026#39;/root/q\u0026#39; /etc/passwd # 这个操作虽然还是会修改passwd文件，但在修改前会备份一个.bak文件，便于恢复 多重指令 sed 命令的指令可以有多个，但又多个指令时，需要为每个指令指定一个-e参数，如果只使用 1 个指令，则这个 -e 可以忽略\n1 2 sed -e \u0026#39;=\u0026#39; -e \u0026#39;/root/q\u0026#39; /etc/passwd # = 指令会输出当前处理行的行号 如果我们想重复指定 -e ，也可以通过 ; 组合指令\n1 2 sed \u0026#39;=;/root/q\u0026#39; /etc/passwd # 和通过 -e 多重指定效果一样 操作指令说明 在上面的参数介绍中，我们其实已经使用了 如 p, q 等指令。\n而这个操作指令，其实是由两部分组成，也就是寻址部分和操作部分：\n寻址： sed命令是行处理命令，寻址其实就是指定要处理的行 操作： 针对匹配寻址规则的行要执行的操作 寻址规则 寻址格式 含义 数字 指定行号匹配 m~n 从m行开始，按步长n匹配 $ 匹配末行 /regex/ 按正则匹配 m,n 从m行开始，匹配到n行 m,+n 从m行开始，再匹配n行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sed -n \u0026#39;5p\u0026#39; /etc/passwd # 显示第 5 行内容 sed -n \u0026#39;2~3p\u0026#39; /etc/passwd # 显示从第2行开始，步长3递进，即第 2,5,8,11,14.... 行内容 sed -n \u0026#39;$p\u0026#39; /etc/passwd # 显示最后一行内容 sed -n \u0026#39;/qiucao/p\u0026#39; /etc/passwd # 显示包含qiucao的行内容 sed -n \u0026#39;5,8p\u0026#39; /etc/passwd # 显示第 5 行到第 8 行内容 sed -n \u0026#39;5,+5p\u0026#39; /etc/passwd # 显示第 5,6,7,8,9,10行内容 操作指令 操作指令 含义 p 打印匹配行 = 输出匹配行行号 l 打印匹配行并显示不可见字符 s 正则表达式匹配和替换 c 匹配行整行替换 a 在匹配行后追加内容 i 在匹配行前追加内容 d 删除匹配行 r 在匹配换行后追加内容（从文件中） w 将匹配行内容写入文件 q 匹配后退出，不再继续匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 sed -n \u0026#39;=;5p\u0026#39; /etc/passwd # 显示所有行号并打印第 5 行内容 sed -n \u0026#39;=;5l\u0026#39; /etc/passwd # 和上条命令类似，但行末的结束符($)也会打印出来 sed -r \u0026#39;=;s/^m\\w*/test/g\u0026#39; /etc/passwd # 替换所有以m开头的用户名为test, 加/g的作用是在行内替换所有匹配字符，否则只替换第一个 sed \u0026#39;=;5c\\测试一下\u0026#39; /etc/passwd # 将第5行替换为 “测试一下” sed \u0026#39;=;5a\\测试一下\u0026#39; /etc/passwd # 在第5行内容后追加一行 sed \u0026#39;=;5i\\测试一下\u0026#39; /etc/passwd # 在第5行内容前插入一行 sed \u0026#39;=;5d\u0026#39; /etc/passwd # 删除第5行 sed \u0026#39;=;5r test.txt\u0026#39; /etc/passwd # 从test.txt中读取一行并添加到第5行后 sed \u0026#39;=;5w test.txt\u0026#39; /etc/passwd # 将第5行内容写入到test.txt 模式空间和保留空间 上面介绍的操作指令，主要是针对行内操作的一些指令。 我们既然说 sed 其实是一个编辑器，那么对于多行的文本编辑操作，比如整行的复制、粘贴、剪切等，当然也是支持的。\n这就要说到 sed 命令处理时，预留的两个内存空间了：\n模式空间： 存储当前处理行的内容，每完成一行的处理，处理完的内容放到这个空间中 保留空间： 用于临时存储数据，可以认为是像剪切板一样的一个缓存空间，用于不同行内容的交换。初始默认只有一个 \\n 回车符 操作指令 用法 h 将模式空间内容复制到保留空间，替换原内容(\\n) H 追加模式空间内容到保留空间 g 保留空间内容复制到模式空间，覆盖原内容 G 保留空间内容追加到模式空间原内容后 x 交换模式空间和保留空间内容 n 立即读取下一行，并复制到模式空间 N 立即读取下一行，并追加到当前模式空间（常用于行合并） 示例 1 2 3 4 5 sed \u0026#39;=;2h;3H;5x;8G\u0026#39; /etc/passwd # 2h复制第2行到保留空间 # 3H复制第3行并追加到现有保留空间后 # 5x将当前模式空间和保留空间进行交换，复制的内容替换了原第 5 行的内容 # 8G将保留空间内容（原第5行模式空间内容）追加到当前模式空间即第8行内容后 常用 sed 实操案例 1. 删除空白行 1 2 sed -i \u0026#39;/^\\s*$/d\u0026#39; test.txt # 正则匹配仅包含空白字符的行并删除 2. 给文件添加行号 1 2 3 sed \u0026#39;=\u0026#39; test.txt | sed \u0026#39;N;s/\\n/\\t/\u0026#39; # 先用sed命令获取行号，或加到每行默认输出前一行 # 通过管道传递到后一个sed命令，通过 N 指令合并两行，并将 回车符替换为制表符 3. 提取所有图片链接 1 2 sed -nr \u0026#39;s/.*src=\u0026#34;(.*\\.png).*/\\1/p\u0026#39; source.html # 正则表达式匹配图片链接，利用正则表达式分组保存路径并替换原有整行内容 4. 提取log中异常行 1 2 sed -n \u0026#39;/ERROR/{=;p}\u0026#39; app.log # 匹配日志中包含ERROR字样的行并打印输出行号 结语 以上就是关于 linux 三剑客之 sed 命令的系统梳理，后续还会继续带来 awk 命令的总结！ 更多测试扩展技能，欢迎关注秋草的体系化提升课程，回复 大纲 获取详细目录。\n","date":"2025-03-13T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/061-linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-sed/sed3_hu_24fe0cd776a0109c.webp","permalink":"https://chengxiaqiucao.github.io/post/061-linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-sed/","title":"Linux文本处理三剑客 Sed"},{"content":"前言 正则表达式 （Regular Expression） 是一种强大的文本模式描述语言，可以通过简洁的符号组合描述复杂的字符串匹配规则。被广泛应用于数据验证、文本提取、日志分析等领域，在我们日常工作中发挥着重要的作用。\n软件行业从业，是否掌握正则表达式的使用，往往是区分菜鸟和老手的重要标识。 本文我们结合一些具体案例，详细梳理下正则表达式的应用，早日告别新手村！\n正则表达式核心语法 学习正则表达式， 这里推荐一个非常直观的线上验证平台， https://regex101.com , 对于我们练习和掌握正则语法非常有帮助。\n普通字符和特殊字符 正则表达式作为一个匹配规则。当然首先可以匹配各种普通字符。主要指各种中英文单词、字母、数字。此外正则表达式还会预留很多特殊字符，如 * ? + . () [] $ ^ \\ | 等，代表一些特别的匹配规则，而如果这些特殊字符我们需要看作普通字符进行匹配时，则需要使用 \\ 符号进行转义，因此 \\ 也称转义符。比如 \\? 就会匹配目标文本中的 ? 字符， \\\\ 则会匹配目标文本中的 \\ 字符\n量词符（quantifiers） 量词符是用于控制匹配次数的符号：\n* 零次或多次（如 a* 可匹配 \u0026ldquo;\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;） + 一次或多次（a+ 必须至少有一个a） ? 零次或一次（a? 可匹配 \u0026quot;\u0026quot; 或 a） {n} 精确匹配n次（{4} 匹配4次） {m,n} 匹配m到n次（含边界） {m,} 匹配m到多次 {,n} 匹配零次到n次 另外，在正则表达式中，还有两种匹配模式\n贪婪模式：这是默认模式，也就会在目标文本中，尽可能最长地去匹配符合规则的字符 惰性模式：而如果在量词后加?则标记以惰性模式进行匹配，也就是尽可能少地去匹配符合规则的字符 举例来说：\n浮云长长长长长长长消\n这个上联中有 7 个 长 字，正则表达式 长{2,3} 默认按贪婪模式匹配，会匹配到 2 次 长长长， 而加上 长{2,3}? 则会按尽量少的字符匹配，匹配到 3 次 长长\n元字符（Metacharacters） 除量词符外，还有一类元字符，被预留构成正则表达式的基础特殊符号：\n\\d 匹配数字（等价于 [0-9]） \\D 匹配非数字 \\w 匹配单词，包括字母、数字和下划线（等价于 [A-Za-z0-9_]） \\W 匹配非单词 \\s 匹配空白符（空格/制表符/换行符） \\S 匹配非空白 . 匹配任意单个字符（默认不匹配换行符） | 表示逻辑\u0026quot;或\u0026quot; 位置限定符（Position Anchors） 用于精准定位匹配位置：\n\\b 匹配单词边界（如 \\bcat\\b 匹配完整单词） \\B 匹配非单词边界 ^ 匹配目标文本开头，多行模式下也匹配行首 $ 匹配目标文本结尾，多行模式下也匹配行尾 举例来说: 在tester is good at testing 中，用 ^test 就只会匹配到行首的 test， 但testing 中的test 就不会匹配到， 而如果 test\\b，同样匹配不到任何结果，因为这段文本中 test都不是单独的单词，test 后不存在单词边界\n字符类（Character Classes） 字符类用于批量匹配特定字符集合：\n[abc] 匹配a/b/c中的任意字符 [^abc] 匹配不在集合中的字符 范围表示法：[a-z]（小写字母）、[A-Z]（大写字母）、[0-9]（数字） 下例中 [b-f]， 就只匹配了目标字串中的 d,e\n分组（Groups） 分组是正则表达式中重要的技巧，用于对匹配规则进行分组，便于在后续的文本处理中提取匹配到的内容。 分组通过在表达式中将模式用 () 框定来表示。\n比如指定一个字串\n1 this is a \u0026#34;testtest\u0026#34; string to demo regex group! 分组及其引用 分组默认从 1 开始计数，也就是多个分组时，可以按顺序以 \\1 \\2 来反向引用分组\n这个例子，我们 通过 (is)(\\s)\\1\\2 指定了两个分组，组1 匹配 \u0026ldquo;is\u0026rdquo;， 组2匹配空白字符（这里是空格) ，然后用\\1\\2 分别引用这两个组，最终其实就匹配了 \u0026quot;is\u0026quot;+空格 连续出现了两次的情况\n指定分组不进行引用 如果我们进行分组时，某个分组我们并不想在后续引用，那么可以使用 (?:pattern) 来进行标记，指定当前分组在后续不会进行引用。 这时分组默认的提取序号中，就会忽略这一组不进行编号 。\n上例中，如果我们指定其中第二个分组不进行引用\n1 (is)(?:\\s)\\1\\2 这时其实上例中的正则表达式就出现语法错误，无法完成匹配，因为这时第二个分组被忽略，而 \\2 进行引用，这时就会因为不存在出现模式错误\n对分组进行注释 一些复杂的正则表达式，我们还可以在分组添加注释，起到对正则表达式进行说明的作用 (?#comment)(other group)\n分组命名 除了默认用数字序号来引用分组，也可以通过给分组进行命名的方式： (?P\u0026lt;name\u0026gt;pattern) 进行命名。 然后用(?P=\u0026lt;name\u0026gt;)进行引用\n综合上面的说明，使用如下正则说明\n1 (?#这是一个嵌套分组示例)(?P\u0026lt;demo\u0026gt;t(?:\\w*)t)(?P=demo) 断言（Assertions） 断言主要用于判断，用来匹配符合模式的字符所在位置。因为它主要用判断位置，不会消费字符，所以一般也叫 零宽断言\n断言可分为4类，还是用上例中的文本举例\n1 this is a \u0026#34;testtest\u0026#34; string to demo regex group! 正向肯定断言 判断匹配位置之后的字符符合模式， 通过(?=pattern) 来进行断言\n示例：\n正向否定断言 判断匹配位置之后的字符不符合给定模式， 通过(?!pattern) 来进行断言\n示例：\n反向肯定断言和反向否定断言 和正向相对，反向断言匹配的是预期位置之前的字符是否符合模式，也有肯定和否定之分。在 ?后再添加一个\u0026lt;表示反向， 即(?\u0026lt;=pattern) 和 (?\u0026lt;!pattern)\n匹配模式 除了上述正则表达式的主要匹配规则外，正则表达式还有一些匹配模式。是用 \\ 加上一些特殊的字母代表不同的模式\n\\g 表示全局匹配，也就是会在给定的文本中匹配所有符合条件的字串，如果不指定，则仅匹配出现的第一个符合模式的字串 \\m 多行模式，主要是指定 ^ $是否匹配行首行尾 \\i 匹配时忽略大小写 \\x 匹配时是否忽略我们模式文本中的空白，在编写比较复杂规则时较为有用 \\s 指定 . 匹配字符时包含换行符 \\u 匹配unicode字符，如中文 \\a 仅匹配ascii字符 实用案例 针对下面这段文本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 用户注册信息如下： 联系电话：+86 138-0013-8000（北京） / 400-800-8888（全国客服） 电子邮箱：support@example.com / service@sub.domain.org.cn / user.name+tag+sorting@example.co.uk 网站链接： https://www.example.com/page1.html?query=123\u0026amp;sort=desc#section2 http://sub.example.co.jp:8080/admin/dashboard ftp://ftp.example.org/upload.zip 产品序列号：SKU-20240309-001234（生产日期：2024-03-09） INV-2023-Winter-Sale-0456（有效期至：2024-01-31） 活动时间：2024年第一季度（2024-01-01 至 2024-03-31） 特殊字符测试：!@#$%^\u0026amp;*()_+-=[]{}|;\u0026#39;:\u0026#34;,./\u0026lt;\u0026gt;?`~ 测试用密码：Password123!@#（正确） / password123（错误） / Passw0rd!（错误） 日志条目：ERROR[2024-03-09T15:40:22+08:00] 用户登录失败 IP地址记录： 192.168.1.1 / 203.0.113.255 / ::1 / IPv6-Test-Address::FFFFF:1234 匹配完整URL（含协议、域名、端口、路径） 1 ^(https?:\\/\\/)([\\w\\-\\.]+\\.[a-z]{2,6})(:[0-9]{1,5})?(\\/\\S*)?$ 匹配结果：\n提取电话号码 1 \\b(\\+?\\d{2,3})[-\\s]+?(?:\\d{3,4}[- ]?)+ 说明：首先\\b匹配单词边界，用分组提取国家码（2-3位，兼容有+情况），跟-或空格，惰性模式，再匹配3-4个数字和-连续多次出现的情况\n匹配结果：\n+86 138-0013-8000 400-800-8888 验证电子邮箱地址 1 [-.\\w]+@[-.\\w]+\\.[-.\\w]+\\b 匹配结果：\nsupport@example.com service@sub.domain.org.cn sorting@example.co.uk 捕获产品序列号（包含日期和唯一编码） 1 SKU-\\d{8}-\\d{6}|INV-\\d{4}[-A-Za-z]+-\\d{4} 匹配结果：\nSKU-20240309-001234 INV-2023-Winter-Sale-0456 匹配中文 1 [\\u4e00-\\u9fa5] 解析日志条目中的时间戳 1 ERROR\\[(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2})\\] 分组提取结果： 2024-03-09T15:40:22+08:00\n提取IP地址 1 (?:\\d{1,3}\\.){3}\\d{1,3}|(?:(?:[A-Fa-f0-9]{1,4}:){7}[A-Fa-f0-9]{1,4}) 匹配结果：\n192.168.1.1 203.0.113.255 结语 以上就是针对正则表达式的相关总结和部分案例演示。更多关于测试技能系统提升的学习可关注我的课程，回复 大纲 获取详细目录。\n","date":"2025-03-09T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/058-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/Pasted-20250310_hu_eabe35663ffdc83a.png","permalink":"https://chengxiaqiucao.github.io/post/058-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/","title":"搞定正则表达式，告别新手村！"},{"content":" 现代项目管理中，敏捷研发越来越流行；言必称敏捷，似乎不敏捷就是跟不上时代。敏捷真的就是现代软件项目的灵丹妙药吗？它是否真的是一个普适的研发方法？\n敏捷缘起 先说结论：敏捷研发其实是一个非常有局限性的方法，不具备普适性！ 它的发展壮大只是因为契合了互联网高速发展，较好匹配了互联网应用对需求变化和发布频率的需要。\n而互联网软件，相比传统软件，还具备增量交付，线上问题可快速修复，对质量问题容忍度相对较高等特点。这使得敏捷开发会更容易在互联网项目中落地。\n而随着互联网巨头们对敏捷方法的采用，以及敏捷机构的大力推广，到今日敏捷似乎成了可以放诸四海而皆准的通用方法。也诞生出像Scrum、SAFe、LeSS、Nexus等等各种框架来应用敏捷\n但我们观察这些框架的发展过程和应用场景，其实会发现每种框架都有不小的约束。小型框架如Scrum对团队人数有特别限定，有会议仪式的要求；大型框架如SAFe有对组织架构、多种配套角色和专门团队的要求。等等\u0026hellip;\n而大型框架的诞生，也是在实践中应对实际项目的真实运作，演进而来，是为了应对特定场景的问题，不断添砖加瓦，增加了更多的角色、仪式、流程。但这，似乎也在重蹈传统软件研发流程发展脉络，也同样是在向高复杂度团队的方向上一路狂奔！\n敏捷的局限 所以我们不由得要反思一下，敏捷是否真的是一种有普遍适用性的方法？是解决传统问题的灵丹妙药？\n不能排除敏捷中强调协作、响应变化等思想的正面价值，敏捷宣言本身，对传统僵化的软件流程进行变革是极为必要的。\n但问题在于，敏捷是托生于对软件研发流程的思考，提出敏捷宣言的十七位大牛专家，无一例外，都来自软件开发领域。我们不能说这些大牛的思想和视野不够超前，但这个宣言，本身主要是针对软件开发这个领域的原有问题提出的解决思路。\n也就是说，敏捷方法，先天只针对软件开发，而不是针对软件产品和项目管理。组成一个软件项目，经营一个产品，除了开发，还有产品、设计、运营、客服、质量、安全等等其他角色，这些角色的缺位，使这个方法在产品级落地时，就会缺少对应视角的针对性思考，而更多只关注在研发角色在产品中遇到的问题上。\n正是因为这个先天的局限，敏捷在实际落地中，往往会遇到各种各样的问题。项目孵化期，专注研发时，是敏捷最容易产生价值的时期。但一旦产品走向正轨，需要面对更多不同单位、角色的协作时，敏捷往往就会显现力不从心的一面。\n敏捷的价值 任何企业、项目的成功，其实离不开两部分，制度和文化。\n敏捷方法，因为其先天的局限性，作为制度，不具备普适性。 但敏捷方法中传递出来的文化和价值观，才是敏捷的价值所在，无论是否采用敏捷方法，即便我们使用传统流程，拥抱敏捷的价值观，也依然能够帮助项目走向成功。 个人浅见，更多关于敏捷研发的介绍文章可参见合集：\n","date":"2025-03-07T13:50:37+08:00","image":"https://chengxiaqiucao.github.io/post/064-%E5%AF%B9%E6%95%8F%E6%8D%B7%E7%9A%84%E5%8F%8D%E6%80%9D/Agile_hu_3421f59c077416fa.png","permalink":"https://chengxiaqiucao.github.io/post/064-%E5%AF%B9%E6%95%8F%E6%8D%B7%E7%9A%84%E5%8F%8D%E6%80%9D/","title":"敏捷是否是适用大多项目的灵丹妙药？对敏捷的一点反思"},{"content":"前言 在我们工作中，如果使用Windows系统，善用批处理命令，特别是在批量的文件处理，文本处理时能帮助我们极大地提升工作效率，起到事半功倍的效果！\n但很多同学，对批处理的使用更多还停留在可以将多个command命令组合到一起执行，省去重复敲命令和等待的时间。这个其实只是批处理脚本最基本的使用方法\n但要充分发挥批处理的作用，批处理脚本中的 for 命令其实才是核心，它作为一个兼顾循环处理，和文本列处理的命令工具，在提升批处理脚本效率方面，无出其右！\n但 for 命令的使用，相对比较复杂，很多同学可能并未很好掌握，所以本文，我们带来关于批处理中这个核心命令的系统介绍\n文中还有一个秋草发现的彩蛋，微软竟然有一个官方陈年Bug一直没有修 😂😂😂\nFor 命令介绍 下面我们就来详细介绍这个 windows 批处理中的重磅命令\n基础语法 1 FOR %variable IN (set) DO command [command-parameters] %variable: for循环变量，批处理脚本中需用 %%，命令行直接执行用 % (set)： 可以是文件、目录、字符串或命令输出。。 command： 指定对每组循环执行的命令。 command-parameters： 控制循环行为（如 /R, /D, /L, /F 等） 如遍历集合:\n1 2 @echo off for %%a in (苹果 香蕉 \u0026#34;西瓜 芒果\u0026#34;) do echo 水果：%%a 输出：\n1 2 3 水果：苹果 水果：香蕉 水果：\u0026#34;西瓜 芒果\u0026#34; 说明：默认按空格分隔元素，带引号的字符串视为整体。 ** /R参数：递归遍历文件** 这个参数，用于递归遍历目录及其子目录中的文件。\n1 2 @echo off for /R \u0026#34;C:\\Chengxiaqiucao\u0026#34; %%a in (*.txt) do echo 找到文件：%%a 功能：\n遍历 C:\\Chengxiaqiucao 及其子目录下的所有 .txt 文件。 %%a 会包含完整文件路径（如 C:\\Chengxiaqiucao\\test\\file.txt）。 /D：处理目录 这个参数会仅遍历目录（不处理文件）。\n1 2 @echo off for /D %%a in (\u0026#34;C:\\*\u0026#34;) do echo 目录：%%a 功能：\n列出 C:\\ 下的所有一级目录（如 Program Files, Users 等）。 4. /L：生成数字序列 这个参数和我们编程时控制循环次数比较类似。\n语法：for /L %%a in (起始, 步长, 结束)\n如下例生成等差数列：\n1 2 @echo off for /L %%a in (1, 2, 10) do echo 当前数字：%%a 输出：\n1 2 3 4 5 当前数字：1 当前数字：3 当前数字：5 当前数字：7 当前数字：9 /F：高级文本解析（核心参数） 这个参数可以说是 For 命令最核心的参数，For命令大展身手，大部分情况下都是这个参数的功劳。\n这个参数主要用于逐行解析文本、字符串或命令输出，并支持复杂规则。\n语法： 1 for /F [\u0026#34;选项\u0026#34;] %%a in (数据源) do 命令 数据源：文件、字符串或命令输出（用反引号 ` 包裹）。 选项：delims, tokens, skip, eol, usebackq 等。 /F 的常用选项 选项 作用 示例 delims=xyz 定义分隔符（默认空格/制表符） delims=, 按逗号分割 tokens=n 提取第n列（多列用逗号分隔，如 1,3） tokens=2 提取第二列 skip=n 跳过前n行 skip=2 跳过前两行 eol=; 定义行注释符（默认 ;） eol=# 忽略以 # 开头的行 usebackq 改变数据源引用方式（见下文） 处理带空格路径或命令输出 usebackq 的作用 此处有彩蛋：官方文档中的Bug 在windows的中文官方帮助中，对 -F 参数的说明，其实是错误的\n可以看到，这里对使用 usebackq 的介绍和不使用该参数完全一样，而且，这里中文翻译的非常拗口，很难理解什么意思\n不过，我们通过 chcp 65001 命令将命令行代码页切换至utf8，这时查看帮助会显示英文帮助\n可以看到，理解起来就清晰多了， usebackq解决以下场景的问题：\n处理带空格的文件路径：用双引号引用文件名。 执行命令并解析输出：用反引号 ` 引用系统命令。 直接解析字符串：用单引号 ' 引用字符串。 案例一： 1 2 @echo off for /F \u0026#34;usebackq delims=\u0026#34; %%a in (\u0026#34;C:\\My Files\\data.txt\u0026#34;) do echo %%a 若不使用 usebackq，路径中的空格会导致解析错误。 ** 案例二** 解析 data.csv（格式：姓名,年龄,城市），跳过标题行，提取姓名和城市。\n输入文件 data.csv：\n1 2 3 姓名,年龄,城市 张三,25,北京 李四,30,上海 批处理：\n1 2 3 4 @echo off for /F \u0026#34;usebackq skip=1 delims=, tokens=1,3\u0026#34; %%a in (\u0026#34;data.csv\u0026#34;) do ( echo 姓名：%%a，城市：%%b ) 输出：\n1 2 姓名：张三，城市：北京 姓名：李四，城市：上海 应用场景总结 参数 适用场景 典型命令示例 无参数 遍历简单文件或字符串列表 for %%a in (*.txt) do echo %%a /R 递归处理目录下的文件 for /R %%a in (*.log) do del %%a /D 仅处理目录 for /D %%a in (C:\\*) do echo %%a /L 生成数字序列（如循环固定次数） for /L %%a in (1,1,5) do echo %%a /F 解析文本文件、命令输出或复杂字符串 for /F \u0026quot;tokens=2\u0026quot; %%a in (data.txt) 所以通过掌握For命令的这些参数和技巧，完全可以让它成为批处理脚本中处理文件、文本和系统任务的“瑞士军刀”。\n","date":"2025-03-01T15:13:59+08:00","image":"https://chengxiaqiucao.github.io/post/063-%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E4%B9%8Bfor%E5%91%BD%E4%BB%A4/%E6%89%B9%E5%A4%84%E7%90%86For%E5%91%BD%E4%BB%A4_%E5%85%AC%E4%BC%97%E5%8F%B7_hu_3e964d75a718ff09.jpg","permalink":"https://chengxiaqiucao.github.io/post/063-%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E4%B9%8Bfor%E5%91%BD%E4%BB%A4/","title":"批处理脚本之For命令"},{"content":"引子 这两天外网极其热门的一个话题应该是马斯克DOGE新政，要求所有联邦雇员发周报，并列出自己上周做的5项工作，并抄送主管！连续两次不发视同辞职！\n然后目前已经有超100万美国公务员发送了这个周报！ 😂😂😂\n而作为公司牛马，我们对这档事实在再熟悉不过了，但话说回来，为什么会有周报这个事呢？\n周报（日报）的本质是什么？ 对于美国的这些公务员大爷们，写周报可能还比较新鲜，但碰上马斯克这个企业出身的大佬，对周报可是情有独钟，早在特斯拉和推特都执行过类似政策。\n那么对企业或Boss来说，为什么期望看到员工的周报？\n拿软件测试部门举例，周报的作用主要体现再以下几方面：\n风险掌控 这应该是所有 Leader 关心周报中最核心的部分。通过周报，可以知道整个项目总体的进度，便于掌握整体的质量风险，比如测试延期、质量暴露不足等等风险，通过周报可以有一个毕竟清晰的掌握。而周报这个维度，也不会像日报这样过于细节，是一个掌控总体状态的较好输入。\n资源优化 通过周报数据的汇总分析，也便于Leader能掌握所有成员的工作投入情况，便于测试资源的动态调配。\n而这也是这次马斯克新政广受关注的焦点，因为周报的结果指向就是工作不饱和的联邦雇员可能会遭到解雇🤪🤪\n决策依据 周报中，通常会还会包含一些量化的指标，比如测试进展、故障数据、覆盖率、逃逸率、外部支持等等包含可抓取或主动上报的一些质量数据，这些数据是量化当前质量状态并可视化呈现，作为决策依据的重要支撑\n测试人员周报怎么发？ 那么作为一个测试工程师，如果我们要发周报的话，通常应该包含什么内容呢？\n下面给出一个物联网软件（智能手环）员工的周报案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 一、本周工作概述 测试执行情况 - 完成心率监测模块V2.3迭代测试，覆盖10种运动场景，发现2个关键缺陷（数据延迟超阈值、低电量下监测失效）。 - 针对iOS/Android端APP同步功能进行兼容性测试，3款机型（含旧型号）出现数据丢失问题。 - 回归测试通过率95%，剩余5%为低优先级UI显示问题。 缺陷管理 - 新增缺陷15个（紧急2个、高优先级5个），关闭缺陷8个，遗留缺陷中3个需硬件团队协同修复。 专项测试 - 完成OTA升级流程压力测试，模拟5次连续升级后出现1次固件校验失败。 - 功耗测试中，睡眠监测功能待机功耗超标20%。 二、核心问题与风险 阻塞性问题 心率监测数据延迟缺陷导致版本发布延期风险，需开发团队48小时内修复验证。 资源依赖 硬件团队对传感器问题的响应延迟，可能影响下周功耗测试计划。 三、下周计划 - 执行V2.4版本功能测试（血氧监测、紧急呼叫）。 - 针对遗留缺陷进行复测，推动硬件团队联合调试。 - 启动用户场景压力测试（模拟1000台设备并发数据上传）。 以上这个周报，我们从对项目和对测试部门两方面来总结的，体现出的价值可以总结为下表：\n要素 对项目的价值 对测试部门的价值 测试执行进展 明确版本质量状态，帮助PM评估是否达到发布标准。 量化团队产出，便于资源调配与效率优化（如调整测试用例优先级）。 缺陷分布与趋势 暴露模块风险，推动开发聚焦核心问题（如心率模块缺陷率高需重构）。 分析缺陷根源（代码/设计/环境），推动测试用例库补充和流程改进（如增加低电量场景）。 风险与依赖项 预警延期风险，促进跨部门协作（如协调硬件团队介入）。 向上级争取支持（如申请延长测试周期或增加设备资源）。 专项测试结果 验证非功能需求（如功耗、稳定性），避免用户体验硬伤。 积累性能基线数据，为后续版本对比提供依据（如功耗指标库）。 下周计划与目标 对齐项目里程碑，确保测试与开发节奏同步（如血氧功能测试计划匹配迭代排期）。 明确团队分工，避免任务重叠或遗漏。 总结 所以，作为一个企业员工，其实对于周报，没什么值得抗拒的，它是一个再正常不过的管理行为罢了。 对测试人来说，周报既是测试工作的“仪表盘”（实时反映质量状态），也是跨部门协作的“桥梁”（推动问题解决与资源协调），同时也可以为长期测试策略优化提供数据支撑。\n说到底，目的还是为了 状态同步\n和敏捷站会、传统项目可能还有日报，他们的目的其实都是一样的，相关内容在我之前的文章中也有专门阐述，可参考。\n","date":"2025-02-28T17:20:23+08:00","image":"https://chengxiaqiucao.github.io/post/062-%E9%A9%AC%E6%96%AF%E5%85%8B%E6%96%B0%E6%94%BF%E7%9C%8B%E5%91%A8%E6%8A%A5/Pasted-20250228-1_hu_49588963f963603f.png","permalink":"https://chengxiaqiucao.github.io/post/062-%E9%A9%AC%E6%96%AF%E5%85%8B%E6%96%B0%E6%94%BF%E7%9C%8B%E5%91%A8%E6%8A%A5/","title":"马斯克新政“what did you do last week”和发周报"},{"content":" 有人问，国外的大模型基本都是闭源的，Deepseek这么强为什么会选择开源？\n回答这个问题，其实了解下梁文锋是谁，他靠什么起家，以及网上关于他的几段访谈就清楚了！\nDeepseek是兴趣产物 幻方作为国内头部的量化私募，依托的就是基于机器学习这样的AI技术大杀四方。已经极为成功。换句话说，幻方自己赚的钱已经够多了，基于已有的技术积累，投入做Deepseek这个大模型，更多是主创者的兴趣产物，而不是核心产品。本意最多也是给主页赋能，但绝不是自己的主赛道。\n当然现在Deepseek到这个位置，也不排除以后幻方的方向就变成大模型了。\n就好像诺基亚当初做纸浆，兰博基尼当年做拖拉机的一样\u0026hellip;. 无心插柳。\n所以做Deepseek首要考虑的并不是商业模式，如何赚钱！开源还是闭源，在商业模式上并无太多纠结！\n技术的核心不是技术本身，而是产生技术的人才 而从梁文锋的访谈也可以知道，他对开源的看法：人是产生创新的关键！AI这种颠覆性的创新面前，靠闭源获得的护城河是极为短暂的，热爱、好奇、勇于尝试的顶尖人才才是产生这种技术的源头！\n他也举了英伟达的例子，就是英伟达的技术本身也没有特别秘密之处，但组件团队、打造生态和追赶，需要时间，这个时间才是护城河！\n骨子中的自信和以天下为己任的使命感\n梁文锋在访谈中，多次谈到中国以前的技术发展，多是跟随者和微调式的创新而缺乏颠覆性的创新。需要从模仿阶段向原创过度，人类科技进步中要体现中国人的贡献。相信这也是自己在有经济实力的基础上，给了团队中这些全本土人才充分的自由度和创新空间，厚积薄发产生的结果！\n梁文锋是真正做到了：达则兼济天下\n","date":"2025-02-25T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/036-deepseek%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E6%BA%90/","title":"Deepseek为什么会选择开源？"},{"content":" 使用 pytest-mock 进行 Python 高级单元测试与模拟 一、单元测试与模拟的意义 在软件开发中，单元测试用于验证代码逻辑的正确性。但实际项目中，代码常依赖外部服务（如数据库、API、文件系统）。直接测试这些依赖会导致：\n测试速度变慢 测试结果不可控 产生副作用（如真实发送邮件） 模拟（Mocking） 技术通过创建虚拟对象替代真实依赖，使测试聚焦于当前单元的逻辑。\n二、环境安装 使用 pytest 和 pytest-mock 插件：\n1 pip install pytest pytest-mock 三、基础用法示例 场景：邮件发送服务 假设我们有一个邮件发送类 EmailSender：\n1 2 3 4 5 # email_sender.py class EmailSender: def send(self, to, subject, body): # 真实发送邮件的逻辑 return True 测试时不应实际发送邮件。使用 pytest-mock 模拟 send 方法：\n1 2 3 4 5 6 7 8 9 # test_email_sender.py def test_send_email(mocker): mock_send = mocker.patch(\u0026#34;email_sender.EmailSender.send\u0026#34;) sender = EmailSender() result = sender.send(\u0026#34;user@example.com\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;Test email\u0026#34;) mock_send.assert_called_once_with(\u0026#34;user@example.com\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;Test email\u0026#34;) assert result is True 代码解析：\nmocker.patch 替换了 EmailSender.send 方法 验证方法是否以正确参数被调用 断言返回值为 True 四、高级模拟技巧 1. 模拟返回值 1 2 3 4 def test_mock_return_value(mocker): mocker.patch(\u0026#34;module.Class.method\u0026#34;, return_value=\u0026#34;mocked_response\u0026#34;) instance = Class() assert instance.method() == \u0026#34;mocked_response\u0026#34; 2. 模拟抛出异常 1 2 3 4 5 def test_mock_exception(mocker): mocker.patch(\u0026#34;module.Class.method\u0026#34;, side_effect=Exception(\u0026#34;DB Error\u0026#34;)) instance = Class() with pytest.raises(Exception, match=\u0026#34;DB Error\u0026#34;): instance.method() 3. 模拟连续调用 1 2 3 4 5 6 7 def test_multiple_returns(mocker): mock_method = mocker.patch(\u0026#34;module.Class.method\u0026#34;) mock_method.side_effect = [10, 20, 30] assert Class().method() == 10 assert Class().method() == 20 assert Class().method() == 30 4. 模拟属性与方法链 1 2 3 4 5 6 def test_chained_methods(mocker): mock_instance = mocker.MagicMock() mock_instance.method1().method2().method3.return_value = \u0026#34;final\u0026#34; assert mock_instance.method1().method2().method3() == \u0026#34;final\u0026#34; mock_instance.method1.assert_called_once() 五、模拟复杂场景 场景：API 客户端测试 1 2 3 4 5 6 7 # api_client.py import requests class APIClient: def get_user_data(self, user_id): response = requests.get(f\u0026#34;https://api.example.com/users/{user_id}\u0026#34;) return response.json() 测试时模拟 requests.get：\n1 2 3 4 5 6 7 8 9 10 11 def test_api_client(mocker): mock_response = mocker.MagicMock() mock_response.json.return_value = {\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;} mock_get = mocker.patch(\u0026#34;requests.get\u0026#34;, return_value=mock_response) client = APIClient() data = client.get_user_data(1) mock_get.assert_called_once_with(\u0026#34;https://api.example.com/users/1\u0026#34;) assert data == {\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;} 六、最佳实践与注意事项 精确断言：不仅要验证是否调用，还要检查参数\n1 mock_method.assert_called_with(arg1, arg2=expected_value) 使用 autospec：保持模拟对象与原对象接口一致\n1 mocker.patch(\u0026#34;module.Class\u0026#34;, autospec=True) 避免过度模拟：核心业务逻辑尽量使用真实对象\n清理模拟：使用 mocker Fixture 自动清理，避免测试污染\n七、总结 通过 pytest-mock 我们可以：\n✅ 隔离测试环境 ✅ 模拟各种边界条件 ✅ 验证对象交互行为 ✅ 提升测试执行速度 掌握模拟技术能显著提高测试覆盖率与代码质量。建议结合 官方文档 深入学习更复杂的使用场景。\n","date":"2025-02-23T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/057-pytest_mock%E8%AF%A6%E8%A7%A3/pytest-mock_hu_de180f1cd69dce00.png","permalink":"https://chengxiaqiucao.github.io/post/057-pytest_mock%E8%AF%A6%E8%A7%A3/","title":"Pytest_mock详解"},{"content":"\n前言 grep 是 Linux 三剑客（grep, sed, awk）之一，用于在文件中搜索特定的文本模式。它不仅功能强大，而且非常灵活，能够处理各种文本搜索需求。下文我们梳理 grep 命令的详细用法及进阶示例。\n基本用法 基本搜索 1 grep \u0026#34;pattern\u0026#34; filename 用于在 filename 文件中搜索包含 pattern 的行，并打印出来。\n忽略大小写 1 grep -i \u0026#34;pattern\u0026#34; filename 使用 -i 选项忽略大小写。\n递归搜索 1 grep -r \u0026#34;pattern\u0026#34; directory 在 directory 目录及其子目录中递归搜索包含 pattern 的文件内容。\n显示行号 1 grep -n \u0026#34;pattern\u0026#34; filename 使用 -n 选项显示匹配行的行号。\n反向搜索（显示不匹配的行） 1 grep -v \u0026#34;pattern\u0026#34; filename 使用 -v 选项显示不包含 pattern 的行。\n显示文件名 1 grep \u0026#34;pattern\u0026#34; file1 file2 file3 当搜索多个文件时，默认会显示匹配的文件名。使用 -H 可以强制显示文件名，使用 -h 可以隐藏文件名。\n进阶用法 使用正则表达式 1 grep -E \u0026#34;pattern1|pattern2\u0026#34; filename 使用 -E 选项支持扩展正则表达式，例如 | 表示或操作。\n计数匹配的行数 1 grep -c \u0026#34;pattern\u0026#34; filename 使用 -c 选项统计匹配的行数。\n只显示匹配的部分 1 grep -o \u0026#34;pattern\u0026#34; filename 使用 -o 选项只显示匹配的部分，而不是整行内容。\n前后行显示 1 2 3 grep -A 3 \u0026#34;pattern\u0026#34; filename # 显示匹配行及其后3行 grep -B 3 \u0026#34;pattern\u0026#34; filename # 显示匹配行及其前3行 grep -C 3 \u0026#34;pattern\u0026#34; filename # 显示匹配行及其前后各3行 -A, -B, -C 选项分别用于显示匹配行之后、之前或前后的指定行数。\n从标准输入读取数据 1 echo \u0026#34;some text\u0026#34; | grep \u0026#34;pattern\u0026#34; grep 可以从标准输入读取数据，这在管道操作中非常有用。\n使用固定字符串搜索（提高性能） 1 grep -F \u0026#34;fixed_string\u0026#34; filename 使用 -F 选项将 pattern 视为固定字符串而非正则表达式，可以提高搜索性能。\n排除文件 1 grep -r --exclude=\u0026#34;*.log\u0026#34; \u0026#34;pattern\u0026#34; directory 使用 --exclude 选项排除特定类型的文件。\n使用 Perl 兼容正则表达式 1 grep -P \u0026#34;\\d+\u0026#34; filename 使用 -P 选项启用 Perl 兼容正则表达式，例如 \\d+ 表示一个或多个数字。\n零宽断言 1 grep -P \u0026#39;(?\u0026lt;=foo)bar\u0026#39; filename 使用 Perl 兼容正则表达式支持零宽断言，例如 (?\u0026lt;=foo)bar 匹配前面是 foo 的 bar。\n组合使用示例 查找特定目录中的特定类型文件并搜索内容 1 grep -r --include=\u0026#34;*.py\u0026#34; \u0026#34;import\u0026#34; /path/to/directory 在 /path/to/directory 目录中递归搜索所有 .py 文件，查找包含 import 的行。\n查找并显示匹配行及其前后两行 1 grep -C 2 \u0026#34;error\u0026#34; /var/log/syslog 在 /var/log/syslog 文件中查找包含 error 的行，并显示其前后两行。\n统计包含特定单词的文件数量 1 grep -rl \u0026#34;word\u0026#34; /path/to/directory | wc -l 在 /path/to/directory 目录中递归搜索包含 word 的文件，并统计文件数量。\n结语 通过这些示例，可以体会到 grep 的强大能力和灵活性，也让它成为Linux中最实用的文本处理工具之一。\n","date":"2025-02-20T14:02:28+08:00","image":"https://chengxiaqiucao.github.io/post/060-linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep/Pasted-20250310_hu_c2e5d0de01a75b4.png","permalink":"https://chengxiaqiucao.github.io/post/060-linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep/","title":"测试工程师进阶必学 - Linux三剑客（grep）"},{"content":" 有同学提问，在团队中，开发和测试经常会发生一些矛盾，产生冲突，怎么在团队中避免这样的冲突？\n冲突的产生 一个团队中，成员之间产生冲突其实是非常正常的，也很难完全杜绝。冲突的原因各种各样，只是糟糕的团队中冲突的情况更容易出现：双方不一致的目标和期望、缺乏信任、缺少沟通等都是常见的产生甚至升级冲突的原因。\n冲突就一定需要避免吗？ 站在项目和产品维度来说，开发和测试之间得矛盾冲突也并不全然是坏事。我们也不应该想当然地认为冲突就一定应该是要避免的。\n很多研发项目管理中，会把开发和测试之间的冲突称之为建设性冲突，也就是这种冲突对促进产品质量是具有建设性的，在双方的针对具体问题的冲突讨论中，完成对产品质量的提升。\n这个思路其实和冲突管理中对冲突类型划分是吻合的\n在冲突管理理论中，从产生冲突的事务重要程度和人际关系两个维度，冲突的类型可以分为以下四类：\n建设性冲突：冲突产生是事务性的，通常是为了解决问题，对双方的人际关系影响较小。这种冲突其实是良性的。\n破坏性冲突：冲突也是为了解决问题，但烈度较高，对双方的关系有破坏性，会影响后续的友好合作。\n失调性冲突：这种更糟糕，纯粹是双方的关系隔阂导致的冲突，跟事务本身的分歧反而关系不大，可以认为是为了冲突而冲突。\n功能性冲突：这种是最容易发生的冲突，针对的是一些无关紧要的事务，通常表现为发发牢骚、开玩笑式的埋怨等。\n针对不同的冲突类型，团队中，通常应该是鼓励建设性冲突，及时中断破坏性冲突，隔离失调性冲突，包容功能性冲突但避免累积。\nThomas-Kilmann冲突模型 对于个体来说，面对冲突时的处理方式，其实也有一个理论模型，就是Thomas-Kilmann冲突管理模型：\n从面对冲突时，自己对问题解决的个人自信程度和管控和对方的合作关系两方面，形成下面五种冲突处理策略：\n竞争：个人强势，可以采取竞争策略。会造成非赢即输的局面，强势的一方强迫另一方接受自己的诉求。Win-Lose\n合作：这是最佳策略，通过双方团结协作，找到一个双赢的途径，1+1\u0026gt;2, Win-Win\n回避： 不能解决问题，冷处理，搁置问题。Lose-Lose\n让步：一方主动退让，以维系双方的关系。Lose-Win\n妥协：折中，双方各退一步，互有让步达成一个中间方案，形成妥协。 Half-Half\n不同的个体，其实面对冲突时，都会有意无意地去用不同的策略来面对。理解这个模型以后，可以让我们更理智地对冲突进行评估并选择合适的应对方式。\n团队怎么管控冲突？ 对于一个研发团队来说，做好冲突管理，根本还是要在健全的流程制度前提下，打造好团队文化，营造透明、信任的合作关系和环境。\n健全的制度，举例来说，对bug的争议，应该有仲裁机制，而不是让开发和测试一直在那自行争个面红耳赤。\n团队文化，不应该把测试和开发的工作对立起来，而是大家共同面向质量目标的合作。\n","date":"2025-02-19T12:28:00+08:00","image":"https://chengxiaqiucao.github.io/post/056-%E5%9B%A2%E9%98%9F%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81%E7%AE%A1%E7%90%86/Pasted-20250220-2_hu_7477e89a3b37b82f.png","permalink":"https://chengxiaqiucao.github.io/post/056-%E5%9B%A2%E9%98%9F%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81%E7%AE%A1%E7%90%86/","title":"怎么处理团队中开发和测试经常发生的矛盾冲突？"},{"content":"前言 入门自动化测试，录制回放通常是小白测试首先用到的功能。而录制回放工具也一直是各大Web自动化测试必然会着重提供的一块功能。\n早期WinRunner、QTP这样的工具，自动化测试可以说是围绕录制回放开展的。近年像Selenium也提供有录制工具 Selenium IDE，Playwright也包含有 codegen 这样的功能。\n而这些针对Web页面的自动化录制工具，其实本质都是通过在浏览器操作时记录操作行为完成的，说到底还是通过浏览器行为记录来实现。\n本文，我们要介绍的则是Chrome浏览器，官方提供的一个针对自动化测试录制的功能，也就是它的Recorder。\nChrome Recorder 用法 Chrome Recorder是 Chrome从 97 版本以后才提供的一个比较新的功能，很多同学可能还不太了解。但因为是浏览器自带的功能，无需额外安装其他工具，而且从操作记录的准确性和易用性上也能有更好的表现。\n启用 打开chrome浏览器的Dev tool， 从它的功能Tab页中，如果发现有 记录器 这个tab，表示当前浏览器已经支持这个录制功能。\n进入 记录器，点击 创建新录制 即可开启一个脚本录制\n进行一些录制设置，包括当前录制的命名，还有优先使用的元素识别手段，这里 选择器属性, 通常是根据自动化测试的最佳时间，项目一般会为页面元素，包含一个用于测试的属性（通常如 date-testid），比如我们这里示例的 SauceDemo.com 这个网站，也包含一个测试id属性，这里是 data-test，所以这里可以进行指定。 然后点击 开始录制 就可以启动录制了\n录制 录制过程中，我们只需要正常进行页面操作，录制器就会自动对我们的操作进行记录，如果录制过程中，我们需要添加一些校验点，可以在录制记录树中选择 添加断言，默认是等待元素 这个校验。\n选择selectors这里的选择器，然后到页面中点击我们希望校验出现的元素，就会自动把对应的元素属性添加为校验点，这里有一个比较好的地方，就是 recorder 会自动添加多种元素的描述方式，实际回放是，会按照顺序依次进行匹配，为录制的脚本适配提供了更好的灵活性。\n在操作记录树的右侧，我们还可以点击 显示代码, 会把操作记录自动体现为自动化测试脚本，这里目前支持的脚本类型主要还是 Google 自家的puppeteer，但从官方介绍上也提到，更多工具类型也在计划补充中。\n点击结束录制，就可以完成一个简单脚本的生成了。\n回放 完成录制后，当然也可以在这里进行回放，点击 重放 进行回放测试。\n这里在重放设置中，我们还可以模拟指定回放测试时的网络条件，如 3G， 低速4G等。回放过程也可以通过性能面板，生成运行过程中的前端交互性能报表（会生成到性能页面中）\n当然也可以通过导出功能，将录制的内容直接导出为puppeteer脚本，通过puppeteer来完成自动化执行。\n脚本编辑 除了通过录制生成步骤外，我们也可以手工在相应步骤的前后，添加和编辑步骤\n指定 操作的类型type，可以看到，这里会包含页面操作时各种操作事件，再通过元素选择器和相关属性的设置，也可以手动地完成步骤行为的编辑\n结语 可以看到，通过recorder这个chrome自带的录制器，我们已经可以非常方便和灵活地完成web页面自动化脚本的录制生成。相比Selenium IDE和Playwright codegen，因为是chrome本身内置，灵活性和准确性更好。不足之处，主要是目前对于测试脚本的支持，主要还是 google 的puppeteer，对于不使用puppeteer作为主要工具的团队，可能还需要有puppeteer转换到其他工具脚本的工作。\n","date":"2025-02-18T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/050-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A5%BD%E5%B8%AE%E6%89%8B_chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BD%95%E5%88%B6%E5%99%A8/Pasted-20250218_hu_54447727b6894724.png","permalink":"https://chengxiaqiucao.github.io/post/050-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A5%BD%E5%B8%AE%E6%89%8B_chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BD%95%E5%88%B6%E5%99%A8/","title":"自动化好帮手_chrome浏览器的录制器"},{"content":"为什么需要PySnooper？ 在Python开发过程中，print调试法和断点调试法是最常用的调试手段。但面对复杂逻辑时，传统方法存在明显不足：\nprint语句需要手动添加/删除，破坏代码整洁性 IDE断点调试在远程服务器场景难以使用 多线程/异步场景调试困难 PySnooper通过智能日志记录机制，实现了零侵入式调试，提供了另一种直观、便利地观测调试手段\n核心功能详解 1. 智能上下文追踪 比如我们编写一个递归函数\n1 2 3 4 5 6 7 8 9 10 import pysnooper @pysnooper.snoop() def factorial(n): if n == 1: return 1 else: return n * factorial(n-1) factorial(3) 输出示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 (.venv) C:\\Chengxiaqiucao\\AI python ai_test.py Source path:... C:\\Chengxiaqiucao\\AI\\ai_test.py Starting var:.. n = 3 20:14:50.353061 call 9 def factorial(n): 20:14:50.357038 line 10 if n == 1: 20:14:50.357103 line 13 return n * factorial(n-1) Starting var:.. n = 2 20:14:50.357159 call 9 def factorial(n): 20:14:50.357220 line 10 if n == 1: 20:14:50.357291 line 13 return n * factorial(n-1) Starting var:.. n = 1 20:14:50.357348 call 9 def factorial(n): 20:14:50.357421 line 10 if n == 1: 20:14:50.357460 line 11 return 1 20:14:50.357501 return 11 return 1 Return value:.. 1 Elapsed time: 00:00:00.000248 20:14:50.357716 return 13 return n * factorial(n-1) Return value:.. 2 Elapsed time: 00:00:00.000649 20:14:50.357843 return 13 return n * factorial(n-1) Return value:.. 6 Elapsed time: 00:00:00.005107 自动记录函数调用栈和代码执行路径，支持递归函数追踪\n2. 变量监控 1 2 3 4 5 6 7 @pysnooper.snoop(watch=(\u0026#39;result\u0026#39;, \u0026#39;len(data)\u0026#39;)) def process_data(data): result = [] for item in data: processed = item * 2 result.append(processed) return sum(result) 监控特点：\n支持表达式监控（如len(data)) 实时显示变量类型 数值变化提示 3. 上下文管理模式、输出到文件 1 2 3 # 上下文管理器模式 with pysnooper.snoop(output=\u0026#39;/var/log/debug.log\u0026#39;): critical_operation() 4. 多处跟踪时指定前缀 1 2 3 4 5 6 7 8 9 10 11 @pysnooper.snoop(prefix=\u0026#39;[add]\u0026#39;) def add(a, b): return a + b @pysnooper.snoop(prefix=\u0026#39;[main]\u0026#39;) def main(): result = add(5, 7) return result result = main() print(f\u0026#34;Final result: {result}\u0026#34;) 输出时会显示指定的不同前缀\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [main]20:29:01.818895 call 17 def main(): [main]20:29:01.819578 line 18 result = add(5, 7) [add] Source path:... C:\\Chengxiaqiucao\\AI\\ai_test.py [add] Starting var:.. a = 5 [add] Starting var:.. b = 7 [add] 20:29:01.819791 call 13 def add(a, b): [add] 20:29:01.820558 line 14 return a + b [add] 20:29:01.820758 return 14 return a + b [add] Return value:.. 12 [add] Elapsed time: 00:00:00.001314 [main]New var:....... result = 12 [main]20:29:01.821253 line 19 return result [main]20:29:01.821503 return 19 return result [main]Return value:.. 12 [main]Elapsed time: 00:00:00.002834 Final result: 12 5. 设置跟踪深度 如果代码中牵涉多层函数调用，还可以通过指定记录深度，默认深度为 1，灵活结合depth参数，可以帮助我们重点查看关注部分\n1 2 3 4 5 6 7 8 9 10 @pysnooper.snoop(depth=1) def outer_function(x): return inner_function(x + 1) @pysnooper.snoop(depth=2) def inner_function(y): return y * 2 result = outer_function(10) print(f\u0026#34;Outer function result: {result}\u0026#34;) 输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Starting var:.. x = 10 20:37:49.360851 call 9 def outer_function(x): 20:37:49.361569 line 10 return inner_function(x + 1) Source path:... C:\\Chengxiaqiucao\\ai\\ai_test.py Starting var:.. y = 11 20:37:49.361734 call 13 def inner_function(y): 20:37:49.362077 line 14 return y * 2 20:37:49.362184 return 14 return y * 2 Return value:.. 22 Elapsed time: 00:00:00.000589 20:37:49.362380 return 10 return inner_function(x + 1) Return value:.. 22 Elapsed time: 00:00:00.001683 Outer function result: 22 总结 有了这个工具， 我们在调试时，特别是在一些服务器上进行代码调测，就可以通过一行装饰代码实现运行变量和过程的监测了，远离print大法的繁杂啦！\n","date":"2025-02-15T19:13:42+08:00","image":"https://chengxiaqiucao.github.io/post/055-debug%E5%B7%A5%E5%85%B7pysnooper/Pasted-20250215_hu_3e96dd70e4cb276a.png","permalink":"https://chengxiaqiucao.github.io/post/055-debug%E5%B7%A5%E5%85%B7pysnooper/","title":"还在用print大法调试代码？换个玩法"},{"content":" 有同学提问，团队中没有专职的测试人员，要怎么才能快速完成测试？\n先说结论，这里并没有标准答案！\n没有测试岗位只是没有专门负责这个职能的人员，但测试这个事并没有消失\n快速完成测试，其实应该换种说法，就是快速建立质量信心。\n因为测试无穷尽，所以没有绝对的完成测试，按历史经验或大家达成基本共识，产品应该没啥问题了，就算完成测试。\n那既然我们现在希望做的就是快速建立这个质量信心，或者说能快速跟相关干系人达成质量OK的共识，基于这个思路，要考虑哪些因素呢？\n待测范围 要快速做完测试，一个途径就是测试范围少，比如改动很小，而且没啥关联影响模块，快速检验一下就可以了。道理跟开发代码及时提交、高频集成是一样的，不要积累变更，节省出问题后倒查一堆变更的时间。\n开发阶段充分自测，并及时集成测试，不要积累变更。\n已有质量 另一个方面是是否对产品现有质量有信心，开发是增量的，之前的存量是否质量是过关的？新增部分和存量部分的关联、影响是否都是已知的？产品质量是全量的，历史功能或影响同样对影响当前的质量信心，所以是否清晰新增和存量的关系，存量本身的质量是否过关也是关键。\n潜在问题 再有就是，测试是黑盒的，并不能清晰知道冰山之下有多大的危险。但质量信心这个东西其实跟潜在问题并没有直接关系，它主要跟已知问题和已测范围相关，也就是已知问题越少、已测范围越大则信心越足。背后的逻辑就是，已知问题越多，往往意味着潜在问题越多，发现一只蟑螂，可能代表有一窝蟑螂。所以还是强调提测质量！自测没充分，就先别集成测试了，每个开发先把自己的一亩三分地扫干净先。\n问题暴露风险 最后，还有一道防火墙，就是出问题的风险。问题暴露，炸了！ 但炸的影响其实不同，是冒个火星就灭了，还是炸个洞，甚至整栋楼塌了！除了问题本身的大小，不同产品对问题的接受程度其实也不一样，在一个等着拆迁的大楼里放个炮仗，大不了也就是提前拆迁了，容忍度高，信心就足！\n总结 综合以上几个方面，快速完成测试，归根到底就是能不能尽快建立交付的信心，跟个人能力、产品属性、研发流程都有关。其实是个认知问题\n最后，还是要说，任何事物都无法背离内在规律，一个运行稳定，健壮，耐造的系统，必然是会要经过各种磨合、内外部各种问题锤炼才可能达成的。\n你以为的快速交付、一战功成，哪有什么岁月静好，不过是有人替你负重前行罢了。只是这个负重的可能是前期的开发人员、也可能是测试人员、或者运维人员，抑或最后，靠用户抗下所有！\n","date":"2025-02-12T15:31:20+08:00","image":"https://chengxiaqiucao.github.io/post/054-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%8C%E6%88%90%E6%B5%8B%E8%AF%95/Pasted-20250212_hu_e79e7748044ec773.png","permalink":"https://chengxiaqiucao.github.io/post/054-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%8C%E6%88%90%E6%B5%8B%E8%AF%95/","title":"如何快速完成测试"},{"content":"前言 在我们日常工作中，基于Docker技术进行开发、测试环境的快速部署和管理已经非常普遍，而对于我们自己的产品研发来说，必然就离不开很多私有的docker镜像管理，更加上docker官方镜像仓库的访问困难，在我们的研发环境中的搭建私有docker镜像仓库就成为一个普遍需求。\n搭建私有docker镜像仓库的基本方法 - http 搭建docker私有镜像仓库的基础方法，其实非常简便，也是大家网上搜索最容易找到的方案。\n直接通过 docker 启动它的仓库镜像 registry 即可\n1 2 3 4 5 6 docker run -d \\ --restart=always \\ --name registry \\ -p 5100:5000 \\ -v registry-data:/var/lib/registry \\ registry \u0026ndash;restart 设置在仓库异常时自动重启仓库，保证可用性 \u0026ndash;name 设置仓库名称 \u0026ndash;p 内部仓库服务端口5000映射到宿主机5100端口 \u0026ndash;v 仓库存储持久化到数据卷\n镜像启动完成以后，通过浏览器访问一下这台宿主机5100端口的 v2 接口，可以正常显示一个空的 json 字串，表示仓库已经可以正常提供服务\n但这时，如果我们通过 docker push 命令向这个私有仓库上传镜像，会得到一个提示默认协议https不匹配的提示。\n这里我们还需要通过docker配置使其接受http协议，Linux 系统下通常在 /etc/docker/daemon.json 这个docker守护进程配置文件中。\n在其中添加私有镜像服务器地址:\n1 \u0026#34;insecure-registries\u0026#34;: [\u0026#34;192.168.101.67:5100\u0026#34;], 如果是在windows中使用docker desktop，在docker engine中进行配置\n重启docker引擎后，就可以正常对刚搭建的私有参考进行push和pull操作了。\n但是，虽然基于http协议的基础镜像仓库能满足我们日常的基本使用要求，但如果我们的产品项目不是个小型项目，牵涉多个docker镜像联动和多个节点的话，一般会需要使用docker集群。\ndocker官方的集群系统docker swarm使用也非常简便，但docker swarm中对于私有镜像仓库，出于安全考虑，是需要强制通过 https 协议访问的，因此，我们本文的重点，还是介绍下如何搭建一个基于https 协议的私有镜像仓库\nhttps协议镜像仓库的要求 https 协议相对于 http 协议，主要就是提供了传输安全性上的保护。关于 https协议原理的详细说明，可以参看我前面的文章\n大话HTTPS协议，理解SSL、TLS和HTTP的关系\n因此，我们要搭建基于 https 协议的镜像仓库，复杂的地方主要是解决https协议要求的相关认证和鉴权上的要求。主要包括：\n生成证书和访问密钥，非生产环境一般使用自签名证书。 配置镜像仓库启动时挂载证书 配置访问节点对证书的信任 加入集群，推送、拉取docker镜像 集群中部署私有镜像仓库 下面，我们逐步详细说明部署过程\n自签名证书生成 生成根证书私钥和证书 1 2 3 openssl req -newkey rsa:4096 -nodes -sha256 \\ -keyout ca.key -x509 -days 3650 -out ca.crt \\ -subj \u0026#34;/C=CN/ST=Beijing/L=Beijing/O=Qiucao Inc./CN=Qiucao Root CA\u0026#34; 生成服务器私钥和 CSR 1 2 3 openssl req -newkey rsa:4096 -nodes -sha256 \\ -keyout registry.key -out registry.csr \\ -subj \u0026#34;/C=CN/ST=Beijing/L=Beijing/O=Qiucao Inc./CN=qiucao.com\u0026#34; 使用根证书签发服务器证书 1 2 openssl x509 -req -days 3650 -in registry.csr -CA ca.crt -CAkey ca.key \\ -CAcreateserial -out registry.crt -extfile \u0026lt;(printf \u0026#34;subjectAltName=DNS:qiucao.com\u0026#34;) 通过以上操作，会生成我们需要的证书清单\nca.crt：根证书 registry.crt：服务器证书 registry.key：服务器私钥 配置镜像Registry 在swarm集群中启用Registry仓库，可以通过docker compose， 先配置compose启动文件\ndocker-compose.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 services: registry: image: registry:2 ports: - \u0026#34;5100:5000\u0026#34; environment: REGISTRY_HTTP_TLS_CERTIFICATE: /certs/registry.crt REGISTRY_HTTP_TLS_KEY: /certs/registry.key REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY: /var/lib/registry volumes: - ./certs:/certs - /var/docker-registry:/var/lib/registry networks: - registry-net networks: registry-net: driver: overlay 然后通过 docker stack 在集群中启用仓库\n1 2 3 4 5 # 创建 overlay 网络 docker network create -d overlay registry-net # 部署 Registry 服务 docker stack deploy -c docker-compose.yml registry 这样，我们就启用了支持认证的仓库\n配置访问节点信任证书 但仓库支持认证，要在访问时能正常对服务进行认证，在客户节点上，还有一个操作，也就是需要信任仓库的自签名证书\n1 2 mkdir -p /etc/docker/certs.d/qiucao.com:5100 cp ca.crt /etc/docker/certs.d/qiucao.com:5100/ca.crt 重启本地docker服务，以加载信任证书\n验证仓库镜像拉取 然后，在客户机上，我们就可以通过私有仓库来完成镜像的拉取了\n这里还有一个步骤，就是我们配置的仓库地址是 qiucao.com，并不是一个实际存在的公共网络域名，所以这里我们还应该在本地的 /etc/hosts中添加对域名的解析\n1 192.168.101.67 qiucao.com 然后执行命令 docker pull 拉取仓库中的镜像，可以成功完成镜像的拉取\n更多关于docker使用和体系化的测试技能提升，可了解我的测试课程，回复 大纲 了解课程详细内容。\n","date":"2025-02-11T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/025-%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Ehttps%E7%9A%84docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/docker%E4%BB%93%E5%BA%93_hu_57d0029344b5756a.png","permalink":"https://chengxiaqiucao.github.io/post/025-%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Ehttps%E7%9A%84docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/","title":"搭建基于https的Docker私有仓库"},{"content":"春节假期，咱这边举国欢庆，其乐融融。哪吒票房一路高歌猛进；Deepseek也出圈，强势刷屏，服务器长时间繁忙。\n而于此同时，大洋对岸，随着1月20日懂王入主白宫，马斯克也上任DOGE并当天光速开工， 开始对联邦政府支出进行大规模审计。\n此DOGE非彼数字货币DOGE，是美国政府效率部的缩写。\n马斯克和DOGE审计风暴 和我们预想的传统大规模审计，要先成立审计部门，然后成百上千的审计师和动辄数月的准备、入驻、核对工作不同，DOGE到如今，仅用不到20天的时间，已经把美国政坛捅了个天翻地覆\n\u0026mdash; 1 月 20 日，关闭首席多元化官员执行委员会（CDOEC）；\n\u0026mdash; 1 月 25 日，取消约 4.2 亿美元的现有/即将签订的合同；\n\u0026mdash; 1 月 27 日，劳工部、交通部、农业部、商务部、卫生和公共服务部和财政部取消了 16 份 DEIA 合同，节省 1.45 亿美元；\n\u0026mdash; 1 月 28 日，联邦总务管理局（GSA）终止了三份几乎空置的办公空间租约，关闭了 17 个 DEIA 网站，节省了 160 万美元；\n\u0026mdash; 1 月 29 日，取消为缅甸提供的 4500 万美元 DEI 奖学金；\n（截至 2025 年 1 月 29 日，教育部、总务管理局等 26 个部门已终止 85 份 DEIA 相关合同，总额约 10 亿美元；）\n\u0026mdash; 2 月 3 日，未充分利用的建筑的租约终止数量增加到 22 起，节省的金额从 160 万美元增加到 4460 万美元；\n\u0026mdash; 2 月 3 日，关闭美国国际开发署（USAID）；\n\u0026mdash; 2 月 4 日，共有 6 个机构终止了 36 份合同，共节省约 1.65 亿美元，其中包括国土安全部的「人文调查和气候支持服务」合同；\n\u0026mdash; 2 月 5 日，终止 12 份咨询合同（在 GSA 和教育部），共节省约 3000 万美元；\n\u0026mdash; 2 月 6 日，社会保障局已终止其「性别 X 倡议标记」的合同，节省 100 多万美元；NASA 取消 Politico 订阅，节省 50 万美元；DEI、不良资产、媒体和咨询类别的 78 份合同因终止，总节省额约为 1.1 亿美元；\n\u0026mdash; 2 月 8 日，宣布在过去 48 小时内，卫生与公众服务部取消了 62 份价值 1.82 亿美元的合同；教育部终止了三项总额为 1500 万美元的 DEI 培训补助金。\n然而，如此快速高效的审计结果和行动背后，却并没有庞大的团队，依靠的仅仅是几个平均年龄20出头的天才少年和他们的AI算法加持。\nDOGE六灵童 难以想象，以上清单上的手笔，依靠的是下面6个毛头小伙子\n加文·克里格（25 岁）：克里格毕业于加州大学伯克利分校电子工程和计算机科学专业，曾在美国 AI 数据分析公司 Databricks 担任高级软件工程师，是人工智能与大数据分析的专家。克里格的任务是撰写行政命令，并确保它们能够在政府内部迅速生效，那封发给 USAID 全体员工周一不用回总部上班的电子邮件，便出自他手。他还直接起草了针对美国财政部的资金审查令，参与 OPM 的大规模裁员计划，并负责制定公务员的「重新聘用标准」，使得未来的政府雇员必须经过 DOGE 的审批才能入职。\n卢克·法里托（23 岁）：法里托尔已从内布拉斯加大学林肯分校退学，后来为 GitHub 背后的硅谷企业家纳特·弗里德曼（Nat Friedman）工作。他曾在 SpaceX 实习过，为泵、阀门和其他有助于为火箭提供燃料的组件编写软件。法里托尔目前被列为美国卫生与公众服务部（HHS）部长办公室的「执行工程师」，亲自监督了 USAID 的数字封锁行动，接下来的目标已经瞄准了负责合同的医疗保险和医疗补助服务中心的系统。\n爱德华·科里斯廷（19 岁）：科里斯汀是最小的一位，刚刚高中毕业，在波士顿的美国东北大学就读学习机械工程和物理学，去年夏天在马斯克的脑机接口公司 Neuralink 工作了三个月，目前他的具体职责尚未明确。科里斯汀曾使用非政府的谷歌 Gmail 加入美国总务管理局员工的通话中，要求他们检查自己编写的代码并证明自己的工作合理性，此举引发联邦雇员不满。\n阿卡什·博巴（21 岁）：博巴来自加州大学伯克利分校，曾是桥水基金的投资工程实习生，此前还在 Meta，和 MAGA 资助者蒂尔（Peter Thiel）创办的美国软件服务商 Palantir 实习过，专长是人工智能、数据分析和金融建模。他负责设计算法监控政府资金流向，主导的「财政支出实时监控系统」允许在不经过国会审查的情况下，实时冻结联邦「低效支出」。\n伊桑·绍特兰（22 岁）：绍特兰是哈佛大学计算机科学专业的大四学生，是团队中唯一有人工智能创业经验的人，他创办的人工智能公司 Energize AI 获得了 OpenAI 的 10 万美元资助，曾在马斯克的人工智能公司 xAI 举办的黑客马拉松比赛中曾获得过亚军。绍特兰负责 DOGE 的 AI 政府计划，目标是用算法取代政府传统的人力决策机制，将大部分行政审批、预算评估、甚至国会报告自动化。\n戈蒂埃·科尔·基利安（24 岁）：破解财政部安全系统，获取支付网络权限。基利安毕业于麦吉尔大学，在金融数据处理方面有极强的能力，曾在 Jump Trading 公司担任工程师，该公司专门从事高频金融交易和算法。基利安的主要任务是帮助 DOGE 团队破解财政部的安全防线，使他们能够访问政府支付网络，绕开安全检查直接读取数百万笔交易记录。基利安也是少数几个获得白宫高级访问权限的年轻人之一，马斯克对他的信任极高。\n就这么几个大学生年纪的工程师，在取得数据权限后，仅仅两周左右就依靠AI将之前数十年隐藏在冰山之下的各种问题浮上水面。可以说是，确实是兵贵神速，美国的那些官老爷们估计还没缓过神，就发现家被抄了。\n感慨 无论马斯克和这乙巳六章京，维新风暴最终走向哪里，AI 已经实实在在以一种让人瞠目结舌的方式，开始左右大洋对岸的政局，也必将深度影响到我们生活的方方面面。\n","date":"2025-02-10T11:20:27+08:00","permalink":"https://chengxiaqiucao.github.io/post/053-%E9%A9%AC%E6%96%AF%E5%85%8Bai%E6%B2%BB%E5%9B%BD/","title":"马斯克的审计风暴，比Deepseek更直接的AI震撼"},{"content":"近几日Deepseek大火，我这里也尝试了一下，确实很强。而目前vscode的AI toolkit插件也已经集成了deepseek R1，这里就介绍下在vscode中利用deepseek帮助我们完成自动化测试脚本的实践分享\n安装AI ToolKit并启用Deepseek 微软官方提供了一个针对AI辅助的插件，也就是 AI Toolkit for Visual Studio Code， 这个插件可以利用各种开源或商用的大模型，目前也已经集成了Deepseek R1模型，可以让我们在VS code中方便地利用Deepseek来帮助我们的代码开发\n首先在插件中心中找到AI Toolkit并完成安装\n安装完成插件以后，在插件页面，选择catalog中的models模型页面，并通过筛选条件 hosted by Github, 以及 publisher Deepseek 使用Deepseek-R1模型\nAI帮助生成脚本 有了deepseek模型后，我们就可以新建一个playgroud让deepseek帮助我们生成自动化脚本了，以下是我让Deepseek生成的针对saucedemo的测试脚本\n思考过程 嗯，我现在需要帮忙设计一个基于pytest和Playwright的自动化测试项目，针对saucedemo.com的登录和checkout流程，使用POM模式，用户数据放在user.yml里，还要包含异常场景。好的，我得一步一步来。\n首先，应该确定项目的结构。POM模式的话，通常会有page对象、测试用例、配置文件、数据文件等。可能需要这样的目录结构：\ntests/ pages/ login_page.py inventory_page.py cart_page.py checkout_page.py test_login.py test_checkout.py conftest.py user.yml pytest.ini 然后，用户数据存在user.yml里，里面应该有不同的用户类型，比如标准用户，锁定用户，错误密码，没有用户等。然后测试用例要读取这些数据。\n接下来是Page Object Model的实现。每个页面比如登录页、商品页，购物车页、结算页都有自己的类，封装元素和操作。比如LoginPage有用户名、密码输入框，登录按钮，错误提示的方法。\n测试用例应该使用pytest的参数化来覆盖不同的用户场景。比如正常登录成功，无效密码，锁定用户等。同时，checkout流程需要正常流程的测试，可能还有填写信息不完整的情况。\n然后考虑conftest.py里面设置Playwright的fixture，比如browser，page，以及各个page对象的fixture。比如，每次测试前都转到登录页，登录后到库存页，这样可以处理前置条件。\n异常场景的话，例如登录时的各种错误信息，结账时的表单验证，比如必须填first name等。需要编写这些测试用例，并验证错误提示是否正确。\n用户的数据如何加载呢？可能用pyYAML库来读取user.yml文件，里面分不同用户的数据。测试时用@pytest.mark.parametrize参数化输入不同的用户数据。\n比如，用户数据分成valid_users，invalid_password，locked_user等键。在测试登录的时候，参数化这些情况，触发不同的测试用例。\n在测试checkout流程时，可能需要先登录，然后添加商品到购物车，进入购物车，进入结算页，填写信息，完成checkout。这时候，正常的测试用例需要用有效的数据，而异常情况比如不填写某些字段需要验证错误提示。\n还需要处理元素的选择器，Playwright的定位方法，比如使用CSS选择器或文本定位。例如，登录页可能通过id定位用户名和密码输入框。\n此外，测试完成后需要清理状态吗？比如，购物车中的商品或者是否需要登出，或者每个测试用例之间保持独立，可能使用 fixtures 来确保各自的状态。\n也可能需要处理异步操作，不过Playwright是自动处理等待的，所以在页面导航或元素点击时不需要额外处理。\n现在，具体的步骤：\n创建项目结构，安装依赖：pytest, playwright, pyyaml。 编写user.yml，包含不同类型的用户数据。 实现各个页面的Page类，包含元素定位和操作方法。 在conftest.py中定义fixture，例如初始化page，创建各page对象的实例。 编写测试用例，参数化用户数据，覆盖正常和异常流程。 处理测试中的等待和断言，确保元素的存在或文本正确。 需要检查测试用例是否覆盖以下场景：\n登录：\n正确用户密码登录成功。 错误密码提示错误信息。 锁定用户无法登录。 空用户名或密码提示错误。 Checkout：\n正常填写所有信息，完成订单。 必填字段缺失（如first name为空）提示错误。 取消订单流程。 现在，user.yml的结构应该是什么样的？\n可能如下：\nusers: valid_user: username: standard_user password: secret_sauce invalid_password_user: username: standard_user password: wrongpass locked_user: username: locked_out_user password: secret_sauce missing_username: username: \u0026quot;\u0026quot; password: secret_sauce missing_password: username: standard_user password: \u0026quot;\u0026quot;\n在测试登录的时候，参数化这些情况。比如，对于valid_user，应该登录成功，跳转到/inventory.html。对于invalid_password，显示Epic sadface: Username and password do not match。锁定的用户提示Epic sadface: Sorry, this user has been locked out。缺少用户名或密码提示相应的错误信息。\n对于checkout流程，可行的步骤是：\n登录后，添加一个商品到购物车，点击购物车图标，进入购物车页，点击checkout按钮，填写信息，继续，完成。\n所以测试用例需要参数化填写的信息是否正确。例如：\n正常情况下的信息：\nfirst_name: John last_name: Doe zip: 12345\n异常情况，比如不填first name，是否提示错误。\n在编写这些测试时，需要使用页面对象的方法来完成每个步骤，比如添加商品，进入购物车，填写信息，继续按钮等。\n可能的问题点：\n元素的定位是否正确，特别是动态生成的内容或者异步加载的部分是否需要等待。不过Playwright有自动等待机制，所以选择元素时只要正确选择应该没问题。\n需要断言的地方包括：登录后的页面URL是否正确，订单完成后的确认信息是否存在，错误提示是否显示正确的文本。\n比如，登录成功后应该跳转到/inventory.html；checkout完成后应该显示“Thank you for your order”。\n另外，可能需要清理购物车，但因为每个测试可能独立运行，或者每个测试都重新开始会话，所以在fixture中可以处理，如在每次测试前登录并重置状态？\n或者使用类似于beforeEach的fixture，让每个测试用例开始时处于某个状态。比如，登录后的页面。\n此外，测试购物流程需要添加商品到购物车，所以库存页面的类需要有添加商品的方法。\nPage类示例：\nInventoryPage可以有添加某个商品的方法，比如点击“Add to cart”按钮。比如，根据商品名称定位对应的按钮。不过这可能比较复杂，也许在页面上使用通用的方法。\n或者，在InventoryPage中有方法add_item_to_cart(item_name)，用于点击对应商品的添加按钮。这时需要使用Playwright的定位方法，例如：\ndef add_item_to_cart(self, item_name): self.page.locator(f\u0026quot;text={item_name}\u0026quot;).locator(\u0026ldquo;xpath=..\u0026rdquo;).locator(\u0026ldquo;button\u0026rdquo;).click()\n不过这可能需要根据实际的DOM结构来确定。可能需要inspector查看元素结构。\n例如，每个商品项的结构可能类似：\nSauce Labs Backpack Add to cart 所以，找到对应的名称元素，然后找到其父级元素中的按钮。\n或者，更简单的办法是每个商品的“Add to cart”按钮有不同的id，比如 add-to-cart-sauce-labs-backpack，或其他属性。需要看实际网站的结构。\n登录后的页面可能有多个商品，每个商品对应的添加按钮可能需要通过其文本来定位对应的按钮。或者通过其他属性。\n现在，需要实际查看saucedemo.com的结构。可能使用Playwright的代码生成功能来获取正确的选择器。\n假设，例如，每个商品的“Add to cart”按钮的id是动态生成的或者类似，例如对于“Sauce Labs Backpack”，对应的按钮的id可能是add-to-cart-sauce-labs-backpack，那么可以直接通过这个id去定位。\n这样的话，InventoryPage中可以有一个方法：\ndef add_product_to_cart(self, product_name): product_id = product_name.lower().replace(\u0026rsquo; \u0026lsquo;, \u0026lsquo;-\u0026rsquo;) self.page.click(f\u0026quot;#add-to-cart-{product_id}\u0026quot;)\n当然，这需要查看实际的网站结构是否正确。\n假设正确的商品example在这里是Sauce Labs Backpack，其id可能确实是这样的，这样方法可行。\n另外，购物车图标上的数量是否正确，当商品添加后，购物车的图标显示数量为1。当进入购物车页，是否有对应的商品。\n需要注意，每个操作之后的页面变化是否需要新的Page对象实例，比如在InventoryPage点击购物车后跳转到CartPage，所以该操作应该返回CartPage的实例，从而能够继续操作。\n这样方法的返回值处理可能成为问题。比如：\n在InventoryPage中的方法：\ndef go_to_cart(self): self.page.click(\u0026quot;.shopping_cart_link\u0026quot;) return CartPage(self.page)\n类似这样，每个导航动作返回新的Page对象。\n这会需要在各个页面的方法中处理返回相应的页面对象。\n然后是测试流程的组装：\n在测试checkout的时候，可能步骤很多，需要写一个大的测试用例，分步骤进行：\n例如：\ndef test_checkout_process(login_page, inventory_page, checkout_data): # 登录 login_page.login(\u0026ldquo;standard_user\u0026rdquo;, \u0026ldquo;secret_sauce\u0026rdquo;) # 添加商品 inventory_page.add_product_to_cart(\u0026ldquo;Sauce Labs Backpack\u0026rdquo;) inventory_page.go_to_cart() # 进入购物车页面，点击checkout cart_page.click_checkout() # 填写checkout信息 checkout_page.fill_shipping_info(checkout_data) checkout_page.continue_to_overview() # 确认订单 checkout_page.finish_checkout() # 断言是否成功 assert checkout_page.get_order_confirmation() == \u0026ldquo;Thank you for your order!\u0026rdquo;\n当然，这可能涉及到许多页面的跳转，每个页面之间需要用对应的方法来连接。\n异常场景的话，比如在填写信息的时候不输入first name，点击continue时，出现错误提示。\n此时，测试用例可能参数化不同的数据，比如：\n@pytest.mark.parametrize(\u0026ldquo;first_name, last_name, zip_code, error_message\u0026rdquo;, [ (\u0026quot;\u0026quot;, \u0026ldquo;Doe\u0026rdquo;, \u0026ldquo;12345\u0026rdquo;, \u0026ldquo;Error: First Name is required\u0026rdquo;), (\u0026ldquo;John\u0026rdquo;, \u0026ldquo;\u0026rdquo;, \u0026ldquo;12345\u0026rdquo;, \u0026ldquo;Error: Last Name is required\u0026rdquo;), (\u0026ldquo;John\u0026rdquo;, \u0026ldquo;Doe\u0026rdquo;, \u0026ldquo;\u0026rdquo;, \u0026ldquo;Error: Postal Code is required\u0026rdquo;), ]) def test_checkout_missing_fields(\u0026hellip;, first_name, last_name, zip_code, error_message): # 填信息时，漏掉对应字段 checkout_page.fill_shipping_info(first_name, last_name, zip_code) checkout_page.continue_to_overview() assert checkout_page.get_error_message() == error_message\n可能还需要考虑，错误信息提示元素的定位是否正确，以及当出现错误时是否阻止进入下一步。\n现在，问题可能是如何组织这些数据和页面方法。\n另外，关于用户数据的读取，测试用例需要从YAML文件中加载。可能的做法是在conftest.py里面写个fixture读取YAML的数据，然后参数化测试用例。\n但pytest的参数化可能需要特定的方式处理，可能将YAML数据转换成测试参数。或者使用外部数据源来参数化测试。\n例如，在conftest.py中读取user.yml的所有用户数据，并为登录测试创建一个参数化的fixture。\n或者，可以在测试用例中直接读取YAML文件中的数据，并将其参数化。\n比如：\nimport yaml\ndef load_users(): with open(\u0026lsquo;user.yml\u0026rsquo;) as f: data = yaml.safe_load(f) return data[\u0026lsquo;users\u0026rsquo;]\n然后在测试用例中用：\n@pytest.mark.parametrize(\u0026ldquo;user\u0026rdquo;, [ (\u0026ldquo;valid_user\u0026rdquo;), (\u0026ldquo;invalid_password_user\u0026rdquo;), (\u0026ldquo;locked_user\u0026rdquo;), # \u0026hellip; 其他情况 ], indirect=True) def test_login(login_page, user): login_page.login(user[\u0026lsquo;username\u0026rsquo;], user[\u0026lsquo;password\u0026rsquo;]) # 断言等操作\n不过，如何将数据转换为参数可能需要更细致的处理，比如将各个用户数据提取成各个测试实例的参数。\n可能更好的方法是将不同的用户情况分别写成不同的测试数据项。例如，把不同用户类型数据的键列出来，然后根据这些键从数据中加载相应的参数。\n或者，在所有参数化时，导入所有用户数据作为参数。\n比如：\nimport yaml import pytest\nwith open(\u0026lsquo;user.yml\u0026rsquo;) as f: user_data = yaml.safe_load(f)[\u0026lsquo;users\u0026rsquo;]\nlogin_test_data = [ (user_data[\u0026lsquo;valid_user\u0026rsquo;], True, None), # 正常用户，登录成功，没有错误 (user_data[\u0026lsquo;invalid_password_user\u0026rsquo;], False, \u0026lsquo;Epic sadface: Username and password do not match\u0026rsquo;), (user_data[\u0026rsquo;locked_user\u0026rsquo;], False, \u0026lsquo;Epic sadface: Sorry, this user has been locked out.\u0026rsquo;), # \u0026hellip; 其他情况 ]\n@pytest.mark.parametrize(\u0026ldquo;user, success, error_msg\u0026rdquo;, login_test_data) def test_login_user(login_page, user, success, error_msg): login_page.navigate() login_page.login(user[\u0026lsquo;username\u0026rsquo;], user[\u0026lsquo;password\u0026rsquo;]) if success: assert login_page.current_url == \u0026lsquo;https://www.saucedemo.com/inventory.html' else: assert login_page.get_error_message() == error_msg\n这时候，需要在user.yml里的每个用户数据中有一个error键，或者在参数化的准备阶段处理错误信息的映射。\n不过这样的参数方式可能更灵活，能够同时指定预期结果。\n对于YAML的结构，可能需要更详细的数据项，每个用户数据包含预期的错误消息。\n例如，user.yml部分内容：\nvalid_user: username: standard_user password: secret_sauce expected: success: true error: null\ninvalid_password_user: username: standard_user password: wrong expected: success: false error: \u0026ldquo;Epic sadface: Username and password do not match\u0026rdquo;\nlocked_user: username: locked_out_user password: secret_sauce expected: success: false error: \u0026ldquo;Epic sadface: Sorry, this user has been locked out.\u0026rdquo;\n这样参数化时可以更具结构化。但在编写YAML时需要考虑每个用例的期望结果。\n这样，测试用例的参数可能会是直接从YAML中读取的结构，然后通过解析不同的用户组生成测试用例参数。\n不过，这可能有些复杂。另一个办法是，将每个测试案例定义为YAML中的一个项目，包含输入数据和预期结果。\n总之，这部分的处理可能需要更多设计。\n然后，关于Playwright的fixture设置，在conftest.py里可以使用pytest-playwright提供的fixture。例如，使用pytest-playwright插件中的page fixture。不过这可能需要安装pytest-playwright库，并调用playwright的安装步骤。\n安装依赖包括：\npytest-playwright playwright pyyaml\n执行playwright install安装浏览器。\n然后，在conftest.py中，定义如何初始化各个page对象，并将它们作为fixture注入到测试用例中。\n例如：\nimport pytest from playwright.sync_api import Page from pages.login_page import LoginPage from pages.inventory_page import InventoryPage\n其他页面的导入 @pytest.fixture def login_page(page: Page): return LoginPage(page)\n@pytest.fixture def inventory_page(page: Page): return InventoryPage(page)\n等等。这样每个测试用例如果需要用到特定的页面对象，可以直接在参数中声明需要的fixture。\n例如，一个测试用例函数可能接收login_page和inventory_page作为参数。\n接下来，各个Page类的示例。\nLoginPage类是这样的：\nclass LoginPage: def init(self, page): self.page = page self.username_input = page.locator(\u0026quot;#user-name\u0026quot;) self.password_input = page.locator(\u0026quot;#password\u0026quot;) self.login_button = page.locator(\u0026quot;#login-button\u0026quot;) self.error_message = page.locator(\u0026quot;.error-message-container\u0026quot;)\n1 2 3 4 5 6 7 8 9 10 def navigate(self): self.page.goto(\u0026#34;https://www.saucedemo.com\u0026#34;) def login(self, username, password): self.username_input.fill(username) self.password_input.fill(password) self.login_button.click() def get_error_message(self): return self.error_message.inner_text() 但实际情况需要根据saucedemo.com的实际HTML结构调整选择器。比如，错误信息的元素可能是div.error-message-container带有data-test=\u0026ldquo;error\u0026quot;的属性，其文本可能在某个子元素内。\n比如说，实际的网站中，错误信息的HTML可能是：\nEpic sadface: Username and password do not match any user in this service 那么，error_message的locator需要定位到h3元素的文本。或者，定位到整个容器，然后用inner_text()获取文本。\n或者，正确的选择器可能是：\nerror_message = page.locator(\u0026rsquo;[data-test=\u0026ldquo;error\u0026rdquo;]\u0026rsquo;)\n但Playwright支持多种选择方式，比如用data-testid属性等，所以在编写时需要查证正确的元素定位方式。\n所以可能更好的方式是使用data-test属性来选择元素，例如登录页的数据测试属性：\n用户名输入：data-test=\u0026ldquo;username\u0026rdquo;\n密码输入：data-test=\u0026ldquo;password\u0026rdquo;\n登录按钮：data-test=\u0026ldquo;login-button\u0026rdquo;\n错误信息元素：data-test=\u0026ldquo;error\u0026rdquo;，所以其元素可以定位为：\nself.error_message = page.locator(\u0026rsquo;[data-test=\u0026ldquo;error\u0026rdquo;]\u0026rsquo;)\n然后其文本内容可以用error_message.inner_text()来获取，包含错误信息的关键部分。\n至于其他页面，比如库存页面，购物车页等：\nInventoryPage可能有添加商品到购物车的方法，跳转到购物车的方法，或许购物车数量的显示。例如：\nclass InventoryPage: def init(self, page: Page): self.page = page\ndef add_product_to_cart(self, product_name): # 这里假设商品名称对应的添加按钮如何定位，假设data-test属性中有对应的add-to-cart按钮，例如 data-test=\u0026ldquo;add-to-cart-sauce-labs-backpack\u0026rdquo; product_id = product_name.lower().replace(\u0026rsquo; \u0026lsquo;, \u0026lsquo;-\u0026rsquo;) self.page.locator(f\u0026rsquo;[data-test=\u0026ldquo;add-to-cart-{product_id}\u0026rdquo;]\u0026rsquo;).click()\ndef get_cart_count(self): return self.page.locator(\u0026rsquo;.shopping_cart_badge\u0026rsquo;).inner_text()\ndef go_to_cart(self): self.page.locator(\u0026rsquo;.shopping_cart_link\u0026rsquo;).click() return CartPage(self.page)\nCartPage类，可能有checkout按钮：\nclass CartPage: def init(self, page: Page): self.page = page\n1 2 3 def checkout(self): self.page.locator(\u0026#39;[data-test=\u0026#34;checkout\u0026#34;]\u0026#39;).click() return CheckoutPage(self.page) CheckoutPage类：\nclass CheckoutPage: def init(self, page: Page): self.page = page self.first_name_input = page.locator(\u0026rsquo;[data-test=\u0026ldquo;firstName\u0026rdquo;]\u0026rsquo;) self.last_name_input = page.locator(\u0026rsquo;[data-test=\u0026ldquo;lastName\u0026rdquo;]\u0026rsquo;) self.postal_code_input = page.locator(\u0026rsquo;[data-test=\u0026ldquo;postalCode\u0026rdquo;]\u0026rsquo;) self.continue_button = page.locator(\u0026rsquo;[data-test=\u0026ldquo;continue\u0026rdquo;]\u0026rsquo;) self.error_message = page.locator(\u0026rsquo;[data-test=\u0026ldquo;error\u0026rdquo;]\u0026rsquo;)\ndef fill_shipping_info(self, first_name, last_name, postal_code): self.first_name_input.fill(first_name) self.last_name_input.fill(last_name) self.postal_code_input.fill(postal_code)\ndef continue_to_overview(self): self.continue_button.click()\ndef get_error_message(self): return self.error_message.inner_text().strip()\n然后，在完成信息填写后的页面，可能有finish按钮，在CheckoutOverviewPage类中：\nclass CheckoutOverviewPage: def init(self, page: Page): self.page = page self.finish_button = page.locator(\u0026rsquo;[data-test=\u0026ldquo;finish\u0026rdquo;]\u0026rsquo;) self.confirmation_message = page.locator(\u0026rsquo;.complete-header\u0026rsquo;)\ndef finish_checkout(self): self.finish_button.click()\ndef get_confirmation_message(self): return self.confirmation_message.inner_text()\n当然，这些需要根据实际页面的结构进行调整，比如确认信息的元素是否正确。\n这样，整体测试流程就可以通过各个页面的方法来串联。\n现在编写测试用例的步骤：\n测试登录流程：\n参数化不同的用户数据，判断登录是否成功，或者是否出现正确的错误提示。\n例如：\n在test_login.py中：\nimport pytest from playwright.sync_api import Page\n@pytest.mark.parametrize(\u0026ldquo;user_key, expected_success, expected_error\u0026rdquo;, [ (\u0026ldquo;valid_user\u0026rdquo;, True, None), (\u0026ldquo;invalid_password_user\u0026rdquo;, False, \u0026ldquo;Epic sadface: Username and password do not match\u0026rdquo;), (\u0026ldquo;locked_user\u0026rdquo;, False, \u0026ldquo;Epic sadface: Sorry, this user has been locked out.\u0026rdquo;), (\u0026ldquo;missing_username\u0026rdquo;, False, \u0026ldquo;Epic sadface: Username is required\u0026rdquo;), (\u0026ldquo;missing_password\u0026rdquo;, False, \u0026ldquo;Epic sadface: Password is required\u0026rdquo;), ]) def test_login(login_page, user_key, expected_success, expected_error): # 从YAML加载用户数据，这里假设有一个fixture可以加载全部的测试用户数据 users = load_users() user = users[user_key] login_page.navigate() login_page.login(user[\u0026lsquo;username\u0026rsquo;], user[\u0026lsquo;password\u0026rsquo;])\nif expected_success: assert login_page.page.url == \u0026ldquo;https://www.saucedemo.com/inventory.html\" else: assert login_page.get_error_message() == expected_error\n需要写出load_users函数，或者使用fixture来传递给测试用例。\n这里的load_users可能是在conftest.py中的一个fixture：\nimport pytest import yaml\n@pytest.fixture def users(): with open(\u0026lsquo;user.yml\u0026rsquo;) as f: data = yaml.safe_load(f) return data[\u0026lsquo;users\u0026rsquo;]\n然后测试用例可以接收users作为一个fixture：\ndef test_login(login_page, users, user_key, expected_success, \u0026hellip;): user = users[user_key] \u0026hellip;\n但这种参数化可能需要结合indirect参数的使用，或者在参数化时动态获取用户数据。\n或者，将参数化的数据和用户密钥对应起来，通过字典获取正确的用户数据。\n这可能需要对pytest的参数化更深入的处理，例如使用间接参数化，将用户键作为参数，然后在测试函数内部获取相应用户的数据。\n或者，这种参数传递方式可能不太直接，可能需要重新设计参数化的结构。\n可能最好的方式在参数化的列表中直接指定用户数据的键，然后在测试用例中使用该键来索引users fixture中的对应数据。\n例如：\n@pytest.mark.parametrize(\u0026ldquo;user_key, expected_success, expected_error\u0026rdquo;, [ (\u0026ldquo;valid_user\u0026rdquo;, True, None), (\u0026ldquo;invalid_password_user\u0026rdquo;, False, \u0026ldquo;Epic sadface: Username and password do not match\u0026rdquo;), (\u0026ldquo;locked_user\u0026rdquo;, False, \u0026ldquo;Epic sadface: Sorry, this user has been locked out.\u0026rdquo;), (\u0026ldquo;missing_username\u0026rdquo;, False, \u0026ldquo;Epic sadface: Username is required\u0026rdquo;), (\u0026ldquo;missing_password\u0026rdquo;, False, \u0026ldquo;Epic sadface: Password is required\u0026rdquo;), ]) def test_login(login_page, users, user_key, expected_success, expected_error): user = users[user_key] login_page.navigate() login_page.login(user[\u0026lsquo;username\u0026rsquo;], user[\u0026lsquo;password\u0026rsquo;]) if expected_success: assert login_page.page.url == \u0026ldquo;https://www.saucedemo.com/inventory.html\" else: assert login_page.get_error_message() == expected_error\n需要确保user.yml中存在相应的键，且各用户的数据正确。\n对于checkout流程的正常测试：\n在test_checkout.py中：\ndef test_successful_checkout(login_page, inventory_page, users): valid_user = users[\u0026lsquo;valid_user\u0026rsquo;] login_page.login(valid_user[\u0026lsquo;username\u0026rsquo;], valid_user[\u0026lsquo;password\u0026rsquo;]) inventory_page.add_product_to_cart(\u0026ldquo;Sauce Labs Backpack\u0026rdquo;) cart_page = inventory_page.go_to_cart() checkout_page = cart_page.checkout() checkout_page.fill_shipping_info(\u0026ldquo;John\u0026rdquo;, \u0026ldquo;Doe\u0026rdquo;, \u0026ldquo;12345\u0026rdquo;) checkout_page.continue_to_overview() overview_page = CheckoutOverviewPage(checkout_page.page) overview_page.finish_checkout() assert overview_page.get_confirmation_message() == \u0026ldquo;Thank you for your order!\u0026rdquo;\n这需要定义CheckoutOverviewPage类的相应元素和方法。\n对于异常测试：\n比如，填写信息时省略必填字段：\n@pytest.mark.parametrize(\u0026ldquo;first_name, last_name, zip_code, expected_error\u0026rdquo;, [ (\u0026rdquo;\u0026rdquo;, \u0026ldquo;Doe\u0026rdquo;, \u0026ldquo;12345\u0026rdquo;, \u0026ldquo;Error: First Name is required\u0026rdquo;), (\u0026ldquo;John\u0026rdquo;, \u0026ldquo;\u0026rdquo;, \u0026ldquo;12345\u0026rdquo;, \u0026ldquo;Error: Last Name is required\u0026rdquo;), (\u0026ldquo;John\u0026rdquo;, \u0026ldquo;Doe\u0026rdquo;, \u0026ldquo;\u0026rdquo;, \u0026ldquo;Error: Postal Code is required\u0026rdquo;), ]) def test_checkout_error_messages(login_page, inventory_page, users, first_name, last_name, zip_code, expected_error): valid_user = users[\u0026lsquo;valid_user\u0026rsquo;] login_page.login(valid_user[\u0026lsquo;username\u0026rsquo;], valid_user[\u0026lsquo;password\u0026rsquo;]) inventory_page.add_product_to_cart(\u0026ldquo;Sauce Labs Backpack\u0026rdquo;) cart_page = inventory_page.go_to_cart() checkout_page = cart_page.checkout() checkout_page.fill_shipping_info(first_name, last_name, zip_code) checkout_page.continue_to_overview() assert checkout_page.get_error_message() == expected_error\n这里，需要确定实际的错误提示是否是类似这样的文本。比如，在reqreal的网站上，不填first name并继续时，错误提示是否真的是“Error: First Name is required”。需要查看实际页面的情况，可能错误信息是否包含在data-test=\u0026ldquo;error\u0026quot;元素中，或者是否是其他结构。\n综上所述，整个项目需要：\n正确配置POM的各个页面类。 正确读取用户数据并参数化测试用例。 处理不同测试场景的流程，尤其是Test checkout的流程可能需要连续的页面导航和状态维护。 对异常情况进行断言，如错误消息的正确性。 可能还需要对页面元素的同步进行确认，尽管Playwright自动等待，但例如，点击按钮后的跳转是否完成可能会需要确认页面的某些元素，这样更稳定。\n对于一些异步动作，比如点击按钮后元素变化，可以不用等待，因为Playwright内部已经处理了。\n总的来说，这样的设计应该能够覆盖所需的自动化测试需求。接下来，我需要根据这些思路编写具体的代码文件，并验证是否正确工作。\n具体实现 为了基于pytest和Playwright完成针对saucedemo.com的自动化测试登录和checkout流程，并遵循POM模式，以下是详细的实现方案：\n项目结构 1 2 3 4 5 6 7 8 9 10 11 12 13 project-root/ ├── tests/ │ ├── pages/ │ │ ├── login_page.py │ │ ├── inventory_page.py │ │ ├── cart_page.py │ │ ├── checkout_page.py │ │ └── checkout_overview_page.py │ ├── test_login.py │ └── test_checkout.py ├── conftest.py ├── user.yml └── pytest.ini 依赖安装 安装所需库： 1 2 pip install pytest playwright pyyaml pytest-playwright playwright install 文件实现 user.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 users: valid_user: username: standard_user password: secret_sauce invalid_password_user: username: standard_user password: wrong_pass locked_user: username: locked_out_user password: secret_sauce missing_username: username: \u0026#34;\u0026#34; password: secret_sauce missing_password: username: standard_user password: \u0026#34;\u0026#34; pages/login_page.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class LoginPage: def __init__(self, page): self.page = page self.username_input = page.locator(\u0026#39;[data-test=\u0026#34;username\u0026#34;]\u0026#39;) self.password_input = page.locator(\u0026#39;[data-test=\u0026#34;password\u0026#34;]\u0026#39;) self.login_button = page.locator(\u0026#39;[data-test=\u0026#34;login-button\u0026#34;]\u0026#39;) self.error_message = page.locator(\u0026#39;[data-test=\u0026#34;error\u0026#34;]\u0026#39;) def navigate(self): \u0026#34;\u0026#34;\u0026#34;导航到登录页\u0026#34;\u0026#34;\u0026#34; self.page.goto(\u0026#34;https://www.saucedemo.com\u0026#34;) def login(self, username, password): \u0026#34;\u0026#34;\u0026#34;填充并提交登录表单\u0026#34;\u0026#34;\u0026#34; self.username_input.fill(username) self.password_input.fill(password) self.login_button.click() def get_error_message(self): \u0026#34;\u0026#34;\u0026#34;获取错误提示文本\u0026#34;\u0026#34;\u0026#34; return self.error_message.inner_text() pages/inventory_page.py 1 2 3 4 5 6 7 8 9 10 11 12 13 class InventoryPage: def __init__(self, page): self.page = page def add_product_to_cart(self, product_name): \u0026#34;\u0026#34;\u0026#34;将指定商品添加到购物车\u0026#34;\u0026#34;\u0026#34; product_id = product_name.lower().replace(\u0026#39; \u0026#39;, \u0026#39;-\u0026#39;) self.page.locator(f\u0026#39;[data-test=\u0026#34;add-to-cart-{product_id}\u0026#34;]\u0026#39;).click() def go_to_cart(self): \u0026#34;\u0026#34;\u0026#34;进入购物车页面\u0026#34;\u0026#34;\u0026#34; self.page.locator(\u0026#39;.shopping_cart_link\u0026#39;).click() return CartPage(self.page) pages/cart_page.py 1 2 3 4 5 6 7 8 class CartPage: def __init__(self, page): self.page = page def checkout(self): \u0026#34;\u0026#34;\u0026#34;进入结算页面\u0026#34;\u0026#34;\u0026#34; self.page.locator(\u0026#39;[data-test=\u0026#34;checkout\u0026#34;]\u0026#39;).click() return CheckoutPage(self.page) pages/checkout_page.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class CheckoutPage: def __init__(self, page): self.page = page self.first_name_input = page.locator(\u0026#39;[data-test=\u0026#34;firstName\u0026#34;]\u0026#39;) self.last_name_input = page.locator(\u0026#39;[data-test=\u0026#34;lastName\u0026#34;]\u0026#39;) self.postal_code_input = page.locator(\u0026#39;[data-test=\u0026#34;postalCode\u0026#34;]\u0026#39;) self.continue_button = page.locator(\u0026#39;[data-test=\u0026#34;continue\u0026#34;]\u0026#39;) self.error_message = page.locator(\u0026#39;[data-test=\u0026#34;error\u0026#34;]\u0026#39;) def fill_shipping_info(self, first_name, last_name, postal_code): \u0026#34;\u0026#34;\u0026#34;填写配送信息\u0026#34;\u0026#34;\u0026#34; self.first_name_input.fill(first_name) self.last_name_input.fill(last_name) self.postal_code_input.fill(postal_code) def continue_to_overview(self): \u0026#34;\u0026#34;\u0026#34;提交并进入订单概览\u0026#34;\u0026#34;\u0026#34; self.continue_button.click() def get_error_message(self): \u0026#34;\u0026#34;\u0026#34;获取错误提示文本\u0026#34;\u0026#34;\u0026#34; return self.error_message.inner_text() pages/checkout_overview_page.py 1 2 3 4 5 6 7 8 9 10 11 12 13 class CheckoutOverviewPage: def __init__(self, page): self.page = page self.finish_button = page.locator(\u0026#39;[data-test=\u0026#34;finish\u0026#34;]\u0026#39;) self.confirmation_message = page.locator(\u0026#39;.complete-header\u0026#39;) def finish_checkout(self): \u0026#34;\u0026#34;\u0026#34;完成订单\u0026#34;\u0026#34;\u0026#34; self.finish_button.click() def get_confirmation_message(self): \u0026#34;\u0026#34;\u0026#34;获取订单完成确认信息\u0026#34;\u0026#34;\u0026#34; return self.confirmation_message.inner_text() conftest.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import pytest import yaml from playwright.sync_api import Page from tests.pages.login_page import LoginPage from tests.pages.inventory_page import InventoryPage from tests.pages.cart_page import CartPage from tests.pages.checkout_page import CheckoutPage @pytest.fixture(scope=\u0026#34;session\u0026#34;) def users(): with open(\u0026#39;user.yml\u0026#39;, \u0026#39;r\u0026#39;) as f: data = yaml.safe_load(f) return data[\u0026#39;users\u0026#39;] @pytest.fixture def login_page(page: Page): login_page = LoginPage(page) login_page.navigate() return login_page @pytest.fixture def inventory_page(login_page: LoginPage, users): login_page.login(users[\u0026#39;valid_user\u0026#39;][\u0026#39;username\u0026#39;], users[\u0026#39;valid_user\u0026#39;][\u0026#39;password\u0026#39;]) return InventoryPage(login_page.page) @pytest.fixture def cart_page(inventory_page: InventoryPage): return inventory_page.go_to_cart() @pytest.fixture def checkout_page(cart_page: CartPage): return cart_page.checkout() test_login.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import pytest @pytest.mark.parametrize(\u0026#34;user_key, expected_success, expected_error\u0026#34;, [ (\u0026#34;valid_user\u0026#34;, True, None), (\u0026#34;invalid_password_user\u0026#34;, False, \u0026#34;Epic sadface: Username and password do not match\u0026#34;), (\u0026#34;locked_user\u0026#34;, False, \u0026#34;Epic sadface: Sorry, this user has been locked out.\u0026#34;), (\u0026#34;missing_username\u0026#34;, False, \u0026#34;Epic sadface: Username is required\u0026#34;), (\u0026#34;missing_password\u0026#34;, False, \u0026#34;Epic sadface: Password is required\u0026#34;), ]) def test_login(login_page, users, user_key, expected_success, expected_error): user = users[user_key] login_page.login(user[\u0026#39;username\u0026#39;], user[\u0026#39;password\u0026#39;]) if expected_success: assert login_page.page.url == \u0026#34;https://www.saucedemo.com/inventory.html\u0026#34; else: assert login_page.get_error_message() == expected_error test_checkout.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import pytest def test_successful_checkout(inventory_page, checkout_page): inventory_page.add_product_to_cart(\u0026#34;sauce-labs-backpack\u0026#34;) checkout_page.fill_shipping_info(\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;12345\u0026#34;) checkout_page.continue_to_overview() overview_page = CheckoutOverviewPage(checkout_page.page) overview_page.finish_checkout() assert overview_page.get_confirmation_message() == \u0026#34;Thank you for your order!\u0026#34; @pytest.mark.parametrize(\u0026#34;first_name, last_name, postal_code, expected_error\u0026#34;, [ (\u0026#34;\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;12345\u0026#34;, \u0026#34;Error: First Name is required\u0026#34;), (\u0026#34;John\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;12345\u0026#34;, \u0026#34;Error: Last Name is required\u0026#34;), (\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Error: Postal Code is required\u0026#34;), ]) def test_checkout_errors(checkout_page, first_name, last_name, postal_code, expected_error): checkout_page.fill_shipping_info(first_name, last_name, postal_code) checkout_page.continue_to_overview() assert checkout_page.get_error_message() == expected_error 知识点和解释 POM设计模式:\n每个页面（如登录页、商品页）被封装为一个类，页面元素和操作抽象为方法，从而提高代码复用性和可维护性。 数据驱动测试:\n用户数据与测试代码分离，存储在YAML文件中，提升了可维护性，方便添加新的测试场景。 异常场景覆盖:\n通过参数化测试验证不同错误输入（如锁定用户、错误密码、缺失必填字段）是否会触发正确的错误提示。 Fixture管理:\n利用pytest的fixture管理浏览器和页面对象，确保每个测试用例的独立性，减少重复代码。 Playwright自动等待机制:\nPlaywright内置的自动等待确保在操作元素前其已处于可交互状态，增强了测试的稳定性。 此方案覆盖了正常和异常的业务流程，确保核心功能点（登录、购物车、结算）的自动化验证，提高了软件质量。\n结论 参照给出的结果，基本不用做什么微调就可以执行成功，确实极大提升了我们进行自动化实现的效率。最难能可贵的是，deepseek给出的思考过程，对于我们代码实现和用例设计的要点也有极大的参考价值！\n","date":"2025-01-31T21:29:12+08:00","permalink":"https://chengxiaqiucao.github.io/post/052-%E7%94%A8deepseek+vscode%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/","title":"用deepseek+vscode自动完成测试脚本"},{"content":"前言 很久没有更新博客，是因为在梳理制作Playwright测试框架实战相关的课程内容。现在课程已经完结，开个帖子介绍下这门课程（硬广, 哈哈）\n课程放在CSDN学习频道， 欢迎关注~\nPyTest+PlayWright自动化测试框架实战\n为什么是Playwright？ Playwright，相比一些老牌的工具，它的诞生时间并不长，2020年才发布了第一个正式版本，当然在这之前已经有beta版推出。正因为工具比较新，所以也就有了后发优势。 而且Playwright出自微软，背靠大厂，各方面支持力度也很强，所以目前在web自动化测试工具中，上升的势头非常强劲，普遍被认为是能代替传统的web自动化霸主Selenium的新生代自动化测试工具。\n当然，这个工具能受到欢迎，除了因为它是大厂出品，自然也离不开其自身的一些显著的明显优点。\nPlaywright的开发团队，是来自另一款工具puppeteer（Google基于chrome推出的web自动化工具）的核心成员。可以说Playwright是建立在puppeteer基础上的。而puppeteer，本身一度被认为是后selenium时代的web自动化三驾马车之一，所以Playwright可以说是站在巨人肩膀上，它不仅兼容了puppeteer的很多优点，还优化了puppeteer本身的一些不足，更加完善。\npuppeteer有一个很大的约束就是它只支持chrome浏览器，而playwright则内建了对多种主流浏览器的支持，除了chrome、edge，也支持firefox、safari，能满足web自动化的主流浏览器覆盖\nplaywright支持不同的编程语言实现，除了像puppeteer原先支持的node.js之外，也可以支持java、python, 当然还有微软自己的.net。\nPalywright还支持更多的一些扩充高级功能。\n官网对playwright优势的介绍 多浏览器、跨平台、多语言、以及对移动端web的支持。\n弹性框架，能主动规避很多导致UI自动化不够稳定的问题。包括自动等待、动态校验、过程跟踪这样一些特性\n更匹配现代浏览器的架构，是进程级的隔离，使用上线文的概念区分不同的测试场景，且互不干扰。还有像强化对Frame、shadow dom这样一些比较特殊的前端自动化处理\n更充分的隔离以及更快的执行速度，Playwright的上下文机制可以保证浏览器进程基本的隔离以及毫秒级的创建速度。执行速度的优势也得益于playwright基于websocket协议这种长连接、全双工、双向通信的通信协议。\n各种辅助工具，包括代码的自动化生成、录制，页面元素的定位辅助以及强大的信息跟踪工具。\n工作原理 Playwright是基于Puppeteer之上的优化产物，它的实现原理可以说是puppeteer跟Selenium优点的综合。Playwright内建了一个基于Node.js实现的server模块，这个模块和基于各种不同语言的客户端程序之间，通过websocket协议来进行连接，通信，可以发挥websocket长连接、双向工作的优势。\n然后再通过CDP协议对chromium内核的浏览器进行控制和自动化驱动，这里Playwright也支持firefox和webkit（其实是Playwright本身实现了针对这两款浏览器的CDP协议，这里叫CDP plus协议）。\n还有个区别，Playwright其实是把浏览器版本内建在工具之中，这样就屏蔽了因浏览器版本不同导致的差异性。\n测试框架在自动化测试工具体系中处于什么位置？ 我们说到自动化，经常提到测试脚本、自动化工具、框架、平台，那么这些不同的概念到底有什么不一样，我们要介绍的框架，在整个自动化测试体系中，实际是处于什么位置呢？\n可以用下面这个分层图来概括：\n脚本层面。 更多是可以通过一些测试脚本，来完成一些自动化测试任务或测试辅助工具。包括我们使用各种编程语言编写出来的测试代码，或者操作系统的一些shell、批处理脚本等，都属于脚本层面。脚本是自动化测试测试逻辑的直接体现。包括很多自动化测试录制回放工具，把手工操作，转换为测试脚本，完成的都是这个层面的工作。是自动化测试最基础的部分。\n工具层面。 这一层完成的是对脚本的驱动，脚本具体怎么驱动程序执行，怎么进行测试动作和结果的判断？ 这些是自动化测试工具要完成的工作。不同类型的测试通常有不同的工具。我们经常说到的Selenium， Appium，Postman，QTP、Jmeter等等，包括Playwright，主要都可以理解为测试工具。可以做Web、移动应用，接口，性能等等不同类型的自动化测试。\n框架层面，它解决的是自动化测试的组织，把一整套自动化测试用例组织起来。包括用例的选择，执行过程的控制，结果的汇总呈现等。框架层面，最主要的是会支持不同的测试工具，可以对不同类型的自动化测试进行整合。比较常见的测试框架，比如Pytest、Junit、Robotframework等，都属于优秀的自动化测试框架。 像Junit、Pytest，开始是面向单元测试的测试框架，PyTest是借鉴Junit发展而来，但并不是说他们的应用范围就是单元测试，集成测试、系统测试也同样应用。就像自动化测试不属于某一个具体的测试阶段一样，我们也不要把某个测试工具或测试框架和测试的阶段混淆，这是两个不同维度的概念。\n平台层面。自动化测试平台是在更高层面来组织自动化测试。要实现测试任务的调度、测试环境的管理，测试数据、测试脚本等测试资产的管理和分配，包括和其他的研发流程实现互通，比如bug的管理、代码管理、文档管理、配置管理等与各种其他研发工具的互通和整合。\n课程大纲 我的这门课程主要是结合Pytest和Playwright工具的系统介绍，学习如何搭建起一个可落地使用的自动化测试框架，包括和持续集成系统的集成。\n感兴趣的小伙伴，可以关注哈，链接如下：\nPyTest+PlayWright自动化测试框架实战\n目前上新期，八折优惠哦~~\n","date":"2025-01-19T11:07:57+08:00","image":"https://chengxiaqiucao.github.io/post/051-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0pytest+playwright%E6%A1%86%E6%9E%B6/Pasted-20250120-1_hu_273a426231d7a946.png","permalink":"https://chengxiaqiucao.github.io/post/051-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0pytest+playwright%E6%A1%86%E6%9E%B6/","title":"我的pytest+playwright实战课程上线了"},{"content":"这二者不同的地方还是挺多的。主要还是从测试对象的特点出发来看\n设备处理性能上的区别 虽然现在手机处理器、内存等硬件性能上已经有了非常大的提升，但一些低端手机和电脑端相比，处理性能上的差距还是比较明显的。因此在测试时，针对手机端的软件，加载效率、卡顿等就需要重点关注\n屏幕分辨率和系统版本碎片化 手机因为便携，屏幕分辨率有限，再加上厂商、型号众多，所以碎片化情况非常突出。因此针对手机应用测试，考虑不同分辨率和厂商定制的影响，对应用呈现效果的验证也是和电脑端比较明显的不同。\n交互方式差异 电脑端主要的交互方式是键盘鼠标，手机端则主要是触屏、多点触控，拖拽等等。文字输入和页面精准触控比电脑端困难，所以针对应用的测试上，这些也是区别所在\n使用场景差异 手机端应用，使用场景和电脑端的区别，还有一些典型的特殊场景：\n网络稳定性 手机因为是移动设备，移动过程中，出现网络切换、网络不稳定的情况是大概率事件，所以应用对网络持续稳定的兼容性要求比电脑端要高得多\n耗电量 手机依靠电池供电，移动场景下对电量的使用应更为节制，所以应用本身对耗电控制的要求更高\n网络流量 虽然现在手机流量资费已经大幅下调，但流量依然在手机费用中占据极大比重，所以应用在网络交互中对数据包大小、频率等影响流量的控制也是手机App的特点。\n应用安全 虽然电脑端和手机端都存在应用安全问题，但手机作为随身携带且日常使用频率很好的设备，包括定位、通话、摄像等功能也都和个人隐私紧密相关，信息安全上的挑战更大，所以手机应用本身的安全要求和隐私防护上，一般也比电脑端要求更严格。\n测试工具上的不同 手机端应用和电脑端应用，在操作系统、开发工具方面有明显差异，对应到测试工具上也有明显区别。\n以自动化工具为例，电脑端可能有selenium、robotframework、postman等，但对应到手机端，相应的工具则是以Appium、airtest这样的一些工具为代表。\n大致从以上这些方面来看，可以看到，区别还是非常明显的，不可一概而论。\n","date":"2024-12-13T13:37:35+08:00","image":"https://chengxiaqiucao.github.io/post/049-%E6%89%8B%E6%9C%BA%E5%BA%94%E7%94%A8%E5%92%8C%E7%94%B5%E8%84%91%E7%AB%AF%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%8D%E5%90%8C/Pasted-20241213_hu_be55f93612b2836c.png","permalink":"https://chengxiaqiucao.github.io/post/049-%E6%89%8B%E6%9C%BA%E5%BA%94%E7%94%A8%E5%92%8C%E7%94%B5%E8%84%91%E7%AB%AF%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%8D%E5%90%8C/","title":"手机应用和电脑端应用测试的不同"},{"content":"在前面的分享中，我们已经梳理了计划会、每日站会和复盘会的召开要点，本篇我们再对Scrum敏捷四大仪式中的最后一个会议仪式 - 迭代回顾会 进行探讨\n回顾会的目的和作用 回顾会因为和复盘会一般都放在迭代的最后一天，而且通常安排是相邻在一起的会议，所以很多时候大家会错误地认为这两个会议是同一个敏捷仪式，把这两个会等同起来。\n这个其实是对复盘和回顾这两个不同仪式的错误认识。这两个会议，作用、目的，包括会议的参与人员其实都有明显不同，所以，不能因为这两个仪式时间上比较连贯，就想当然地认为它们是同一个会议。\n复盘会的主要目的是通过对迭代交付物的演示，及时收集产品干系人的反馈和意见，以便确认阶段交付符合预期并对后续迭代进行及时调整。 着眼点是面向外部的反馈收集，针对产品本身\n而回顾会的着眼点在团队内部的回顾总结，针对流程和团队协作。\n所以回顾会的目的是在迭代结束后，再回过头检视迭代的运作，从中总结经验，汲取教训。\n而通过召开回顾会，能产生以下作用：\n团队在通过多个迭代去实现产品愿景的同时，也会定期地检视迭代的运作，发现问题，总结经验，及时改进，持续提升。 团队成员通过回顾会这个窗口，有一个相对正式和公开的平台，都可以提出对团队运作方式的建议或发现可能的问题。 回顾会也是增进团队凝聚力的一个重要仪式，是团队成员间互相肯定或开诚布公交换意见的一个渠道。 总之，回顾会可以看作是团队内部的一个闭门会议，是团队自我更新和优化的一个仪式。\n回顾会中的不同角色 所以基于上面的目的，这个会议也不应该和复盘会作为同一个会议召开。\n不同角色参与会议的角色其实也都有所区别：\n必须参加：作为一个团队内部的总结会议，面向的是团队自身的改进，所以Dev Team和Scrum Master是必须要参与会议的。\n尽量参加：PO虽然也是团队一份子，但PO的职责更多还是面向产品本身，而且基本不直接参与产品研发本身。所以PO在团队回顾这点上，不是必须要参加；但是作为团队的重要成员，很多情况下，有些意见和改进举措也是需要PO提出或参与的，因此PO是尽可能参加。\n避免参加：而把回顾会和复盘会分开的一个重要原因，其实就是作为团队内部的改进会议，为了让团队成员能够更直接地表达意见，参与复盘会议的一些利益干系人，比如用户、经理层等，最好是避免参会。当然有些特殊情况下，比如产生重大分歧、产品目标有重大风险等情况下，可能也会请关键的干系人参与回顾。（当然，老板非要参加一般也没法拒绝）\n会议流程 回顾会通常建议是尽可能线下召开，而因为团队都比较熟悉，又是迭代结束，气氛尽快可能营造得轻松些，准备些小零食，小礼品有助于帮助会议达到更好效果。\n会议大体流程如下：\n首先当然还是Scrum Master来主持会议。在进行回顾之前，通常还要做些准备。比如收集迭代过程中的相关数据，比如burn-down燃尽图，团队的速率图。以及在以前迭代回顾会上的跟踪项，目前的状态，这些都在在召开会议开始阶段，让团队总体做个了解。当然然对于比较新的团队，还要介绍下回顾会的规则。要用到的配套工具比如卡片、投票贴纸等。\n下一个环节，是收集团队对迭代运作的建议，也就是团队成员各自把自己对当前迭代的观察结果写下来，哪些方面做得好，应该保持：哪些方面还不够好，可以改进，包括如果想单独感谢谁都可以写到不同颜色的贴纸上。大家都写完以后，将相关贴纸贴到准备好的白板上对应区域中，而在意见收集完以后，大家可以集中到白板前，由SM或者团队任意一个成员，大声地复述每一个贴纸卡片的内容。这个过程其实相当于团队一起重温迭代运作的过程。\n在读完大家所有的意见之后，会进入投票环节。比如每人都可以规定有3票，然后针对这些意见，每人投出自己觉得最值得在下一个迭代采取行动的3条意见。\n完成投票以后，统计得票最多的意见，比如每人三票，那么最后就选出得票最多的三条意见，作为需要在下一个迭代采取行动的待办项。\n确定待办项后，团队还要共同针对对应的事项，讨论具体的措施内容，确定如何来进行改进和提升。\n上面讨论产生的结果，要明确到可实施的具体行动，指定对应的负责人。这些要作为下一个迭代的任务安排，纳入迭代看板进行任务跟踪。\n通过上面这个会议流程，达到团队自我持续更新和改进提升的目的。这里一个非常重要的核心就是成员应该开诚布公，需要大家真正从团队本身的提升为出发点来进行回顾。\n常用回顾会工具 回顾会的主要内容，其实就是收集大家对迭代运作观察和建议的改进事项。一般线下是通过不同验收的贴纸在白板上体现。\n不过现在很多团队可能是异地或居家办公，这种线上回顾会也可以利用一些线上的配套工具。\n比较常用的有：\nIdeaBoardZ 通过 https://ideaboardz.com/ 可以方便地建立一个回顾模板\n按最基本的\n团队执行比较好的地方 值得改进的地方 需要采取的行动 从这几方面收集大家的意见\n海星图 除了上面的基本模型外，有的团队还会利用海星图对观察结果进行细分，划分出五个不同区域\nKEEP: 应该继续保持的行为 MORE: 应该更多执行的行为 LESS: 应该在后续迭代减少的行为 START: 应该在后续迭代开始实施的行为 STOP: 应该在后续迭代停止的行为 帆船图 类似的其实还有 帆船图 这样的模型，目的基本相似，都是起到 回顾检视，后事之师的目的。\n总结 以上就是关于 Sprint 回顾会 的一些梳理。实际运作中，千万不要把回顾会开成抱怨、诉苦会或互相指责，不管运作过程中发现的问题多么严重，大家最终还是要立足团队发展，成员和团队共同得到提升才是目的。\n","date":"2024-12-09T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241201_hu_acc0afaa2f1659b8.png","permalink":"https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/","title":"Scrum敏捷四会 回顾会"},{"content":"前两篇文章，我们分享了敏捷四会中的计划会和每日站会，本文我们继续介绍在敏捷 Sprint 结束后会召开的敏捷复盘(Review)会议。\n目的和作用 Sprint Review Meeting 作为一个Sprint迭代结束后召开的会议，主要目的其实是体现敏捷思想中的“和客户合作”，“快速反馈”，是敏捷小步快跑思想的重要体现。\n具体来说，这个会议的目的，是向产品的业务团队、用户和利益干系人来展示当前 Sprint 的工作成果，听取他们对产品的反馈，确认当前产品的输出 增量（Increment） 是否符合预期，有无新的意见，便于后续 Sprint 的及时调整。\n这也是敏捷区别于传统研发模式的一个显著区别，也就是在一个短周期的Sprint，就会通过这个会议的展示，和最终需求方及时确认进展，而不是像传统流程那样，直到经过一个长周期的完整研发流程后，才会把最终产品交付给用户进行确认。\n所以，这个会议的作用，除了团队的成果交付，更主要的是通过对产品Increment的展示，获取外部业务方和其他干系人的反馈，便于及时调整。\n误区 很多人把这个会议看作是Sprint团队内部，跟PO的一个交付确认会议，其实是不正确的。\n它更多是基于和团队外部的沟通目的。\n也因此，有些特殊状况下，某些Sprint这个会议也是可以不召开。比如：\nSprint的 Increment 产出并无可直接展示的比较明显的业务变更，更多是一些技术调整，架构层面的变化时，并无多少需要业务方确认的内容。\n关键的业务方或利益干系人无法参加，不能匹配当前 Sprint的节奏。Sprint的结束时间比较固定，但关键利益干系人的时间如果无法匹配，那么这个会议可能会取消。这种情况下，后续Sprint 的复盘会时会包含当前sprint的相关输出展示\n团队本身评估Sprint Goal就没有达成，关键的产出达不到预期时，自然也不适合跟外部进行产品展示。\n参会人员 基于这个会议的目的，其实复盘会可能参与的人员会比较多，一般会包含下面这样一些角色：\nScrum Team 当然都是应该参加的，包括PO、SM、Dev Team 关键的利益干系人，通常指这个产品的投资人（产品总监/研发总监这样的角色） 团队成员的相关汇报对象，开发经理、测试经理、UE经理等 和Sprint产出相关的其他关键关联团队角色，比如有协作的其他Scrum团队关键成员（PO、SM），或者像安全、法务、质量、售后、售前、客服等。 复盘会一般都在Sprint结束的最后一天召开。而Scrum 团队中，PO作为和外部各种干系人的沟通渠道，会在会议召开前（通常提前1~2天）发出会议邀请，既告知相关人员当前Sprint的主要输入内容和范围，也便于确认会议与会人，并给团队预留一些复盘演示的必要准备时间。\n会议流程 迭代最后一天，大家完成迭代工作，根据PO的会议邀请，参与Review Meeting。\n会议的流程大致如下：\nScrum Master主持会议，一般会在开始欢迎参会的相关干系人，并简单介绍下参会的成员，如果Scrum团队有新成员加入，可能还会让新成员做个简单的自我介绍。如果相关人员都比较熟悉，就是个简单的开场白。\n接下来，会由 PO 说明下当前这个Sprint增量的主要内容，也是接下来演示的主要功能范围。如果是间隔了多个sprint才召开的Review，这里通常会包含多个Sprint的内容。\n然后就是演示环节，一般是PO 自己来进行演示说明，因为 PO 全程参与Sprint，对相关内容也比较熟悉。实际工作中，也可以是团队中比较熟悉相关功能的成员来进行演示，通常负责测试的同学执行这个演示会比较多。最好不要在演示过程中，频繁切换不同人员来进行演示。\n下面这个环节，其实通常也会贯穿在演示过程中，就是干系人对产品实现上的一些反馈沟通，基于产品的目标和价值，包括下一Sprint的预期，对产品会有一些疑问或改进意见，团队可以就这些问题，和干系人进行直接的沟通和讨论。这部分其实占用了这个会议最主要的时间，气氛或融洽或激烈，但最终都会对形成一些原有需求的修订或新增。\n所以在上一个环节的输出其实会产生一个更新的PBI清单，而这也会是后续Sprint的主要输入，是会后PO需要进一步梳理精炼的素材。\n最后，SM进行会议总结，通常会汇总下讨论结果，包括确认后续要跟踪落实的需求和其他事项，如相关技术的调研攻关等。当然，这里的总结，其实也会提醒干系人散会，但对团队来说，也是提醒后续回顾会的召开（回顾会通常紧接复盘会召开）\n复盘会一般控制在2小时内（针对2周的Sprint），SM在过程中要控制会议节奏，根据演示内容的多少，对一些过于发散和深入的讨论进行时间上的把控，比如另行预定专门的会议讨论等。\n总结 那么总结下复盘会的关键事项：\n首先这个会议是一个迭代结束后，获取迭代产出反馈的一个会议。是敏捷小步快跑思想的主要体现。但实际运作中，并不是一个必定会每个Sprint都会召开的一个会议。只是应尽可能不要间隔时间太长，给团队来根据干系人的反馈进行及时调整有灵活性。\n这个会议并不是一个验收会，它并不是用于向PO确认Sprint Goal有没有达成的一个会。沟通反馈才是主要目的\n会议的过程和产出，是敏捷迭代，产品演进的重要一环，是确定PBI，及时纠偏的重要过程，可以确保团队的工作和用户的期望是匹配的。\n最后，这个会议也是Sprint中Dev Team和相关干系人直接沟通，感受压力和直面用户或老板们真实想法的唯一一个正式的窗口。对于避免团队闭门造车、想当然或工程师思维有重要意义。\n以上就是关于Sprint Review Meeting相关召开要点的梳理和总结，欢迎关注秋草，持续带更多软件研发、测试、技术的深度梳理和思考。\n","date":"2024-12-01T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201_hu_4f330aeadd5cd546.png","permalink":"https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/","title":"细说敏捷：敏捷四会之复盘会"},{"content":" 上一篇文章中，我们讨论了 敏捷四会 中 冲刺计划会 的实施要点，本篇我们继续分享敏捷四会中实施最频繁，团队最容易实施但往往也最容易走形的第二个会议：每日站会\n关于每日站会的误区 站会是一个比较有标志性的仪式活动，大部分号称敏捷的团队，也都会实施站会这个实践，但其实对站会的理解上，其实还是有不少误区。\n很多人会认为站会是由Scurm Master负责的一个会议。把它理解成像传统项目一样，PM听取团队工作汇报目的的一个会议。 但在Scrum中，SM其实一个辅助性的角色，团队本身才是对各项具体工作负责的人。所以站会的Owner其实是团队。虽然通常也会由SM来主持，但SM的主要作用是协调和掌控节奏，会议本身主要还是为了完成团队内部自身的协作。\n第二个误区，就是这个会议也不是一个状态更新会，它既不是用来向SM，也不是向PO汇报工作进展的。更新状态本身不是会议的目的，而主要是为了让团队成员对其他人的工作都有清晰的了解，便于当天工作的进一步协作。\n还有一个误区，也是很多人会不自觉进入的误区。就是这个会议也不是用来解决问题的。它只是一个很简短的团队成员之间的同步会议。要保证会议效率，避免进入具体细节的长时间讨论。做到反映团队当前的进展、识别工作障碍就达到了目的。\n每日站会的作用 所以，澄清了以上误区，站会的作用也就比较清楚了：\n会议的负责人是团队本身。一个很成熟的Scrum团队，甚至也可以不需要SM来组织并主持站会的召开\n会议的主要目的是用于团队进展的同步，成员间互相了解进展，使每个人都能知道团队目前处在完成 sprint 目标的一个什么位置，还有哪些需要调整的地方\n最后，通过站会，也可以识别出当前主要的困难和阻碍，便于进一步及时采取措施。\n站会的内容 而因为站会的主要作用是同步和协同，所以通常会放在一天工作的开始，站会就是团队当天工作的起点。 会议的召开流程，通常也是大家一起集中到看板前，每个团队成员轮流说明下三个问题：\n前一天我完成了哪些工作？ 今天的工作计划是什么？ 有哪些遇到的困难或需要他人协作的事项？ 每位成员都通过说明这三个问题，让团队其他人都能知道自己目前的工作进展，然后判断出当天各自要协作的对象是谁，还有哪些需要下一步尽快讨论的问题，说明需要的支持或者在别人需要支持时予以协助。\n正因为站会的作用就是同步信息，而且每天都会召开，会议的时长应严格控制，通常不应该超过15分钟。大家快速更新完各自的进展，任何需要进一步讨论的问题都应该放到会后，再单独和相关的伙伴就问题的细节或解决方案深入讨论。\n站会中的不同角色 而作为 Scurm 中的三种不同角色，每种角色参与站会的话应该做些什么？发挥什么作用呢？\nScrum Master SM作为团队的组织者和支持者，参与站会最主要的作用其实就是维持站会的纪律，保证会议召开的效率，使会议符合敏捷精神。\n在出现有问题可能需要深入讨论的时候，及时中断，并且把问题放入看板的停车场部分中，站会后再安排继续讨论\n根据团队成员同步的进展和工作内容情况，判断完成冲刺目标的进度风险，并提醒团队成员可能落后的进度，视情况协调其他成员参与协作\n成员提出的阻碍如果会上无法在团队内部立即解决，记录并在当天进行进展跟踪\n会议结束前，SM 还可以快速地和团队分享下 sprint 的当前燃尽图和看板中主要条目的状态，使大家对当前的总体进展有一个整体的了解\n- 最后，SM应该控制会议时间，不超过15分钟结束\n燃尽图是一个当前实际完成工作量和理想进度的拟合图，可以直观反映出团队当前进展是否符合预期\nDev Team 准时参会，不要迟到。\n最主要的当然是进度同步，说明清楚上面的三个问题\n会议前，及时将自己的负责的任务状态更新到最新，保证看板的任务的状态信息是准确的\n有任何阻碍或者需要协调、澄清的问题，站会上应该及时地提出来，这也是这个会议主要的目的\nPO PO在 sprint 进行中，主要职责是澄清和确认需求，但站会的作用主要是团队的工作进展同步，所以PO 不一定必须参加这个会。但也不是不能参加，参与站会也有他的作用。\n对PO自身，通过参与站会，可以知道团队当前的进展情况，能对 Sprint Goal 的达成有更加及时和清晰的判断。\n站会如果有关于需求的疑问或者需要澄清的，简单一两句话就可以在会议上完成说明的就可以在会议上解决。对于比较复杂的，也可以及时地掌握情况，方便会后立即单独进行沟通。\n还有就是 Sprint 进行中，如果正在进行中的需求发生了调整或者优先级变化，就需要及时在站会上跟团队说明，方便团队进行相应的调整和应对\n有时团队识别的困难或阻碍是跟跟PO相关的，这时 PO 也可以及时跟进，包括对于之前反馈过的阻碍事项的解决进展也可以跟团队进行通报。\n总体说来，对于 Scrum 中三种角色参与站会的要求：\nSM - 非必须，但推荐参加 Dev Team - 所有成员必须参加（包括远程电话参会），成员临时无法参与，最好也请其他成员代为说明。 PO - 不要求，但可以参会 召开注意事项 最后，站会能否达到它的效果，也是很多敏捷团队实践走形的一些注意事项，总结如下：\n- 会议应该定点，定时。站会每天都开，大家应该形成习惯，每天在固定的时间，固定的地点来参会，避免因为经常调整，浪费会议召集的时间。\n- 简要。每个成员发言要清楚会议的目的就是进展同步，把三个相关问题说明清楚就可以了。而不是在这里探讨和解决问题。控制每个人的发言时间在1分钟左右。\n准时。站会要求Dev Team成员都应该参与，这样才能清楚了解其他人的进展，在需要协作的事项上可以及时进行协同。而且站会比较简单，所以准时参会就尤为重要，不能因为个人原因浪费团队的时间。 确实出现成员迟到的情况，通常也不会等待大家到齐。定时召开的时间要严格保证。（对于异地办公、或者远程的团队成员，可以通过视频会议、电话的方式拨入，但也要保证参会。如果有团队成员中途休假，通常也应该将自己的进展情况委托其他成员代为说明。）\n专注。这是个容易忽略的注意事项。道理和上面一样，因为站会的作用是协同，所以每个成员都应该是专注在会议上的，确保能清楚所有人的进展情况，而不应该出现在会议中处理其他工作事务、接电话、玩手机、或者开小会的情况。\n停车场。这个看板上的一块专门区域，通常是站会时不可避免遇到一些需要深入讨论的问题时，为了保证会议的效率，暂时把问题记录下来，所放置的一个单独区域。停车场的作用就是避免会议进入深入讨论，但会后可以由对应成员再针对停车场中的问题，继续深入。\n站立会议。站会，顾名思义，就是希望所有人在会议期间是站立进行的。特别是对于在一个办公室办公的团队来说，站立可以有效避免会议时间拉得过长，而且对于有实物看板的团队来说，站立姿势来移动看板上的事项会更加方便，站着说话也能更容易让所有人都听清。\n总结 站会是 Sprint 进行过程中，全体成员都会参加的一个例行的信息同步仪式。所以效率很重要，是团队自组织和高效协同的重要体现。掌握站会的目的和各个角色参与的要点和注意事项，可以帮助我们更好地把站会开好，真正发扬出敏捷精神。\n关注秋草的公众号，及时了解更新动态\n","date":"2024-11-24T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/standupMeeting_hu_1bbd63cb0f6a742a.png","permalink":"https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/","title":"细说敏捷之每日站会"},{"content":"在 Scrum 敏捷模型中，敏捷的落地，其实主要是通过 Scrum 定义的四个主要仪式，也就是我们通常说的 敏捷四会 来完成的，本文我们探讨四会中 Sprint Planning 会议的作用以及其实践要点。\nPlanning会议的作用 在每一个Sprint的开始，首先就会召开这个Sprint Planning会议，同时这个会议也标志着Sprint开始。\n这个会议的主要作用，当然如其名，就是制定当前Sprint运作的计划，确定团队在当前Sprint的工作内容和工作方向，形成Sprint的待办列表 SBI。\n会议的输入 PBI Planning会议最主要的输入，是产品待办清单 PBI。\n会议中的主要讨论其实主要是围绕 PBI 展开的，也就是要从 PBI 中提取经过团队共同确认的待办项，纳入当前迭代，形成 SBI\n而作为会议输入的 PBI，应该是已经和团队一起经过梳理、提炼的需求。团队成员对需求本身也有了充分的理解，并完成对待办项工作量的估算。所有待办项也都有优先级的定义。\n这也是在召开Planning会议前，PBI最好是已经经过grooming会议做过了需求澄清和估算的主要原因。以提高planning会议的效率。 当然在Planning会议上，也会存在对需求的进一步澄清和确认过程，只是为了控制时间，这部分可以尽可能提前打好充分基础。\nDOR/DOD 另外一个重要的输入是团队集体对DOR和DOD的定义，这个通常在sprint 0上确认。后续Sprint可以沿用，如果有修正再重新确认。\n关于DOR 和 DOD，我们介绍Sprint工件的时候有过说明，不再赘述。\nDOR 其实是可以进入Sprint的待处理需求的标准，符合DOR的需求才应该进入 Planning的讨论。 DOD 则是Sprint进行中，每个待办项可以认为完成的标准。\nPlanning会议上应该确认大家对此有共识。\nCapacity（产能） 这个体现的是团队的生产能力。每个 Sprint 团队成员的产能是不固定的，因为可能有成员休假，借调或者本来就不是全职投入的情况。因此在召开 Planning 会议前， Scrum Master应该提前收集掌握好当前Sprint团队整体的Capacity。\n会议要解决的问题 在Planning会议上其实主要就是要解决三个问题： Why？ What？ How？\nWhy？ 为什么我们要进行这个sprint？ 团队要理解这个sprint中的工作带给产品的价值是什么。 PO需要向大家说明他希望达成的价值目标，要能够回答团队为什么我们要做这些需求？为什么这些需求应该要放到当前这个sprint？\nWhat？ Sprint中具体要做的是什么？如果需求已经经过了grooming的梳理和提炼，这里就会节省很多时间。但如果需求还没有充分澄清，或者会议中产生了新的一些思路，PO和团队这里要完成对需求细节的梳理，识别相关的风险和依赖，并达成理解一致。\nHow？ 这部分更多是开发团队成员的讨论内容，就是确定具体如何纳入Sprint的需求实现？并将需求Story再拆分成不同的工作任务，匹配到人，Scrum Master会和团队一起，完成任务的分配和团队Capacity的平衡。\n会议的输出 Planning会议最主要的输出，当然就是SBI，包含当前迭代中需要完成的所有任务项。\n此外，还有一个我们之前介绍过的工件，Sprint Goal。 这个阐明了团队和PO共同达成的迭代应该要力争完成的目标摘要。\n会议时长 敏捷组织的经验数据是根据sprint的长度，每周对应2小时，也就是如果sprint是1周的话，sprint计划会大概要开2h，而通常sprint一般是2周的长度，这时sprint计划会则需要4个小时。\n当然这只是经验数据，不同团队根据团队规模、成熟度和工作的复杂程度会有所不同。\n不同角色应如何参与 Planning会议主要是团队内部会议，参与人包括团队全体成员。极少数的情况下，会邀请主要的利益干系人（直接老板）。在需要他们给出一些决策输入时，可能需要邀请参加。对于比较大的项目，存在多个Scrum团队合作的情况，可能也会邀请到其他团队的关键工程师，来参与一些重要的技术评估。但总体来说，这个会主要还是团队内部的讨论为主，参与人是PO、SM和Dev Team。\nPO PO在计划会前，要完成PBI的优先级排列，并和团队提前完成需求的grooming。\n在会议进行中，则主要是要解答Why和What的问题，并提出期望的sprint goal，确认Scope。\n会议最后，要团队一起确认会议输出：sprint Goal和SBI。\nSM Scrum Master在会前要预定会议，收集团队的投入产能，有那些人需要休假，每位成员在Sprint中的投入时间。\n会议中，SM负责主持，要组织会议流程，协助团队进行任务的分解和工作分配，确保scope中的所有任务都有对应的owner负责人。\n在任务分配和认领过程中，要随时检查团队成员的任务和个人可投入时间的匹配情况，避免出现过度认领。还包括在一些互相依赖任务上进行协调的工作。\n最后，SM要负责汇总出SBI，并和团队一起确认goal。一般还会有一个收集大家对完成Sprint goal的信息指数环节。\n在会后，SM还一应该准备好sprint看板，把相关任务设置到初始状态，并发出会议纪要。\nDev Team 会前，团队成员应该将个人在当前迭代的投入时间告知SM，提前参与PO的grooming，充分了解PBI中的相关需求细节。\n在会议召开过程中，确保自己理解了sprint的目标，另外如果有需求需要进一步说明，积极参与梳理，理解需求，完成估算，主动提出并讨论识别到的风险、依赖。 然后和团队一起，根据自己迭代中的Capacity认领任务，承诺产出）。\n最后大家一起确认sprint goal，给出自己对sprint完成goal的信心指数。完成sprint的启动\n会议流程 再总体梳理下会议进行的流程\nSM 召集会议后，\nPO首先说明期望的sprint目标和当前Sprint的工作范围。并给出相关的理由，对产品的价值说明。团队一起就这部分完成讨论，初步确定scope和goal\n接下来针对Scope中的需求逐一进行澄清，对照DOR，如果没有进行过groom的需求，这时完成梳理澄清和工作量估算。同时识别可能的风险和依赖，并讨论应对措施。\n这两个阶段是Planning会议的上半场，也是PO的主场\n接下来的下半场是开发团队的主场，针对已经理解的需求，再进行任务的拆分，具体分配到人。SM根据任务认领情况，要同步观察Capacity的匹配情况，确保没有遗漏任务和过度认领。这个环节视情况，PO不是必须参加。即使参加，也主要是回答一些讨论中出现的对需求的疑问。\n最后，所有团队成员共同确认达成一致的sprint goal，输出SBI。也代表团队对目标和范围的承诺。最后，团队全体可以对成功完成sprint给i出一个信心指数（0~5）。\n会议全程，SM负责主持，应该控制会议节奏，注意进度和时间。\n总结 通过上面的说明，大家应该可以看到，sprint planning会议是敏捷运作中非常关键的一个会议：\n通过计划会，产生了一个明确的sprint目标\n团队正式开始Sprint前，通过计划会完成了充分沟通，整体工作范围、目标对所有成员透明化，增进了理解\n尽可能准确地匹配了团队的产能和纳入迭代中的工作任务\n每项待办需求经过拆分和认领，都有了明确的负责人\n团队集体完成了SBI和目标，加强了互相之间的合作。也为完成迭代奠定了信心\n关注秋草的公众号，及时了解更新动态\n","date":"2024-11-18T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/sprint_planning_hu_1475ad389fe8542c.png","permalink":"https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/","title":"Scrum敏捷四会 计划会"},{"content":"知乎上看到的问题：\n各位专业的IT或是测试大牛能告诉我环境部署怎么做吗？每次我都是说根据测试文档安装相应软件，环境变量设置！准备相关材料！总觉得回答不够好！求解正确答案？\n作为一个专业的测试人员，这个回答不能说不好，而是基本等同于不会测试。\n这个问题虽然是直接问的如何做安装部署，但其实是问你对于安装部署需要怎么测试？ 不直接问是因为很多小白都意识不到安装部署其实是软件功能测试范围中极为重要的一块，比如题主。\n一个软件系统的安装，特别是直接交付给用户的系统，这部分可以说就是整个系统的门面，是使用这个软件的第一步，表现好坏直接影响用户对这个软件的评价。\n那么软件的安装部署测试要做哪些测试方面的考虑呢？可以从以下几个方面来看：\n全新安装/全量安装 全新安装，指一个软件首次部署或者是在不保留原先已安装信息的情况下重新部署。\n这部分其实是测试的主要部分，题主所说的安装文档其实也主要会针对这一部分说明。\n但测试时还是有很多需要注意的测试要点\n1. 安装的依赖 大部分的安装程序或脚本，它其实都是有一定的条件依赖的：\n需要的磁盘空间？ 网络的连接状态？ CPU/内存有没有要求？ 操作系统的版本？ 系统用户的权限（是不是需要操作系统的管理员权限来安装？） \u0026hellip;. 而且这些依赖也不单纯只是安装程序本身的依赖，也包括安装完成后，软件系统要正常运行需要的依赖条件，这些在我们程序安装的时候，都应该由安装程序提前进行验证。所有这些都是测试时需要考虑和进行设计的。\n2. 安装程序/脚本的功能验证 不管是有安装程序还是通过执行脚本，这部分是安装部署的主体，也是安装部署文档中重点描述的部分，大部分面向用户的安装程序其实都是有界面的。\n那这里的验证其实和普通软件的功能测试没太大区别。\n界面中描述性信息、文字是否清晰 一些操作的提示信息是否明确 有用户交互部分，用户不同选择的分支验证 不同的屏幕分辨率下的兼容性 是否提供步骤回溯？误操作时能否返回上一步\u0026hellip;. 在设计这部分验证时，最好结合流程图，梳理出各种不同路径逐一确认。\n3. 安装异常处理 这个是考验测试人员经验的重要环节。\n磁盘空间不足？ 中途断网？ 本地服务端口冲突？ 中途断电？\u0026hellip;. 4. 易用性 关于安装程序的易用性，主要考虑安装过程中有没有对用户体验优化的一些考虑。\n比如安装选择一个已经存在的目录，是否有提示？ 文件的覆盖会不会有二次确认？ 安装过程中，有没有进度条显示安装进度? 在比较大的文件拷贝时，界面有没有一些信息变化提示，避免用户怀疑程序卡死？ 检测到冲突，有没有给用户提供解决方案建议？\u0026hellip;.. 这些其实都是属于易用性的范畴\n5. 安装校验 在执行安装测试时，我们还应该了解并确认安装前后系统有哪些变化，这些变化是否是符合设计要求。\n安装后安装目录下会包含哪些程序文件？ 操作系统的系统文件夹或非安装目录下有没有生成什么文件？ 注册表有无增加和修改？ 系统服务有没有增加和修改？ 开始菜单中有没有添加程序组？ 桌面上有没有创建快捷方式？\u0026hellip;.. 掌握这些不仅是功能的检查，也是我们理解安装程序本身做了哪些事情，有没有测试场景的遗漏。\n升级安装/更新 除了全新安装外，另一个重要的场景是系统的升级，更新。也就是系统已经存在了一个版本，需要在原有基础上升级到当前安装包的版本。\n而升级又可以分为全量升级和增量升级\n全量升级 全量的升级会完整替换原先的程序文件，但一般会保留原有的配置和数据，安装包通常会包含当前版本的所有文件，安装包通常比较大\n增量升级 增量升级则是根据用户的当前版本，安装包只包含增量的一些程序文件，包括一些升级操作的脚本文件。这种安装包一般比较小，安装过程也通常更加快速。但安装包要和用户的当前版本严格匹配。一般会在全量安装包非常庞大，分发给用户效率不高的时候采用\n版本跨度 不管是全量还是增量，验证时和全新安装的要点基本类似。但有一个升级验证特定的场景需要重点考虑，就是版本的跨度问题\n如果软件迭代，版本变更次数非常多，那么从历史古早版本升级到新版本往往会带来很多问题，包括配置、数据结构的变化造成的影响，以及升级策略的选择，是一次到位还是逐个中间版本升级？对测试策略可能都有影响。\n数据转换 对于牵涉到数据库，数据结构变化的版本升级，业务数据可能会需要进行很多数据转换的操作，这里也是Bug的高发地带，需要结合升级后的业务测试重点关注。\n回退 回退通常属于安装出现问题时，是否可以恢复原先状态，以不影响原来的业务。\n这里主要从几个方面考虑：\n正常取消安装/部署 用户主动发起，属于正常回退，这时安装程序应该要能够清理掉已完成的安装文件，恢复原有的系统配置，将状态重置到安装前的状态\n异常回退 除了用户主动发起的正常回退外，如果安装过程中出现了一些未知的异常导致安装无法继续，这时需要提示用户安装失败，同时也应该触发回退流程，将系统恢复到安装前。\n这种属于我们安装程序本身的异常捕捉和处理的一部分。\n而即便不是安装程序本身捕捉的异常，比如安装过程中拔电源强制中断这样，我们的软件也应该提供一些清理脚本来将部署状态恢复到安装前。 这也是安装测试的重要场景之一。\n回退有效性 除了回退的触发，就是我们还要对回退的效果进行确认。是否确实正确完成了清理和状态恢复。\n另外，在回退执行过程中，如果出现异常（和因为异常触发回退不同），是否有对应的解决方案？比如提供清理工具\n卸载 当然，有安装就有卸载。除了安装程序的验证，我们还要验证卸载程序或脚本。类似安装程序的功能验证\n卸载入口 除了直接执行卸载程序，还有通过操作系统的卸载入口进行卸载，都是应该考虑的场景\n卸载遗留 软件卸载以后，有哪些文件、配置会遗留在操作系统中，是否符合设计要求？\n破坏性卸载 制造一些特殊场景，比如一些关键文件物理删除，关键的配置被变更，确认卸载还是否能正常进行？\n卸载中的异常 同样也要考虑卸载中的各种异常场景\n文件正在使用？ 断网？ 断电？\u0026hellip; 异常出现时，有没有对应的手段可以善后\n很多时候，看上去简单的问题，深究的话门道可并不小。 测试是一门关于探索和发现未知的艺术，自有奥妙​。\n","date":"2024-11-16T16:28:04+08:00","image":"https://chengxiaqiucao.github.io/post/047-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E6%B5%8B%E8%AF%95%E6%80%8E%E4%B9%88%E5%81%9A/Pasted-20241116-3_hu_2fdd0a0813cc5e9d.png","permalink":"https://chengxiaqiucao.github.io/post/047-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E6%B5%8B%E8%AF%95%E6%80%8E%E4%B9%88%E5%81%9A/","title":"安装部署测试怎么做"},{"content":" 面试时被问，为什么会选择做测试而不是做开发？\n实际是问的什么？ 提问代表面试的是测试岗位。而面试官这个问题，其实两方面原因：\n第一，确认面试人是主动还是被动。\n主动：自己有想法，目标就是奔着测试岗位来的。\n被动：其实更想做开发，但自己编程能力不够，算法、设计模式等一团糟。\n第二，看面试人对这两个岗位核心要求的理解。\n如何应对？ 理解了问题背后的目的，那么应对策略其实也就明确了：\n首先当然应该向面试官表明是主动考虑这个岗位的。而考虑这个岗位的原因其实就是自己对测试工作的理解。\n比如我之前的回答\n软件测试的目的是什么？\n测试这个岗位其实需要很多和开发工作不同的特质，比如比较善于质疑、关注细节、喜欢刨根问底等等。\nJame Bach关于测试和检查的区别的论述中其实也指明了很多测试工作需要的特殊能力。\n除此之外，也可以表现自己在测试相关领域的一些积累，比如对测试工具、自动化测试也有较多的掌握，如果有相关的可拿得出手的项目经历就更有说服力了。这里的言外之意，就是自己不选择开发并不是因为没有编程能力，做不了开发，只是因为兴趣点更多是在测试这一边。\n对于测试和开发这个两个岗位的差异，还可以从这么一些角度阐述：\n开发是推陈出新，测试是不破不立\n开发工作更追求确定性，测试则基于不确定性\n开发强调创造，测试长于节外生枝\n等等\u0026hellip; 注意 以上，虽然说的是应对策略，但最好还是真的是因为测试工作的性质更倾向这个工作，而不是退而求其次\n","date":"2024-11-03T23:54:39+08:00","permalink":"https://chengxiaqiucao.github.io/post/046-%E6%B5%8B%E8%AF%95%E5%92%8C%E5%BC%80%E5%8F%91%E7%9A%84%E9%80%89%E6%8B%A9/","title":"关于测试和开发的选择"},{"content":"之前的系列，我们介绍了 Scrum 敏捷中的三大主要角色。而具体实施 Scrum，还牵涉一些具体的工作对象或产出物，这些材料在 Scrum 中叫做 工件 （Artifacts）。\n工件 在 Scrum 中，常说的工件其实主要指三大核心工件：产品待办清单PBI、Sprint迭代待办清单SBI、产品增量Increment。但除了这三种核心工件外，其实还定义有和这三大工件相关的其他的几种工件。\n在敏捷中，工件作为我们的工作对象，产出物。应该是整个Scrum团队集体共同工作和维护的，并且应该对所有人透明，也就是这些工件，对团队中的所有人都是可视化的。这也是敏捷的原则，强化团队对事物的一致理解和沟通，大家应该工作在同一个频道上，透明、可视、随时可查阅极为关键。\n产品待办清单 Product Backlog（PBI） 第一个核心工件是Product Backlog Items （PBI）， PBI 是一个有序列表，包含有产品的所有待完成的未尽事项，包括产品需求、未修复的bug、技术优化、内部改进、工作任务等等各种需要团队后续处理的、和产品相关的事务。\nPBI应该具备以下几个重要特征，或者说DEEP原则：\nDetailed：细节描述。对待办的事项有清晰，无歧义的说明，团队成员可以充分了解待办事项的必要信息。这也是Scrum中需求精炼的的必要性，越是优先级高的，细节描述应该越充分。 Emergent：涌现式的。PBI是一个动态列表，可以根据需要随时进行插入和调整。 Estimated：有估算。待办条目在需要落实之前，应该要完成工作量以及对产品价值的估算，估算是否准确，是团队实际生产力的基础。 Prirotized：有优先级的。PBI中的待办事项，应该是有优先次序的，在PBI中，不存在两个优先级完全相同的条目。这也是列表的优点，列表先天就是有排列顺序的，PBI列表中，排在前面的项优先级更高。团队在从PBI中提取迭代任务的时候，也会按照优先级来依次提取。 和其他工件一样，PBI虽然也是需要团队共同维护的一个产出物，但 PBI 的owner，是PO（产品负责人），其他成员虽然也会参与到PBI的细节补充、方案完善，包括PBI的工作量估算也是需要团队给出，但最终对 PBI 负责的只有PO，PO对PBI有最终解释和优先级的决定权。\nPBI的生成和维护过程中，通常是PO会尽可能把相关的Feature、Story、Enhancement（优化）纳入PBI中，作为后续工作的基础。再经过和团队的充分沟通，一般会通过产品的需求精炼会议(grooming)，对需求进行细化和实现方案的讨论，团队还会分解出具体的技术任务并对需要的工作量进行估算。\n所以 PBI 它其实就是Scrum敏捷研发的源头，相当于是传统研发中，需求分解阶段的主要产出PRD的作用。PBI是启动 Sprint 的基础，也是 SBI 的来源。\n产品愿景 Product Vision 和PBI 配套的，其实还有一个辅助工件，或者Scrum定义中也叫做 PBI 的commitment（承诺产出物）。就是产品愿景Product Vision。\nProduct Vision是一个在产品早期就应该完成定义的东西，主要是总体上概括产品要实现什么目标，大家共同做的这个东西到底是为了达到什么目的，对用户有什么价值。也就是让整个团队直到自己在为什么工作。\n是一个比较长远的对整个产品蓝图的描述。\nSprint待办清单 Sprint Backlog （SBI） Sprint 是冲刺的意思。Scrum中定义的一个短周期的时间窗，在这个较短的周期内团队可以完成一些可交付的产品功能。并基于已完成的功能获取相关干系人的反馈，以便及时地调整整个产品的演进路线。是敏捷“小步快跑”思想的具体体现。\n而SBI，就是在Sprint这个周期中，团队需要完成的所有待办事项的清单。因此 SBI 其实是从 PBI中提取出来的，分布到不同 Sprint 中的团队需要完成的工作。\n通常在Sprint 正式启动前的Sprint Planning会议上，依据PBI的优先级和团队的生产力(Capacity)，由团队共同完成 SBI 的提取。\nSBI在计划会确定以后，一般是尽可能维持不变的。但现实总有各种意外情况发生，而且敏捷提倡拥抱变化，所以并不意味 SBI 确定以后会在 Sprint 中一定是恒定的。PO 根据优先级的调整，在和团队达成一致后，SBI 也是可以进行增删改的，但前提是要团队达成共识。\n通常SBI 调整意味着工作量的浪费，因此在 Sprint 周期内，应该尽可能维持稳定。\n如图，是常用敏捷管理软件 Jira 中，已经纳入到 Sprint 中的 SBI。Sprint 开始以后，则会通过 Scrum 的迭代看板来实时反映 Sprint 的进展情况。\nSprint Goal 类似的，和 SBI 配套的也有一个辅助工件或commitment，就是 Sprint 目标。这个工件通常由PO定义，整体上概述整个Sprint应该达成的核心目标。在和团队确认并达成一致后，Sprint Goal 其实也代表了团队整体在这个周期中承诺的产出。\n对于未参与迭代的各种干系人，通过 Sprint Goal 也可以了解当前产品进展的总体情况。\n增量 Increment Increment，增量的意思。在敏捷中，因为提倡小步快跑，每个迭代的工作成果其实都是面向产品愿景，是在原有基础上的增强，不仅是一个累积的过程，也是不断向用户交付价值的过程。\n基于敏捷原则，Increment 应该是可工作的软件，可以呈现出产品的价值。也就是 Increment和之前 Sprint产出的叠加， 应该总是一个面向未来的、最小的可用软件 MVP（Minimum Viable Product）\nSprint 是否达到了 Sprint Goal，通常是在Sprint评审会上通过演示Increment的功能效果，来向相关干系人进行展示，并获取反馈。\nDOD（完成定义 Definition of Done） 和 Increment 相关的commitment， 其实就是SBI中每个待办项的完成情况。那这里怎么定义这个完成，在 Scrum 中，对应的就是 DOD。DOD 是关于主要待办项类型的一些共性定义。\n其实除了 DOD 外，还有 DOR，DOR 是定义一个待办项在什么情况下可以定义为就绪。只有就绪的待办项才应该纳入SBI\n其他工件 除了 Scrum 中定义的这三种核心工件以及辅助的 commitment 工件，还定义了反映迭代进展状态的工件\n燃尽图 Burndown Chart 燃尽图是一种能够及时反映出 Sprint 进展状况的可视化图形。\nX轴：迭代的进行时间 Y轴：迭代的工作量，通常通过SBI中估算的故事点（Story Point）反映完成这个这个迭代的预估总工作量。\n基于工作量和时间的关系，先绘制一条线性的故事点的理想燃尽线，再根据迭代进行中，实际每天完成的工作量，绘制一条实际燃尽线。 这两条线的匹配度，其实能反映迭代当前进度是否正常。是Scrum Master和团队每日站会时应该随时关注的一个迭代关键状态图。\n因此通常会将燃尽图也作为 Scrum中的一个重要工件来看待。\n除了燃尽图外，其实还有很多其他的图形可以用来分析迭代当前进展，比如常用的还有：\n累积流图 (Cumulative flow diagram）\n通过累积流图，可以看出 Sprint 中，总体需求在不同状态间变化的趋势，往往在识别团队瓶颈、平衡成员间工作量时发挥重要作用。\n速度表（Velocity）\n另一个常用的图还有 Velocity，这个图更多是通过对多个Sprint 完成工作量的跟踪，来观察团队的生产力是否稳定，进而对团队成熟度有个基本的判断。\n越是稳定的敏捷团队，每个迭代的产出应该是比较恒定的。而如果差别波动较大，则代表团队在任务平衡、估算、应对干扰等方面还存在较多问题。是一个观察指标\n以上就是关于Scrum敏捷中，团队工作对象和产出，工件的介绍。 欢迎大家继续关注这个系列，持续更新中\u0026hellip;.\n","date":"2024-11-03T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/","title":"敏捷中的三大工件"},{"content":"问题是什么 老板是否会容忍平行不端的员工？ 这里品行不端，其实我们可以把它理解为违背纪律甚至法律，无视公序良俗等，也就是员工存在价值观上的问题。\n但这里其实还隐含着另一个前提，就是这个员工其实能力应该很强（不考虑背景之类，当然背景其实也算是某种能力）。否则就没有要讨论是否容忍的基础了。\n理论上的正确做法 因此，这里我们要讨论的就是管理中，对员工评估的问题。通常企业在评估员工时，都会综合业绩、价值观两个维度来看\nGE人才九宫格 比如GE评估员工，就会根据这两个维度，综合上、中、下三个级别综合得出一个9宫格。\n绿色：评估优秀\n蓝色：合格或可改进\n红色：应淘汰\n而且，从这个9宫格上，价值观的权重比业绩其实是更看重的，即便业绩很好，也依然是偏红的，倾向淘汰。\n阿里的五类员工模型 类似的，据说阿里其实也有对员工的5种类型划分\n明星：业绩亮眼，贡献突出，价值观正确，绩效重点倾斜\n黄牛：兢兢业业，尽职尽责，是团队基本盘\n野狼：能力出众，但价值观有问题。不能及时纠正，需要坚决汰换\n白兔：看上去工作勤恳，价值观很好，但能力不行。如无法提升，也要淘汰\n土狗：能力和价值观都不行，坚决淘汰\n所以从上面可看出，成熟企业对于价值观有问题的员工，其实态度都是比较明确的，即便你业绩再好，也应该是要淘汰的。即不会容忍品行不端。\n现实中的可能情况 以上，更多是理论上的正确做法。\n不过现实中，老板会作何选择，通常还是会根据所在企业所处的阶段，当然也包括老板个人的价值观所共同左右。\n马克思早就指出过，“资本来到世上，每个毛孔都滴着血和肮脏的东西”。当然这里更多指的是资本原始积累阶段，为了实现资本的增长，往往会不择手段。也就是说，品行不端，在资本积累的早期，往往极大概率不可避免。\n所以，现实中，老板作何选择的逻辑，其实也很简单：\n如果企业的生存是第一需求，拿到业绩，先活下去往往对老板来说更重要，这时多半会对不择手段但业绩优秀的员工更多容忍。\n而一旦做大做强，继续容忍不端行为，可能会影响企业的健康和长远发展，那么自然就不可能再继续容忍。\n当然，我们还是应该相信，确实存在有强大格局、人格的企业家从最初就坚持那些美好的价值观。只是，企业面临生死存亡时，会选择采用的做法会更有说服力。\n","date":"2024-11-02T18:03:14+08:00","image":"https://chengxiaqiucao.github.io/post/045-%E6%98%AF%E5%90%A6%E8%A6%81%E5%AE%B9%E5%BF%8D%E5%93%81%E8%A1%8C%E4%B8%8D%E7%AB%AF%E4%BD%86%E4%B8%9A%E7%BB%A9%E4%BC%98%E7%A7%80%E7%9A%84%E5%91%98%E5%B7%A5/GE-9block_hu_fb8c29b7989e95a8.jpg","permalink":"https://chengxiaqiucao.github.io/post/045-%E6%98%AF%E5%90%A6%E8%A6%81%E5%AE%B9%E5%BF%8D%E5%93%81%E8%A1%8C%E4%B8%8D%E7%AB%AF%E4%BD%86%E4%B8%9A%E7%BB%A9%E4%BC%98%E7%A7%80%E7%9A%84%E5%91%98%E5%B7%A5/","title":"是否要容忍品行不端但业绩优秀的员工"},{"content":"任何团队，沟通其实都是管理者的核心工作。所谓管理，各种管理方法、思路要转化到团队的执行力，其实都是通过沟通去达成的。\n管理者需要投入大量精力在团队的沟通上，沟通是桥梁和连接，是凝聚团队的必然途径。但沟通其实并不是双方谈谈话这么简单\n沟通漏斗 沟通其实是一个信息传递、建立共识的过程，但人与人之间的沟通，存在一个叫沟通漏斗的规律\n如果心里想的，针对我们要沟通的事情，原本的信息量是 100%\n那经过口头或书面表达，传递出来的信息 可能就只有80%\n而对方能接收到的信息，会下降到 60%\n即便接收到信息中，真正可以正确理解，不曲解的 就估计只剩 40%\n再将相关的信息内容转换成实际行动 继续下降20%\n随着时间的流逝，甚至衰减到基本没有\u0026hellip;\n所以信息的传递，其实具有明显的衰减效应，而应对这个沟通漏斗的衰减，就是团队管理中沟通管理的核心。\n包括多种层面的确认；通过流程的定义和里程碑、检查点的设立来检查偏差；定期的复盘来回顾经验教训。\n有效沟通模型 - 乔哈里窗 针对沟通的这种衰减效应，保证双方沟通中能充分地理解一致，达成共识，让大家能尽可能在同一个基础上提升沟通的成效。有一个著名的模型： 乔哈里沟通视窗模型\n在这个模型中，根据沟通双方对信息掌握的程度，分为了四个区块\n我知道，你也知道的信息，处于开放区。 在这个区域中，双方对信息掌握的基础是一致的，也是我们在沟通时，建立信任的基础，这个区域约越大就越不容易产生误会，也就越能帮助我们实现高效沟通。\n我知道，你不知道的信息，在隐藏区。是人都会有秘密，有隐藏在外在之下的真实自我。但有时候，要做到有效的沟通，适度地打开隐藏区，是赢得他人信任并建立高效沟通的一个捷径。\n他人知道，但自己不知道的信息，比如一些别人对你的真实看法，个人的一些弱点，自己并不掌握的一些信息，这些都属于信息的盲点区。盲点区越小，那么自己对事物的判断就越接近真实，做正确决定的可能性就越大。保持探索精神，努力去缩小自己的盲点区。stay foolish, stay hungry\n未知区，则是双方都不了解得信息。在这个区域中的信息既是风险，也可以是团队的发展潜力。\n在乔哈里窗中，要做好高效沟通，其实也就是四句话：\n扩大开放区，开放区越大，大家的共识就越多，就越容易达成一致。是彼此信任的基础\n打开隐藏区，帮助我们增强互信的有效手段，隐藏区的打开，也可以帮助我们扩大开放区。\n缩小盲点区，可以帮助我们更多的了解事实。扩大自我认知，进行自我提升。\n探索未知区，广开言路，多方位、多渠道地去充分掌握信息，尽可能消除未知的风险。\n","date":"2024-10-28T15:18:27+08:00","image":"https://chengxiaqiucao.github.io/post/043-%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86%E4%B8%AD%E6%B2%9F%E9%80%9A%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/Pasted-20241028-1_hu_774f4b7a8bc9b7fa.png","permalink":"https://chengxiaqiucao.github.io/post/043-%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86%E4%B8%AD%E6%B2%9F%E9%80%9A%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/","title":"团队管理中沟通的重要性"},{"content":"在本系列的前几篇，我们梳理了敏捷的起源和目前的主要落地框架。其中 Scrum 框架是敏捷实践的绝对主流，几乎是团队级敏捷实践的事实标准。而规模敏捷框架也大多是在 Scrum 的基础上来进行扩展。因此我们后续的总结将以 Scrum 为基础，探讨敏捷在软件研发过程中落地实践的主要做法运作方式。\n本篇我们将从探讨 Scrum 框架的角色组成来谈起。\nScrum 团队 在 Scrum 中，Scrum 团队只面向一个目的，就是每次都是为了完成产品的一个有价值的目标而存在。Scrum团队作为敏捷组织中有凝聚力的最小生产力单位，Scrum团队内不再有层级结构。团队由跨职能的专业人员组成，团队成员应该具备完成产品目标的所有技能。\n在运作中，Scrum团队会负责所有与产品目标相关的活动，包括同利益相关者的协作、验证、维护、操作、实验、研究和开发，以及其他任何可能需要的活动。Scrum团队是自组织并自我驱动的，以一种可持续的节奏，保持专注并不断交付价值。\n虽然在团队规模上没有明确约束，但通常一个 Scrum 团队的理想规模应该限制在 10人以内。小型团队会有更好的沟通效率，更高的单位生产力。\n在每个迭代（Sprint）中，交付有价值的增量（Increment）是整个团队的职责所在。Scrum 针对这个目标，定义了团队中的三种不同角色：开发团队（Developers）、产品负责人（Product Owner）和 Scrum 教练（Scrum Master）\n产品负责人 Product Owner PO这个角色，从命名也可以看出，是团队工作产物-产品 的拥有者。产品最终要做成什么样子，PO有决定权。 在团队中，他是最终用户的代言人，是需求的来源方、定义者和最终决策人。\n所以PO的职责，包括以下几方面：\n1. 定义需求，管理产品待办清单 作为PO最主要的职责，也就是定义需求。需求是团队工作的源头，也是基础。需求的定义和确定，虽然并不完全是PO独立完成的工作，团队成员也会参与到需求的讨论、梳理和完善中，但PO会是需求最终的决策拍板者。完成定义的需求，也就是产品待办清单PBI(Product Backlog Item), PO 是PBI的管理人和负责人，即便团队也会参与到需求条目的维护和一些技术细节的细化工作中，但PO会对PBI中的每一个条目负责。\nPBI中包含的需求，是所有未实现的需求清单，包括当期和远期的需求，所以在管理 PBI时，PBI的一个重要属性就是它的优先级，定义 PBI 的优先级是PO的职责。PO要根据需求对产品的价值，以及团队的反馈，综合风险和收益，确定每一个需求的优先排列顺序。\n这也是 PBI 以列表形式存在的一个先天优势，每一条需求在列表中都会有一个唯一的位置，这个位置就代表优先级。列表中越排得靠前，代表优先级越高。PO管理待办清单，重要的一点就是要管理好每条需求对应的排列顺序。有效管理的 PBI 是后续迭代启动的基础。\n2. 向团队澄清需求，及时反馈 而对于敏捷团队而言，既然需求是工作的输入，所以 PO 还有一个重要的职责就是向团队解释需求的定义，澄清可能存在的误解或不够清晰明确的描述。\n这个过程是持续贯穿在研发活动中的，既包括前期，在迭代计划会之前的需求梳理精炼会（grooming meeting），也包括在迭代进行中，当成员对需求有疑问或需要决策的时候，能够及时给出反馈和说明。这也是为什么说 Scrum 团队是应该要大家一起工作，保持沟通效率的重要因素。\n3. 维系和利益干系人的关系 Scrum 团队在工作中，必然会牵涉各种利益干系人，包括投资人（各产品各相关部门的主管），客户，终端用户、内部关联部门（销售、售后、客服、法务合规、安全、审计、质量等等）都会有一些和产品的关联，这些不同渠道的意见、声音和反馈可能都会影响到产品相关需求、实现的定义，所以PO是维系这些渠道，和这些不同干系人进行沟通和协调的责任人。这也是为什么作为PO这个角色的成员，应该是一个具备很好沟通能力和协作能力的人。\n4. 工作产出（Increment）的成果确认人 作为产品的Owner，团队每个迭代的工作成果，是否符合要求，能否达到预期的产品要求，是由PO来进行确认的。\nScrum中虽然没有定义单独的测试角色，但测试这个工作其实是包含在开发团队中的，对产品的验收确认，虽然最终是PO拍板，但并不是说 PO会负责这里的测试工作。更多还是根据测试成员的评估或者迭代的演示评审会上的反馈，来判断产品目标是否达成。\n总而言之，PO 作为Scrum团队中一个非常核心的角色，极为关键。 专人专职其实很有必要，在有的敏捷项目中，PO可能身兼数职，游离于团队之外，其实都是没搞清楚这个角色的重要性。\nScrum大师（教练） Scrum Master 在有些似是而非的敏捷项目中，会把SM和传统的项目经理PM混为一谈，认为Scrum Master的工作就是传统PM的作用。这是完全错误的理解。\n1. 并不是团队成员的上级 传统项目中，PM是一个项目的负责人，需要对项目的成功负责。同时PM也会具备相应的项目管理权，对项目成员的工作分配权，对成员的工作成果的考核权，和项目成员是不同层级的关系。\n但是在Scrum中，SM和团队成员是平级的关系，更没有考核、评估权。SM的主要职责是保证团队工作的顺利开展，是作为协调人，以自己对敏捷的专业理解和实践经验，引领团队尽可能高效地完成迭代工作。其实定位是一个服务者的角色。在sprint执行过程中，通过观察和监测迭代运作情况，及时消除阻碍，并鼓舞大家的干劲，必要时给大家打打鸡血。\n2. 敏捷价值观和敏捷实践的推行 作为Scurm大师，敏捷教练。SM的职责是贯彻敏捷的价值观，并把这个价值观传递给所有成员，并以自己的实践经验让团队的运作符合敏捷的原则。\n作为Scrum团队的牵头人，SM会需要负责迭代中的一些主要活动的组织，最主要的就是Scrum中的四大仪式会议。当然还会包括一些其他的需要协调组织的活动，比如一些紧急事项的讨论，重要的澄清、评审等等。在这些活动中，SM通常需要作为主持者，保证活动的效果，避免跑偏。\n3. 团队的防火墙 SM职责中很关键的一点就是，SM需要作为团队的防火墙。这也是作为SM非常有挑战的地方。对一个迭代来说，迭代目标的达成是团队在sprint周期中最重要的事项，迭代过程中的工作都应该围绕这个目标展开。\n但在任何组织中，都难免可能出现一些干扰到团队成员工作的地方。比如一些领导会临时交办一些额外的任务，做临时的人员抽调等等。这时SM需要起到防火墙的作用，要能够将这些任务顶回去或者通过协调，寻求外部支持等保证当前的迭代目标不受到影响。一切以完成sprint的既定目标、保持团队战斗力为目的。而不是让团队成员直接被各种外部事务干涉，影响到当前迭代任务的完成。\n开发团队 Developers Scrum团队的主体其实就是开发者团队Developers Team。但这里的开发者，并不应该理解成传统理解的程序员。Scrum团队的定义，是团队应该具备完成产品目标的所有技能，所以这里的开发者团队，其实是一个笼统的概念。除了程序员，还会包含测试人员、视觉设计，可能还会有架构师、DBA、配置管理等等多种传统项目中不同的角色，但在Scrum中，都统称为Developers。\n1. 具备各种完成目标的技能 所以对于开发者团队来说，首要的职责，就是要具备完成产品目标的各项技能。包括设计、开发、测试、部署、配置等等。但这些工作，是被看作一个整体，不会明确对应到具体的单个成员。也就是团队中成员的技能可能会是综合的，一专多才，不会将团队整体能力建立在对个别成员的依赖上。\n相对传统研发，Scrum的开发团队成员，应该是跨职能的，每个成员都会有承担不同任务类型的技能要求和对应能力。简单来说，这里的开发者团队，每个成员的技能会有侧重点，会承担对应的任务类型，但不绝对，也有可能会要承担非主技能范畴的工作，一切以完成迭代工作目标为目的。\n2. 待办清单和需求的评估 开发团队的另一项职责是要评估PBI中的待办项。\nPBI中需求的实现终归还是开发团队负责，实现的方案、技术、团队的能力成熟度都会对完成每一条需求的实现工作量产生影响。\n而实现需求的工作量，又直接影响需求的完成和交付，所以在敏捷中，对需求的估算是一个重要的事项。\n这里的估算就是开发团队的主要职责之一。在Scrum中估算一般会发生在需求澄清会或者计划会时完成。可以通过经验估算法或者按计划扑克法尽可能客观地评估出每个需求的实现复杂度和工作量。\n估算的准确度会直接影响迭代目标的完成情况和迭代运作的健康水平。也是开发团队成熟度的一个指标。\n3. 目标分解和任务认领 在PBI中，需求主要是业务层面的要求。但其具体的实现方案和实施，通常还需要拆分成不同的任务，比如前端任务、设计任务、后端任务、测试任务等等。这些都需要开发团队来完成任务的分解和通过自组织的认领、分配。这个工作一般会在计划会上，团队集体完成分派和认领。\n4. 完成承诺，交付价值 最后就是完成迭代的承诺并交付产品增量，提供产品价值。保质保量地完成迭代计划时承诺的既定目标，是开发团队整体工作的核心。迭代的承诺达成率是一个Scrum团队是否成熟，Scrum敏捷落地是否成功，最直接的一个观察指标。\n总结 以上就是对Scrum框架中三大角色，其各自职责和要求的分享。用三句话提炼总结就是：\nPO负责让大家做对的事 开发团队负责把事做成 SM负责让团队把事做好 ","date":"2024-10-25T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/agile_dev_team_hu_c5fef09a131c92bb.png","permalink":"https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/","title":"敏捷Scrum中三大角色"},{"content":"时至今日，互联网已经是大家日常生活中不可或缺的一部分，购物、点餐、刷剧、网课，已经融入了我们生活的方方面面。但网络具体是怎么工作的呢？ 特别是我们具体从事软件研发、ICT行业的同学，理解和掌握这个我们产品运行的基础设施尤为必要。\n本文，我们会力争用最简单易懂的方式，弄清网络协议的地基：OSI七层模型 和 TCP/IP四层模型\n网络的起源 要说 OSI 七层模型，我们首先还是要回顾下网络技术本身的发展和渊源。\n现今的网络技术，其实最初是军事目的，萌芽于美苏争霸的冷战背景下。1957 年苏联成功发射第一颗人造卫星，引起美国恐慌，并成立了APRA（Advanced Research Project Agency，美国国防部高级研究计划局）。\n1961 年，苏联又成功试射了 R-16 洲际导弹，使核打击美国本土成为可能。为了应对可能来临的攻击，美国国防部授权 APRA 研发一种 “分布式”的军事指挥系统。\n1966年，这个系统的雏形，被命名为 ARPANET （阿帕网），它也就是现代互联网的前身。\n1969年，美国国防部正式对 ARPANET 开始商业招标，BBN公司中标，并在同年组建了研发中心。\n1969年底，第一个 ARPANET 诞生，将加利福尼亚州大学洛杉矶分校、加州大学圣巴巴拉分校、斯坦福大学、犹他州大学四所大学的 4 台大型计算机进行了互联。人类社会开始进入 “网络时代”。\n在 ARPANET 的继续演进过程中，网络协议的需求被提出，以解决不同节点间的信号识别问题。最开始建立的网络协议叫 NCP （net control protocol）\n1977年，为了解决 NCP 本身要求同构系统的缺点，以及支持的主机数量有限，提出了传输控制协议 TCP V1和V2版本。\n1978年，TCP V3版本基于分层思想，将原先的协议分为了TCP协议和IP协议。前者负责可靠传输，后者负责寻址互联。并进一步演进到稳定的V4版本。\n到1984年，美国国防部将 ARPANET 划分为军用和民用两部分。Internet 至此诞生\n同样在1984年，为了解决不同系统间的互操作问题，国际标准化组织 ISO， 提出了 OSI （Open System Interconnect）开放系统互联模型，并大力推广。\n与此同时，Unix操作系统中捆绑了TCP/IP协议，并随着Unix系统的推广流行，TCP/IP被后续各种操作系统支持，TCP/IP的四层模型成为在实际中被采用更多的实现。\n但 OSI 七层模型和 TCP/IP 四层模型虽然定义不同，但基本上是可以匹配对应的。OSI 模型更偏理论，TCP/IP则实际采用更多。\nOSI七层网络模型 下面我们来具体说明 OSI 七层模型是如何划分，每一层具体的作用和它所处的角色。\n物理层 现代计算机网络技术的基础，其实最底层还是数字电路技术。也就是将电磁波形信号中的电压位对应的高电平信号和低电平信号，处理为二进制中的1和0。也就是二进制中的位 Bit。 我们在电脑、手机上的各种操作，最后通过网络传送出去的，最终实际上就是一连串的二进制信号bits，也就是比特流。\n所以物理层的作用，处理的就是物理意义上的连通，通过网卡、网线，或者光纤、无线电磁波信号等，把我们当前使用的设备，跟目标主机之间的通信通道建立起来。通过这个通道，把比特流传导到对端。\n数据链路层 但是比特流只是一串二进制的信号，这串信号要发去哪里，物理层其实是不知道的。这就是数据链路层的作用了：\n在这一层，首先会把二进制的比特流，以8位一组转换为字节（1个字节对应8位），字节也就是我们计算机存储的基本单位。 按字节分组组织好的数据，定义上把这个叫做帧（frame）。链路层的第一个作用，是对数据进行重组，将比特转换为帧。\n另一个链路层的关键作用，还包括MAC地址的添加。用来标记要发送的数据去到哪里。 这里的mac地址，也叫网络物理地址，是我们每一个网卡，在网卡出厂的时候就被烧录进去的一个唯一地址，不可变更。通过这个唯一的地址，我们就能知道这个数据具体是要发给谁的。就像写信时我们要有个地址一样，这样信件才能知道发到哪里。 但是一开始如果并不知道通过物理层连接的这个设备的mac地址， 就还需要寻址。 寻址是通过寻址协议（ARP），先发送一个广播消息，带上自己的mac地址和从网络层拿到的IP地址，在当前网络中询问要访问的目标IP对应的MAC地址。而对应的目标，在收到广播消息后，就会根据收到消息中的源mac地址，将自己的mac地址发送给他，这样，原来的发送方拿到目标mac地址后，就能够完成数据帧的封装，并根据地址进行正确的传递。\n这一层中，通常会存在二层交换机在当前网络中，用来进行消息的转发。\n所以数据链路层的主要作用就是帧的封装，以及mac寻址。（而通过交换机，还能完成一些差错检测和纠正，以及流量控制的目的）\n网络层 在链路层我们说的寻址，是要在同一个网络下，通过广播喊上一嗓子，对方能够收到，然后才能把mac地址告诉你。但实际中我们访问互联网，目标服务器和自己相隔十万八千里，这时要怎么找到对方并完成通信呢？\n这时就有了不同网络的概念，互联网实际上是由大大小小各种各样不同的网络构成的。在不同网络之间完成通信，你的数据可能会经过很多个不同网络的计算机才能到达对端，同时我们还要找出最快速的路径来让传输的效率更高。\n所以，我们的电脑要联网，其实都有一个IP地址，相对mac地址对应物理地址，IP地址是逻辑地址。ip地址按照IP协议定义，我们目前常用的是IPV4，也就是我们常见的四段十进制点分数字（形如192.168.101.11这样），对应到二进制，它实际是一个32位的二进制数串。 当然，现在因为IPV4地址已经用尽，目前网络IP也在向128位的IPV6转化，但相当长时间内，IPV4还是会继续使用。\n在这32位的IP中，会同时标明当前电脑所在的网络号和主机号。而区分网络号和主机号，是IP地址中子网掩码的作用（具体IP协议的梳理理解，我们后续文章再总结）\n而这里就是网络层的主要作用，会把IP地址封装到数据包中，也就是这一层经过封装的数据叫做包（package）。会包括源IP和目标IP，经过下一层链路层的继续封装，补上MAC地址，就会发送到当前网络的默认网关（也就是默认路由），默认网关收到这个包后，如果发现目标地址不是当前网络的，会通过保存的路由表来选择最优的路径来进行数据包的路由转发。经过一系列的转发，终于到达目标网络，再由目标网络的网关将收到的这个数据包，转换成帧，最后转发给目标主机。\n所以，网络层，主要是完成数据包的封装并进行路由转发。在整个网络通信过程中，极为关键的一层。\n传输层 之前几层我们讨论的数据传输是从主机到主机，但我们在计算机上运行着很多不同的程序，听着歌，开着QQ，打着游戏\u0026hellip; 这些不同的程序都会产生网络通信，那这些传输的数据都怎么正确区分，让不同程序处理各自所需要的数据呢？\n这就是传输层要做的。操作系统会通过端口来对应不同的应用程序，不同应用对应的数据，加上它对应的端口封装起来，这样封装的数据叫做段（segment）。 在段中主要就是添加上了源端口，和目的端口。 此外，段的作用，还有一点，就是应用要处理的数据可能会比较多，要保证数据处理的连贯性和完整性，不可能等所有数据都拿到以后再一次性处理，所以传输层还有个作用就是将数据进行分割，一段一段来传输。在传输层有有两个最重要的协议，一个是TCP（Transmission Control Protocol）、一个是UDP（User Datagram Protocol）。主要是完成对数据进行分段、排序、重组。\n会话层 从这一层向上，是OSI模型中的上三层，主要是程序层面的处理。在TCP/IP模型中，这三层统一看作一层。\n会话层的作用是建立两端通信实体之间的连接，负责通信过程中认证、鉴权以及检查点记录，以便在会话意外中断时还能够继续传输数据。如会话保持、登录信息的记录，断点记录等。\n表示层 表示层，主要是为了消除通信两端不同系统之间的一些差异，负责数据的表示和编解码，实现不同系统之间的数据格式转换和表示方式的统一。通俗地说就是完成两个系统翻译部分的工作。另外还包括像数据的加密和压缩、瘦身，也是定义在这一层来完成。\n应用层 应用层是我们平时使用各种应用时直接接触的一层。主要负责对用户的操作进行处理，完成用户的应用需求。 比如最常用的互联网协议http协议就在这一层。此外还有像邮件协议SMTP、POP3、文件传输协议FTP、远程登录协议telnet等，都是属于应用层。\n用一张图来体现数据在各层的传递如下图\n对OSI模型的通俗理解 以上是从技术原理层面对这个模型进行的分析。 如果用一个我们生活中的例子来类比，会更方便理解：\n双十一到了，要买一个心心念念的笔记本\n首先各种比价，找到一个平台，性价比满意，决定在这个平台购买。 这里这个平台，其实就是应用层，满足购物需求。（应用层：具体的应用服务） 下完订单，卖家在发货前，肯定会把电脑以及各种配件、赠品重新打包好，确保到你手上时没有损坏。那这个打包、保护的过程，就相当于表示层的工作。（表示层：数据编解码，格式化） 在你下订单前，可能还会联系客服，确认赠品，备注发货时间，挑选颜色这些，这个跟客服沟通的过程，就是会话层 （会话层：维持双方的沟通通道） 确认无误，商家给你发货，这时要有一个快递公司负责送货，这个快递公司是顺丰或者四通一达，目的都是负责把笔记本安全按时交到你手上。 这里快递公司的作用就是传输层。（传输层：负责数据的可靠传递） 快递公司怎么送货呢？当然要知道商家地址和买家地址，并根据地址选择最优路径的快递员取货、送货，这就是网络层 （网络层：负责逻辑寻址和路由） 买的笔记本从卖家那里送到了自己所在的区域站点了，这时还会有个快递小哥送货上门，通常都会打个电话，联系你是不是在家。通过电话确定你的具体位置，相当于物理寻址。这是数据链路层 （链路层：物理寻址并传递数据帧） 最后，整个送货的过程中，会用到卡车、送货面包车、小哥的三轮和双腿，这就是物理层，具体的交通工具 （物理层：物理介质传递比特流） 通过这样的类比，我们是不是就比较清楚 OSI 七层模型具体怎么工作了呢？\n","date":"2024-10-21T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/041-%E5%A4%A7%E8%AF%9D%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/Pasted-20241021-2_hu_3fa1662fcfb57b82.png","permalink":"https://chengxiaqiucao.github.io/post/041-%E5%A4%A7%E8%AF%9D%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/","title":"大话网络协议-OSI七层模型和TCP/IP四层模型"},{"content":"前言 在本系列上一篇博文 《敏捷Agile概述，何为敏捷？》 中，我们初步介绍了何为敏捷，敏捷提出的背景和为什么目前得到了广泛的应用。\n但敏捷本身，更多只是一种价值观，是一个思想层面的指引。在组织中实际应用，还是需要借助一些具体的实践模型来进行落地。随着敏捷的发展，其实涌现出非常多不同的实践模型，基于这些模型来组织我们的研发过程，都可以称之为敏捷研发。\n下面，我们将重点梳理下，在敏捷研发实践中，比较常见的一些模型以及它们的优缺点。\n团队级敏捷 敏捷从提出之初，更多是首先从开发者的个人视角出发，在软件开发、协作过程中，希望建立的合作关系和开发理念，这种合作，通常是团队内部的开发协作。所以敏捷初期的主要实践模型，主要还是面向团队级别的实践。\nScrum Scrum其实提出得比较早，1995年，Jeff Sutherland和Ken Schwaber在他们的论文《Scrum_软件开发过程》中首次提出了Scrum框架。这两位也都参与了敏捷宣言的签署。\n随着敏捷的推广，Scrum被广为采用。根据最新版的敏捷状态报告(17th)，Scrum 依然是目前最流行的团队级敏捷框架，调查的团队中使用率超过6成。所以完全可以说，Scrum就代表了敏捷的主流实践。\n我们这个系列后续的敏捷实践分享，也将主要以 Scrum 为准来进行探讨。\nScrum 模型框架的的构成：\n核心过程：以Sprint 为固定研发周期 三大角色定义：PO、Scrum Master、Dev Team 三大工件： PBI（产品待办清单）、SBI（Sprint 待办清单）、Increment（产品增量） 四大工作仪式：计划会、站会、评审会、回顾会 Scrum框架强调以一个固定的短研发周期（sprint），定期地交付产品的增量，通过四种不同的工作仪式来跟踪、协作日常工作，强调团队自组织和紧密、机动的合作关系。\nKanban Kanban 其实起源更早，来源于上世纪四十年代丰田汽车的生产管理理论。强调的是用一种可视化的方式来提高工作效率，同时便于工作流的调整和优化。\nKanban的核心原则是通过可视化的看板向所有成员清晰地展示项目进度和工作分配情况，限制在制品的数量避免过载和积压导致资源浪费，在看板上定义并区分出清晰的工作流程，如任务的创建、分派、执行、测试和完成等。 强调持续集成，通过定期回顾来进行持续改进。\n极限编程（XP） 极限编程（Extreame Programming）简称 XP，是Kent Beck在1996年提出并在自己参与的C3项目中进行了实践。\nKent Beck 进行 XP 实践的C3项目，是克莱斯勒公司的一个薪酬管理系统，项目参与人包括多位后来敏捷运动的重要人物，如敏捷宣言的另两位签署人Ron Jeffries， Ward Cunningham也都参与过该项目。但该项目其实并不成功，延期多个月才交付，并且在运作了一段时间后因为存在严重性能问题，之后被彻底关闭。还是比较讽刺的。\nXP 主要从团队运作、研发过程和开发技术实践三个维度， 定义了13种实践原则，包括持续集成、结对编程、测试驱动开发、客户验收等等，对后续敏捷宣言以及敏捷的12条原则有重要影响。\n精益研发（Lean） Lean Development，精益研发，其实也是脱胎于丰田的精益生产管理理论。\n后来发展到软件领域，主要包括以下7大核心：\n消除浪费：Eliminate Waste\n内嵌质量：Build Quality In\n创造知识：Create Knowledage\n延迟决策：Defer Commitment\n快速交付：Deliver Fast\n尊重他人：Respect People\n整体优化：Optimize Whole\n精益更强调在向用户交付价值的同时尽可能消除浪费，并从更整体的业务环境来看待研发。\n水晶方法（Crystal） 水晶法是Alistair Cockburn于 1991 年为 IBM 开发的一种团队协作和沟通制定指导方针，Alistair Cockburn被认为是敏捷早期的普及者，敏捷宣言发表后，包括Crystal在内的方法开始走入大家的视野。\n水晶方法可细化为透明水晶方法（Crystal Clear）、黄色水晶方法（Crystal Yellow）、橙色水晶方法（Crystal Orange）以及红色水晶方法（Crystal Red）。这几种水晶方法论按照项目重要程度以及参加人员规模进行划分。\nCrystal Clear ： 6人左右的团队 Crystal Yellow：20人左右 Crystal Orange：40人左右 Crystal Red：80人左右 Crystal方法中同样也强调了7大主要特征：\n1. 经常交付\n2. 反思改进\n3. 渗透式交流\n4. 个人安全\n5. 焦点\n6. 与专家、用户建立方便的联系\n7. 自动化测试、配置管理和经常集成的技术环境\n相比于XP、Scrum等，Crystal纪律性较弱，它的主要原则依据团队规模不同会动态变化，所以实际中被应用得并不多。\n除了以上5种常见的团队敏捷框架外，还有类似DSM、FDD等团队级别的敏捷实践模型，但目前应用最广的其实主要还是Scrum。\n敏捷模型虽然多种多样，实际应用其实也并没有非此即彼的排斥性，因为它们更多还是敏捷思想的落地，我们理解这些模型定义背后的出发点，取长补短应该才是更加务实地去进行敏捷实践的方式。\n当然，现代软件的规模其实越来越庞大，仅仅依赖一个小型团队，并不能完成软件产品的系统级研发，这些基于团队级别的敏捷框架，如果应用到大型的软件系统，在组织级别的敏捷，通常并不适用，因此针对这种级别的敏捷，又出现了 大规模敏捷框架， 下一篇我们会继续分享敏捷框架中的这部分框架介绍\n大规模敏捷 以上敏捷模型，是基于敏捷提出之初的一些理念发展而来，主要是面向小规模团队的敏捷实践。但是现代软件规模其实越来越庞大，仅仅依赖一个小型团队，并不能完成软件产品的系统级研发。所以为了整合多个通过的小型团队，敏捷组织又提出了多种不同的大规模敏捷模型。\n相比 Scrum 在团队级别敏捷中绝对优势的主流地位，大规模敏捷框架则显得百花齐放，并没有某种模型占据绝对主流。下面我们介绍其中比较知名的几种规模敏捷框架。\nSAFe 基于最新的敏捷状态报告，SAFe是目前应用最多的大规模敏捷框架，但也只有 22% 左右的占有率。\nSAFe是 Sacled Agile Framework 的缩写， 诞生于2011年，到目前已经更新到 6.0 版本。\n它提供了一整套结构化的方式来对敏捷实践进行扩展，并提供了四种不同的配置以适应不同级别，分别是：\nEssentail：团队级别（中小型项目） Large Solution：大型解决方案级别（大型项目） Portfolio：投资组合级别（产品线） Full：组织级别（企业级） SAFe 框架中，在Scrum 迭代（Sprint）的基础上，引入了PI（Program Increment）和敏捷发布火车（ART）的概念，以一个包含数个 Sprint 的周期，构成PI，通过多个不同Scrum团队的合作，来共同致力完成一个较大规模的产品增量。\n在 Scrum 定义的三大角色PO、Scrum Master、Dev Team之外，SAFe中又定义了产品经理PM（product manager）、发布列车工程师RTE（release train engineer）、方案架构师SA（Solution Architect）、业务负责人BO（Business Owner）等新角色，以管理多个团队和更大规模的产品路线图、技术架构以及跨部门的协调。\nSAFe强调的四个核心价值观：\n一致性（Alignment）：确保组织中的每个人都朝着相同的方向努力，清晰的目标和愿景是关键。 内置质量（Built-in Quality）：从一开始就关注质量，避免后期修复，确保产品在每个开发阶段都符合高质量标准。 透明度（Transparency）：创建一个开放、透明的工作环境，鼓励团队成员间的沟通和反馈。 程序执行（Program Execution）：通过一致的开发和交付节奏来确保程序和产品的顺利交付。 SAFe 以其比较完备的、适应不同规模组织的实践方法论，以及广泛的认证推广，目前在规模敏捷领域，得到越来越多的应用。\nSoS SoS （Scrum of Scrums）其实是一个非常早的规模敏捷模型。2001年（敏捷宣言发布那一年）就由Scrum创建者 Jeff Sutherland提出，并在GE的项目实践中进行了应用。\n这个框架其实理解比较简单。\n本质上是一个同步机制，每个Scrum团队派出一个成员，通常称为大使，这些人再组成一个Scurm，也就是SoS。这个团队同样参照Scrum的原则来运作，有Sprint，站会，backlog等。但SoS的主要关注事项是跨团队的进展、障碍和协调。\nSoS也是目前规模化敏捷中采用比较多的方式，但是它的规模一般也不会太大，5~7个Scrum小组的规模。在其之上还扩展出SoSoS，但这个复杂度就进一步上升，运作起来容易混乱。\nNEXUS 另一个规模框架Nexus， 是由scrum的另一个提出者，scrum之父Ken Schewaber创建，然后通过scrum.org 于2015年推出的，可以说属于Scrum半官方性质的规模敏捷框架。它的提出时间较晚，目前应用得很少，敏捷状态报告中看到只有约 1% 的应用率，推广不利。\nNexus主要是在Scrum的基础上，针对更大范围的团队合作进行了少量改进。框架上本身没有太大的变化，也是主要有几点不同：\n它的主要工作会在跨团队层面完成，包括sprint计划、复盘、回顾， 但站会是分小组来开。\n由3-9个Scrum team组成Nexus team。 规模更大就会难以组织。这些不同 scrum小组会在同一个迭代周期来运作\nNexus引入了一个Nexus 集成团队。这个集成团队，职能和SoS差不多，主要负责不同scrum团队间的工作协调，进展同步。\nNexus 共享同一份产品backlog，只有一个PO角色，在召开计划前，会召开跨团队的需求提炼会。 而工作成果也是同一个increment\n这个框架对团队间的协同要求非常高，而且很多事项是多个Scrum小组共同参与完成并同步，所以效率上较难保证，这可能也是这个框架难以得到更多应用的主要原因。\nLeSS LeSS（Large-Scale Scrum）是一种轻量级的敏捷框架，旨在将Scrum扩展到多个团队，同时保持Scrum的核心原则和简单性，于2005年提出。也是比较早的一个框架\n和NeXus类似， LeSS敏捷框架采用同一个产品列表，所有敏捷团队在同一个Sprint中工作，各团队协同完成这个冲刺。\n但在 LeSS 中，Sprint开始时有2个 Sprint 计划会，第一个冲刺计划会中由各团队派人参加讨论和管理彼此间的依赖及协作工作。第二个 Sprint 才是Scrum团队自己的冲刺。在 Sprint 结束时，同样有2个回顾会，一个是敏捷团队内部的回顾会，一个是整个大型敏捷项目的回顾会。\nLeSS灵活度比较高，相比Scrum来说，保留了Scrum的所有角色并且没有引入新的角色，更加依赖团队的自组织能力。\n相比SAFe等其他框架，LeSS不会引入额外的角色或过多的其他流程，而是通过简化结构来扩展敏捷，但也造成了落地时可操作性上的困难。目前最新的敏捷状态报告中，应用率在2%\n以上就是关于敏捷各种实践模型的梳理和总结。帮助大家可以对敏捷的应用和当前的发展状态，有一个整体上的认知。\n欢迎继续关注这个系列，努力持续更新中~\n","date":"2024-10-18T16:04:07+08:00","image":"https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/scrum_hu_9b09aafaee7f518f.png","permalink":"https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/","title":"敏捷研发模型知多少"},{"content":"Agile 敏捷研发可能是现今 IT行业最为流行，也是被广为应用的研发模型。但实际运作中，似乎和预期总有不少的偏差。所以开一个系列来详细梳理下和 Agile 敏捷研发相关的知识并谈一谈自己的 Agile 的理解。\n敏捷的起源 要谈敏捷，首先我们还是要看看它被提出的背景是什么。\n软件危机 我们知道，在上世纪70年代到90年代，计算机逐渐开始成为普通消费品，开始进入千家万户。以此为契机，计算机软件行业也开始高速蓬勃发展。但同时，随着软件应用规模的增大，其复杂性也急剧增强，这个阶段发生了大量因为软件导致的问题，也就是现在称为的“软件危机”时期。\n软件危机主要表现为：\n超预算 超时 低效 低质量 不满足需求 无法管理、难以维护代码 永远无法交付 而为了应对上面软件危机 中产生的问题，软件工程 开始作为一个学科，快速发展，针对软件研发的各种理论、论文开始涌现。这其中，从制造业的工程管理转化而来的 瀑布模型 以及其衍生而来的 V模型, W模型 占据了主流，影响直到今天\n瀑布模型 但是瀑布模型也存在很明显的缺点，也就是它是一种线性的研发流程，一些影响发布的问题往往要到后期才能暴露。而且这种模型，对风险控制的要求很高，看重计划和流程，所以文档、规范要求非常严格，各种繁文缛节也造成了很大的效率问题。使用瀑布模型，但软件项目失败的例子也依然层出不穷。\n互联网兴起 另外一个背景，就是90年代互联网的兴起。基于互联网的应用，和传统的桌面应用不同，软件发布即送达，且用户群极为庞大。另外互联网的免费策略，使得用户切换同类产品的成本极低，所以互联网应用先天就是一个需求变化极为频繁，对于产品的迭代、更新有极高要求的行业。传统重流程的瀑布模型已经很难适应互联网产品的这种高速的要求。\n正是在以上背景下，敏捷模型应运而生。\n敏捷的历史 图源自smartSheet\n早在上世纪40年代，丰田在它的汽车生产管理上，就采取过不少现在敏捷研发中推崇的理念。最典型的就是kanban。这个kanban的主要作用就是通过可视化的方式管理生产过程和物料，让生产根据需求而不是早期的计划来推动。\n到90年代了，互联网开始兴起。1991年，Crystal水晶方法提出，1994年 动态系统开发方法（dynamic system develop methodology）DSDM被提出。\n1995年, Scrum正式作为一种研发模式被提出，由Scrum之父 ken schwaber 和 Jeff Sutherland共同发表。这也是现在敏捷研发中应用最广泛的一种模式，几乎是敏捷的代名词。\n1996年，XP极限编程 发表，作者是Kent Beck。他也是后面发表的敏捷宣言中排名第一的牛人。敏捷中的很多原则其实都来源于极限编程。题外话，Kent还是著名自动化测试框架Junit的作者。可以说后世的很多自动化框架都受Junit的重要影响。\n2001年，敏捷宣言发表，包括ken，Jeff，kent，还有marting fowler等17个软件开发领域的专家，在美国犹他的雪鸟滑雪胜地共同签署发表。也从此，敏捷开始逐渐走向主流。\n2005， 大型敏捷框架LeSS( large scale scrum) 框架被提出\n2006年， 第一届敏捷中国大会召开，由著名的咨询公司ThoughtWorks牵头。\n2009年，敏捷认证体系DA (Disciplined Agile) 建立\n2011年，大规模敏捷框架 SAFe(Scaled Agile Framework) 被提出。\n2018年， BizDevOps被提出，旨在打通业务到研发的通路.\n发展到现在，敏捷依然在全球范围内广泛传播，但同时，敏捷也暴露了一些本身的问题，所以 Agile 2.0 也已经开始被提及和讨论。\n敏捷宣言 在敏捷的发展中，敏捷宣言的发表是一个里程碑的事件。 从此 敏捷开始逐步走入实践领域并逐步得到广泛应用\n敏捷宣言官网\n个体和互动高于流程和工具： 敏捷更加强调个体的作用，强调个体的主观能动性比靠流程和工具能更加高效和有用\n工作的软件高于文档：这里说详尽的文档，就是指的是很重的僵化的文档，写出来也没多少人真的去看的繁文缛节。而工作的软件，是指能实际运行的软件，\u0026ldquo;百闻不如一见\u0026rdquo;\n客户合作高于合同谈判： 强调的是沟通，开发者是软件生产者，客户是使用者，二者更多直接的沟通才能更好地去确定做的东西和你要的东西是不是一样的，而不是提前靠所谓的合同来约定\n响应变化高于遵循计划，就是变化是肯定存在的，一个好的软件开发过程应该去适应这种变化，而不是按部就班一条道走到黑。\n签署敏捷宣言的17位签署人，都是在其领域内有很高成就和声望的专家，这也为敏捷的广泛传播打下了良好的基础。 但是这17人主要都是软件开发领域的专家，对于整个软件产品的生命周期而言，其他角色的缺位，也为敏捷本身的适应性埋下了局限性上的不足。\n敏捷 12 原则 除了敏捷宣言外，敏捷还针对实际的应用提出了12项基本原则\n客户满意 ： 以用户的价值位导向。客户满意意味着软件的价值得到体现，软件体现出价值是我们研发软件的最终目标。\n拥抱变化： 变化是一定存在的，与其控制变化，不如接受变化。\n频繁交付： 小步快跑，快速交付，快速得到反馈，方便及时纠偏\n相互合作（业务和研发）： 业务的需求方，用户代表和生产者、开发团队应该一起工作。及时确认\n积极的团队：自我激励的团队，团队本身是积极主动的，没有内耗\n面对面：及时沟通，百闻不如一见\n可工作的软件：所见即所得\n稳定的节奏：固定的节奏能更好地形成默契\n好的设计（技术卓越）：强调软件开发的内功，通过的更好的设计解决问题，降低风险。强调技术卓越\n简单即美：软件不应该过度开发，逐步满足用户的需求\n自组织：研发过程的控制权要在开发者自己手中，不要有各种行政命令。 Scrum之父ken 曾经明确表明过，敏捷的目的就是要干掉经理这个职位。😂😂\n反思和调整: 这条是自我组织的补充，敏捷运作过程种，不可避免也会出现各种失败或者运作不畅的地方，这时要及时回顾和反思，及时调整补救。\n笔者对敏捷的看法 敏捷虽然如今在业界广为应用，但也并不是银弹，我们依然要辩证地看待敏捷，天底下没有放诸四海而皆准的理论和方法。\n它提出的理念和发展出的一些原则和实践出发点是极好的，但并不是所有的情况都适用，应用敏捷依然要根据产品、项目的实际情况来确定应用方式。\n从敏捷宣言和原则中其实也看出来，敏捷本身更多传递的是一种价值观，是软件研发理想的方向，而不是一套方法论。它不是一个指导项目如何运作的执行层面的方法。\n敏捷的提出，更多是从软件开发角度来思考的，是这些开发大牛们基于软件开发视角出发得出的思考结论。但敏捷应用在产品领域，很多做法是过于理想化的，比如和客户一起工作，自组织团队等等，特别在一起传统企业，会面临极大阻力。非组织层面的根本性转变是不可能进行推进的。\n所以，敏捷本身不是银弹，它也不是方法论。而是一种文化层面的思想，真正理想地得到应用，是需要组织层面的变革方可推进，并不是一个可以从十数人的小团队自下而上推行就可以成功应用的实践。\n关于敏捷实际应用，后续还会针对 Scurm 框架进行更多分享。敬请关注。\n秋草观“测”台，观察测试业。（公众号：秋草说测试）\n","date":"2024-10-15T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_principle_hu_c3a48bc303fbfda8.png","permalink":"https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/","title":"敏捷Agile概述，何为敏捷？"},{"content":"最近经常被问到软件测试这个行业的前景，网上也有大量唱衰测试这个行业的声音，很多选择职业方向的同学对是否要进入这个职业也非常迷茫。\n所以开一贴来聊一聊秋草对软件测试这个岗位的要求以及对其前景的看法。\n软件测试到底是个什么样的岗位？ 选择一个行业，首先要了解这个行业存在的目的，到底是提供什么价值的？\n软件测试作为软件行业的一个技术分支，是一个面向软件质量的岗位。\n这个职业存在的目的，是基于质量作为产品的核心属性之一，需要得到最大程度地保证。测试工作就是在产品交付用户前，用于完成对产品质量的评估，尽可能暴露产品中潜在的质量问题，以便产品研发团队进行改进和补救。\n所以软件测试这个工作的目的： 尽可能及时、准确地评估出被测试对象的质量状态\n我的另一篇博文 《软件测试的真正目的》 中对这一点进行了详细的说明，这里不再赘述。\n从软件测试职业的目的和它的价值来说，这个职业不是生产单位，而是保障单位。是通过这个职位关联的各种测试技术，去保障产品，使之不因为质量问题出现损失的一个职业。\n因此，只要质量依然是产品的核心属性，质量问题会影响到产品成功与否，那么测试这个职能就依然是一个必要的技术分支，是软件产品研发中必须包含的一个职能。\n软件测试的技能要求 既然软件测试是一个技术岗位，那么要做好这个工作，离不开掌握各种相关技能。\n基础技能 首先是跟软件研发流程和软件项目运作本身相关的知识。理解软件工程从需求到交付的完整过程，理解项目运作以及测试这个岗位在其中的作用。软件研发生命周期 SDLC 具体是什么？测试生命周期又是什么？传统研发模型和敏捷研发的关系？敏捷有哪些活动等等？ 对测试基础理论的掌握，主要是各种不同的测试方法、测试类型，对各种测试概念的理解 测试工作本身相关的技能要求。包括测试用例、测试报告的编写，Bug的提交要求，故障定级标准、故障处理流程、状态报告\n业务理解能力要求。软件需求的构成要素，产品整体架构和需求的关系，产品的软件设计和功能的关系等，要建立起对产品和业务逻辑的理解。\n有了上述的基础技能，那么就基本达到了完成测试工作的基本要求。\n技术能力 而除了掌握基础技能之外，将测试工作完成好，必然还需要掌握进一步的进阶类的关联知识\n关联的IT技能。主要是操作系统、数据库、网络这几大块。而这每一块都有足够的深度和广度。很少有人能在每个方向上都做到极为精通。但要成长为一个优秀的测试人员。这几部分能力却是不可或缺的。 一些进阶的测试类型，需要建立在更高技术能力基础上的测试类型，主要有性能测试、安全测试以及一些专项测试 自动化测试相关的技能。能够实施自动化，目前已经是测试人员的必备技能了。而自动化能力建立在编程能力和不同自动化类型工具的基础上。 软技能 软件测试也是一个非常强调协作和沟通能力的岗位。因此除了技术能力之外，相关的一些软技能对于能否把这个工作做好、做漂亮也尤为关键。\n测试不等同于检查， 测试能力很重要的部分还包括推理能力、设问能力、观察能力等软技能。细心、发现线索、有探究精神对于测试工作尤为重要。 归纳总结、书面表达能力。 输出故障说明、测试报告等等都是归纳总结和书写能力的表现。测试工作的目的是能够评估出产品的质量状态，而把这个评估出的状态呈现出来，关联的就是这里的书面表达能力了\n协作沟通能力。\n测试工作因为工作性质，会需要频繁地和BA、和开发包括和项目其他成员频繁地沟通和协作，澄清问题，很多时候都需要说服别人理解问题对质量的影响。所以良好的协作沟通也是测试工程师的重要能力组成。\n演示宣讲能力 测试作为产品发布前的最后一道检验程序，很多时候在向用户交付，或者敏捷团队中的演示会环节会需要担负起向其他人员进行产品功能介绍、演示的职责，这种情况下自己的演示宣讲能力就不仅是对个人，也是对团队提供价值的一种能力了\n职业发展通道 从事测试行业，个人的职业发展方向，总体上来说有三个方向。网上有一张测试发展路线图其实比较清晰地说明了测试的成长路径。\n管理路线 这条线其实是主线，在中国国情下，经验、技术、资历达到一定程度，还是会逐步向管理转型，从测试主管、测试经理、测试总监到质量总监、副总，沿这样一条线逐步晋升成长。\n技术路线 而作为一个技术岗位，大多公司其实也提供技术发展通道，通过软件技术路线，从中高级工程师到资深工程师乃至专家工程师，以技术提升得到职业发展。\n业务路线 此外，测试作为研发团队中，对整体业务相对更熟悉的岗位，向业务路线发展也是一个重要的成长通道，从测试分析到业务分析以至项目管理、QA等岗位角色，同样也是适合的发展方向。\n未来的前景 最后，再谈谈很多同学，包括不少测试同行对软件测试这个职业前景的担心，测试是否已经式微？今后的发展方向是否就是逐步淘汰测试？\n传统研发已过时，敏捷研发中并不需要测试？ 其实早几年已经有过一次认为测试岗位可以逐步取消的风潮。“google、facebook裁撤测试团队”，“开发测试人员比例减小到10：1”， 包括流行起来的敏捷研发，也只定义了一个开发团队。似乎测试在现代软件研发流程中已经不再是一个必备岗位。\n其实在敏捷研发中，并没有削弱测试，反而是更加强调了测试，特别是测试前移。包括TDD（测试驱动开发），需求验收标准这样的实践，都在强调功能测试的重要性。只是这些实践，更多是把测试放到开发团队内，而不是一个单独的专职测试团队。不再区分敏捷团队（dev team）中的不同角色，而是强调，团队中应该具备完成产品研发的各种角色和能力。\n也就是说，虽然敏捷中只定义了PO、Scrum Master、Dev Team三个角色。但Dev team中其实应该包含具备各种能力的成员，包括设计人员、开发人员、测试人员，不细分具体的职责，强调的是团队整体，可能有的成员会身兼数职。\n所以，并不是敏捷排斥了测试，而是把包括测试在内的研发活动作为一个整体来看待。我们也可以说敏捷中不再有设计，不再有配置管理等等。\n专职测试？ 而这个变化，是不是又说明专职的测试人员岗位会消失？ 从敏捷的定义中来看，确实如此。就像敏捷中也不再会有专职的设计人员、配置人员，包括开发人员定义一样。从这个意义上，敏捷团队中不再有专门的测试工程师。\n但另一方面，我在其他的文章中也讨论过，敏捷强调团队整体，整体对质量负责，团队自组织完成产品研发的各方面事务。这是提出敏捷概念的这群软件开发大师们的理想，但理想不等于现实。\n现实是术业有专攻，特别是开发和测试这两个职能，先天是比较对立的。\n开发人员更倾向追求确定性。基于确定性的需求，步骤，定义产品的表现。 测试人员则需要基于不确定性来考虑各种可能路径和分支场景，基于未知来评估产品的可能表现。 这两种思维方式上的对立，决定了很难让一个角色很好地完成开发兼测试两种职能。敏捷团队中，依然会需要更偏重测试的角色存在。专职的测试人员必然还会发挥他的专业价值。\n测试人员本身的转型 当然，敏捷的提出，也为测试人员纠正一些原先错误的价值观提供了契机。测试并不是为了发现Bug，也不是仅仅为了验证需求。而是基于产品质量的视角，去评估产品的质量状态，目标还是产品本身的价值体现。测试应该承担起敏捷团队中QA的部分职能。\n自动化测试/AI 会替代测试岗位？ 另一个主要的担心，是随着 AI 的发展，测试岗位是否会被 AI 代替？ 当然不仅仅是测试，其他 IT 岗位包括开发人员也存在类似的担忧。\n坦白说，以现在AI发展的速度，十年后很难说像编程、软件开发还是一个多么依赖强技能的职业，开发产品可能更多是将自己的想法准确地描述给AI，AI根据输入的需求完成实现。\n测试岗位理论上也类似，很多本来程序员会犯的错误，AI在实现的时候先天就会规避掉，所以程序本身的bug将极大减少。但除此之外，测试工作中还有一部分是未考虑到的测试场景，当然AI可以根据需求自行补充很多异常场景，但如果这个场景是强业务相关的，AI可能还是难以靠自身的推演完全覆盖。\n此外，很多异常测试场景是严重依赖测试环境构造的，而这些异常情况的模拟如断网、资源不足、高并发等等，脱离实际操作人员的干预，应该还比较困难。\n还有一点，AI自身的训练，也存在数据毒药的问题，就像现在自动化测试也存在测试脚本本身Bug的问题类似，对AI本身成效的验证，也是属于测试范畴。\n所以从这些角度来看，AI 近期内还替代不了测试工作。\n","date":"2024-10-11T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/035-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E5%89%8D%E6%99%AF/TestingCareer_hu_3f66f82878f7f93f.png","permalink":"https://chengxiaqiucao.github.io/post/035-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E5%89%8D%E6%99%AF/","title":"软件测试岗位及其职业发展前景"},{"content":"在质量管理领域，对质量进行改进的一个重要过程就是发现问题并解决问题。这其中，解决问题实践中，一个关键的步骤是根因分析RCA（Root Cause Analysis）。RCA 的方法有很多，常用的有鱼骨图（Fishbone Diagram），亲和图（Affinity Diagram），FMEA（Failure mode and effects analysis）等。\n不过最易于应用，应用最广泛的可能还是 5Why 根因分析法\n5Why 的提出 5Why 方法最早起源于丰田汽车，是丰田之父丰田章男提出的。但被引入主流是丰田生产系统负责人大野耐一的功劳。\n丰田的网站有这样一段说明，描述了大野耐一对这个方法的推崇：\nWhenever a problem cropped up, Taiichi Ohno encouraged his staff to explore problems first-hand until the root causes were found. “Observe the production floor without preconceptions,” he would advise. “Ask ‘why’ five times about every matter.”\n5Why 方法的是基于这样一个基本认识：\n“每个问题背后都有原因，但肤浅的分析只能描述症状。” 为了找到问题背后的根本原因，需要持续的调查，只有得到根本原因，这样才能针对性采取持久的解决方案，使问题不再重现。\n所以 5Why，其实就是我们遇到遇到一个问题，不应该仅仅只从表面上看待导致这个问题的浅层原因，而是要抱着 “打破砂锅问到底” 的精神，探究出它的根本原因。只有解决了导致问题出现的根本原因，才有可能避免问题的不断重复出现。\n举一个软件行业的案例来说， 客户验收发现一个比较严重的功能bug，影响产品的最终交付。这时通过 5Why 方法来分析根本原因：\n客户为什么会遇到这个问题？ 据技术负责人透露，测试团队尚未向开发团队报告任何此类问题\n为什么测试团队无法发现问题？ 测试团队只进行了冒烟测试，并没有对功能做完整的回归验证\n为什么测试团队只进行冒烟测试？ 因为他们没有足够的时间对整个应用程序进行彻底的回归验证\n为什么没有足够的时间进行彻底的回归？ 因为开发提测版本只比最后交给客户验收提前了一天，而彻底的功能测试至少需要 3 天。\n为什么开发在交付前一天才提测？因为其中一个关键功能的实现比预期的复杂，花了更多的时间。\n分析到这里，其实发现了两个根本原因：\n团队成员对工作量的预估出现严重偏差，开发时间估算不足 项目管理上的问题，提测时间比测试预估时间晚太多，牺牲质量，不进行回归就交付给客户。版本准出控制不足。 所以针对分析出来的原因，需要从两方面改进，才能避免类似的情况持续出现。\n提高开发团队对功能实现的估算准确度，包括培训，需求拆分，尽早理解需求等。 项目管理改进，需要加强测试的准入准出控制和风险预防。延期提测需要顺延交付时间；产品未完成回归就进行发布，至少需要完成异常发布的审核流程。 5Why的实施步骤 5Why 方法虽然很简单，但它的实施还是需要遵循一定的步骤流程：\n首先，当然是需要跟问题相关的关键成员要共同来对问题进行分析，这一步应该是需要团队中跟问题相关的关联角色都能够参加。否则可能因为关键人员的缺席导致分析不能继续进行。\n而在确定参与的团队人员之后，还要保证所有人对问题都比较明确，需要分析什么？有哪些背景信息，大家对问题的理解应该达成共识，而不是以不同的理解进入 Why 的讨论环节\n而在具体的分析会议期间中，主持人应该通过合适的提问，来逐步地帮助团队挖掘出真正的原因\n当然，分析问题最终是为了解决问题，所以，我们还要针对得到的根因讨论出对应的纠正措施，以避免同类问题再次发生。\n最后，纠正措施的实施成效怎么样，也需要有对应的举措、时间节点来进行跟踪，对根因分析的效果进行检验确认。\n通过这样一个过程，才是一个完整的、基于 5Why 方法的根因分析实施过程。\n实施 5Why 的注意事项 5Why 方法虽然简单，但在实践中，其实并不容易做好，这里有一些需要注意的关键点：\n团队活动 5Why 分析是一个团队活动，需要跟问题相关的人员积极参与，只有跟问题分析路径上的关键角色能给出有效的答案才能保证分析链路的有效\n并非高效方法 这个方法虽然理解上很简单，但因为是团队活动，且跟问题的各种背景信息是否充分紧密相关。所以包括信息收集、人员召集以及会议上的头脑风暴，都是需要时间投入的，并不是一个高效、快速得到结论的活动，有时甚至要进行多次会议讨论。\n主持人的经验 5Why 方法是否能成功，很关键的一个角色是会议的主持者，这个角色应该对 5Why 方法有充分理解并且对问题相关领域比较熟悉，能够引导团队在正确的方向上去挖掘根本原因。避免过度发散\n对事不对人，避免责任推卸 根因分析不是定责，也就是会议的重点是为了发现将来改进的要点，而不是界定当前问题的责任，避免把分析会变成责任推协会和甩锅会\n关注可控因素 根因分析，得到的根因应该是可以采取措施的一些可控的因素。而不是找到一些根本无法完成修正的不可抗因素。比如说人手不足了，根本原因是公司效益不好，而公司效益不好是经济下行.. 结论会变成不了了之\n总而言之，5Why 分析法是一个简单实用的根因分析方法，但并不是高效方法，并且它的有效性跟团队成员的齐心合力和实施方式关系紧密。只有理解它的内部逻辑，根据团队的实际情况，有选择地实施才能真正起到应有的效用。\n分析模板 附上两个常见的分析模板，供大家参考\n","date":"2024-10-05T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/027-%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%845why%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90%E6%B3%95/5why_hu_5ca8428d65848cdc.png","permalink":"https://chengxiaqiucao.github.io/post/027-%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%845why%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90%E6%B3%95/","title":"不可不知的5Why根因分析法"},{"content":"\n前言 web自动化测试领域，最核心的其实是浏览器的驱动方法。现在最流行的是已经被W3C标准化的webDriver，而占据浏览器垄断地位的Chrome其实也有自己的一个标准协议，也就是CDP（chrome devTools protocol），它可以提供更比WebDriver更底层的对浏览器的控制。google 自己的自动化测试工具 puppeteer 其实就是基于 CDP 进行的自动化实现。\nWebDriver的发展历程 跟随 Selenium 发展起来的 webDriver 协议是目前 Web 自动化测试领域的事实标准。而这一历程也是逐步发展而来的。\n2004 Selenium 诞生 2006 WebDriver 作为一款工具诞生 2009 google自动化测试大会，Seleium 和 WebDriver 合并为一个项目，发布Selenium 2.0 2016 Selenium3 发布，彻底抛弃1.0中的Selenium RC 2018 W3C标准组织吸纳了WebDriver为标准协议 2021 Selnium 4.0发布，取消了WebDriver原先的Json Wire协议，全面采用W3C webDriver JavaScript和Node.js壮大， 自动化测试百花齐放 而随着 Web 页面的前端开发越来越依赖 JavaScript，一批新的自动化测试工作也逐渐推出，包括WebdriverIO、Appium、Nightwatch、Protractor（已废弃）、Testcafe、Cypress、Puppeteer 和 Playwright 等新的自动化解决方案应运而生。\n自动化工具的两大流派 以上这些自动化工具，根据它们运行的层级，可以分为下面两大流派\n上层控制：在浏览器中执行 JavaScript 的工具。例如，Cypress 和 TestCafe 利用 Web API 和 Node.js 来直接在浏览器中运行测试。 底层控制：通过在浏览器之外执行远程命令的工具。当工具需要更强的控制力时（例如打开多个标签页或模拟设备模式），此时它们需要执行远程命令，以通过协议控制浏览器。 两种主要的自动化协议为 WebDriver（W3C） 和 Chrome 开发者工具协议 (CDP)。分别以 Selenium 和 puppeteer 为代表 WebDriver 和 CDP 的对比 webDriver 工作原理 基于 WebDriver 协议的自动化测试工具，需要一个专门的浏览器驱动，通过浏览器驱动来实现跨不同浏览器的标准协议。工具和驱动之间通过 http 协议交互。\n也就是说，我们在web页面上完成的相关操作，实际上是自动化工具将其转换为了一个符合 webDriver 协议的 http 请求，再通过具体的driver驱动浏览器完成动作。\n比如一个页面点击操作，实际是向对应浏览器驱动发出如下请求：\n1 2 3 4 5 # WebDriver: Click on a coffee element curl -X POST http://127.0.0.1:4444/session/:element_id/element/click -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39;{}\u0026#39; 但对于一些底层的控制，如浏览器本身的一些事件如新开窗口等，因为 webDriver 协议基于 http 请求，就很难处理。\nCDP工作原理 而 CDP，它原先并不是专门应用于自动化测试目的，是为 chrome 浏览器的开发者工具的调试功能设计，只是后来被 puppeteer 用于了自动化测试。相比 Webdriver ，它是基于 WebSocket 直接和基于 chromium 的浏览器实现底层通信，可以双向传递，能提供更快速和更底层的控制。完成一些 webDriver协议 无法处理的动作。\n底层控制：\n捕获控制台消息 拦截网络请求 模拟 Device Mode 模拟地理定位 \u0026hellip;.. 页面操作，实际上是转换为了一系列 CDP 命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // CDP: Click on a coffee element // Mouse pressed { command: \u0026#39;Input.dispatchMouseEvent\u0026#39;, parameters: { type: \u0026#39;mousePressed\u0026#39;, x: 10.34, y: 27.1, clickCount: 1 } } // Mouse released { command: \u0026#39;Input.dispatchMouseEvent\u0026#39;, parameters: { type: \u0026#39;mouseReleased\u0026#39;, x: 10.34, y: 27.1, clickCount: 1 } } 但是，虽然提供了底层支持，但 CDP 协议最大的问题就是只能支持 Chromium 内核浏览器，并不是一个开放标准。 此外 CDP 协议也设计的比较复杂，不太适合直接从编码层面调用。\n何为WebDriver BiDi？ 基于 WebDriver 协议和 CDP 协议各自的优缺点，自动化测试领域目前正在讨论推出全新的标准。也就是 WebDriver BiDi。\n这个协议的目标是兼顾 WebDriver 和 CDP 协议的优点，提供如下特性（愿景）：\n跨浏览器支持 双向信息传递 作为通用标准，纳入W3C 提供底层控制 以自动化测试为目的，更简洁方便地通过API调用 支持各种工具和浏览器 目前这个协议还在协商、开发阶段。但已经引入了各大主流浏览器厂商、测试工具和服务提供商的参与，可以预见，将会是 Web 自动化测试领域下一个重大更新！\n参与厂商：\n目前的最新的进展是 2024-09-23 推出的草案版本。 从草案内容来看，目前还处于相对早期阶段，短期内应该不会正式推出，所以相当长时间内， WebDriver 依然会是web自动化测试工具的事实标准，但相信BiDi将会是后续的主要发展方向。\n其实从 近期 Selenium 4的更新源码中，已经可以看到对BiDi协议的支持扩展方法了\n我们将长期关注这一标准的发展趋势和对目前自动化测试技术的影响。\n","date":"2024-10-03T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/026-%E5%A4%A7%E8%AF%9Dchrom%E5%BC%80%E5%8F%91%E8%80%85%E5%8D%8F%E8%AE%AEcdp/","title":"WebDriver将退出历史？BIDI登场"},{"content":"\n我们浏览网站资料的时候，发现有价值的文档，经常需要把材料保存下来。直接复制其实比较麻烦，况且有的网站还做了限制，不方便直接保存。这时将页面直接保存为 PDF 格式的文件是一个很好的需求。\n通常的做法是需要借助一些浏览器插件或者打印扩展来实现，这里我们学习自动化的话，其实利用 puppeteer 就可以方便地实现这个目的。再加上工具的自动化加持，绝对是爬取并保存重要资料的利器。\nPuppeteer用法 关于 Puppeteer 工具的基本用法，在我之前的博文 自动化测试工具Puppeteer简介 中已有较全面介绍，大家可以参考。\npdf() 的基本用法 在 Puppeteer 中保存 pdf 文件其实非常简单，通过调用 puppeteer 内置的 pdf() 方法就可以将当前页面保存为一个pdf文件\n官方给的案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 (async () =\u0026gt; { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(\u0026#39;https://news.ycombinator.com\u0026#39;, { waitUntil: \u0026#39;networkidle2\u0026#39;, }); await page.pdf({ path: \u0026#39;hn.pdf\u0026#39;, format: \u0026#39;letter\u0026#39;, }); await browser.close(); })(); 用来访问一个技术新闻聚合网站，并将页面保存到 hn.pdf 文件中\nPaperFormat 上面的例子中有个参数 format， 这个参数其实是指定保存的页面大小，可以取值为一些默认的打印页面大小，取值清单和对应的大小如下(单位英寸)：\nLetter: 8.5in x 11in Legal: 8.5in x 14in Tabloid: 11in x 17in Ledger: 17in x 11in A0: 33.1102in x 46.811in A1: 23.3858in x 33.1102in A2: 16.5354in x 23.3858in A3: 11.6929in x 16.5354in A4: 8.2677in x 11.6929in A5: 5.8268in x 8.2677in A6: 4.1339in x 5.8268in PDFMargin 除了 format， 还可以像打印时设置页边距，设置 margin 属性, 对应取值\nProperty Modifiers Type bottom optional string | number left optional string | number right optional string | number top optional string | number 上面的代码加上页边距设置： 1 2 3 4 5 await page.pdf({ path: \u0026#39;hn.pdf\u0026#39;, format: \u0026#39;A4\u0026#39;, margin: {\u0026#39;left\u0026#39;: 80, \u0026#39;top\u0026#39;: 40}, }); 可以看到页边距也进行了调整 PDFOption 除了上面两个常用的调整参数外，这个方法其实也提供了其他更丰富的设置，基本可以实现我们保存 pdf 文档时的各种样式设置需要。\n比如 scale 参数可以设置页面缩放，取值为0.1 ~ 2:\nscale: 0.5,\n其更多的设置参数，这里不再验证，清单如下：\nProperty Modifiers Type Description Default displayHeaderFooter optional boolean Whether to show the header and footer. false footerTemplate optional string HTML template for the print footer. Has the same constraints and support for special classes as PDFOptions.headerTemplate. format optional PaperFormat Remarks:\nIf set, this takes priority over the width and height options. letter. headerTemplate optional string HTML template for the print header. Should be valid HTML with the following classes used to inject values into them:\n- date formatted print date\n- title document title\n- url document location\n- pageNumber current page number\n- totalPages total pages in the document height optional string | number Sets the height of paper. You can pass in a number or a string with a unit. landscape optional boolean Whether to print in landscape orientation. false margin optional PDFMargin Set the PDF margins. undefined no margins are set. omitBackground optional boolean Hides default white background and allows generating pdfs with transparency. false outline optional boolean (Experimental) Generate document outline. false pageRanges optional string Paper ranges to print, e.g. 1-5, 8, 11-13. The empty string, which means all pages are printed. path optional string The path to save the file to.\nRemarks:\nIf the path is relative, it\u0026rsquo;s resolved relative to the current working directory. undefined, which means the PDF will not be written to disk. preferCSSPageSize optional boolean Give any CSS @page size declared in the page priority over what is declared in the width or height or format option. false, which will scale the content to fit the paper size. printBackground optional boolean Set to true to print background graphics. false scale optional number Scales the rendering of the web page. Amount must be between 0.1 and 2. 1 tagged optional boolean (Experimental) Generate tagged (accessible) PDF. true timeout optional number Timeout in milliseconds. Pass 0 to disable timeout.\nThe default value can be changed by using Page.setDefaultTimeout() 30_000 waitForFonts optional boolean If true, waits for document.fonts.ready to resolve. This might require activating the page using Page.bringToFront() if the page is in the background. true width optional string | number Sets the width of paper. You can pass in a number or a string with a unit. ","date":"2024-10-03T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/029-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8B%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5%E4%B8%BApdf/","title":"自动化测试奇技淫巧之保存网页为PDF"},{"content":"在企业管理、软件研发过程中，经常会需要进行各种业务流程梳理，而流程图就是梳理业务时必要的手段，同时也是梳理的产出。但在不同的情况下适用的流程图又不尽相同。 本文我们就一起来总结一下8 种最常见的流程图类型\n数据流程图 数据流程图（Data Flow Diagram） 是一种用于描述系统中数据流动和处理过程的图形。一般主要用于分析和设计信息系统，帮助理解系统的功能以及数据的输入、输出和存储\n状态迁移图 状态迁移图（State Transition Diagram） 通常用在业务对象有较多不同的状态，为了梳理不同状态之间的迁移关系和触发条件。 比如订单的状态迁移：\n过程流程图 过程流程图（Process Flow Diagram） 也就是我们通常所说的一般流程图。是用于描述和分析业务流程、工作流程或系统操作的图形。它通过图形符号和连接线展示流程的各个步骤及其顺序，帮助理解和优化过程\n泳道流程图 泳道图（Swimlane Diagram） 是一种用于描述和分析跨部门或跨职能流程的图形。通过将不同的\u0026quot;泳道\u0026quot;分配给参与者或部门，通过泳道流程图清晰地展示了各方在整个流程中的角色与责任\n工作流图 工作流图（Workflow Diagram） 是一种用于描述工作流程和业务过程的图形，通常用于显示任务的顺序、参与者的角色以及任务之间的逻辑关系。它帮助团队理解和优化工作流程，确保任务的高效执行\n比如代码版本控制管理中的 gitflow 就是一种典型的工作流图\n时序流程图 时序图（Sequence Diagram） 是一种用于描述对象之间交互的图形，特别强调时间顺序。它通常用于建模系统中对象或组件之间的动态行为，特别是在软件工程和系统设计中。\n系统架构图 系统架构图（System Architecture Diagram） 是一种用于描述系统各个组件之间关系和交互的图形。它提供了系统的整体视图，帮助开发团队、项目经理和利益相关者理解系统的结构和设计\n组织结构图 组织结构图（Organizational Chart） 是一种用于展示组织内部各个部门、职位及其相互关系的图形。它帮助员工、管理层和利益相关者理解组织的层级结构和工作关系\n","date":"2024-10-01T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/030-%E5%B8%B8%E8%A7%81%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/Pasted-20241001-2_hu_a301f4fa7d0c4bf8.png","permalink":"https://chengxiaqiucao.github.io/post/030-%E5%B8%B8%E8%A7%81%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8/","title":"常用流程图类型及其作用"},{"content":"前言 自动化测试发展到如今，各种自动化测试工具层出不穷。Selenium 无疑是其中的佼佼者，从 2016 年至今，全球流行自动化测试工具排行榜中，Selenium 一直占据着最流行工具的头把交椅。selenium 基于 webdriver 协议，以其免费、开源和强大的功能和扩展性，同时因其创立者著名咨询公司 ThoughtWorks 公司的力推，在行业得到了广泛的应用。\n但在 ThoughtWorks 公司数年前发布的技术雷达（全球技术趋势的分析指南），在 E2E （端到端测试）领域中，指出了 后 Selenium 时代的一些后起之秀，其中就重点提及了Puppeteer。\nWe keep receiving positive feedback on \u0026ldquo;post-Selenium\u0026rdquo; web UI testing tools such as Cypress, TestCafe and Puppeteer.\n\u0026hellip;\nWe have good experience using \u0026ldquo;post-Selenium\u0026rdquo; web UI testing tools such as Cypress, TestCafe and Puppeteer.\n\u0026hellip;\n虽然 Selenium 是 TW 公司自家产品，但是随着前端技术的发展， Selenium 也呈现出对浏览器依赖度高、对单页面类应用掌控能力不足、基于 WebDriver 协议的通信效率不高等缺点，新一代的测试工具也逐渐进入行业视野。本文我们就一起来了解一下三驾马车中的第一个： Puppeteer\nPuppeteer 简介 在介绍 Puppeteer 之前，我们先了解一个背景：headless，也就是无头浏览器。很早之前，在前端测试和爬虫领域就存在无头浏览器的需求，也就是不需要浏览器的界面，纯代码环境下实现浏览器内核操作。特别是 UI 自动化测试以及希望静默完成浏览操作的场景下非常有用。当时最流行的开源 headless 是 PhantomJS，但在 google 开源的 Puppeteer 出现之后，目前 PhantomJS 已经处于终止状态，可以说 Puppeteer 是现在应用最为广泛的 headless。\n那么 Puppeteer 就是 headless 吗？官方对 Puppeteer 有一个简单的定义：\nPuppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the DevTools Protocol. Puppeteer runs headless by default, but can be configured to run full (non-headless) Chrome or Chromium.\n可以看出，Puppeteer 实际上是一个基于CDP协议来控制 Chrome 或 Chromium 的 Node.js 的库，一般用作无头模式，但也能工作在标准模式下。\nPuppeteer 是 Node.js 库，需在 Node 环境下运行代码 基于 Chrome Devtools protocol 仅可控制 Chrome 或 Chromium 可配置运行模式 Puppeteer 架构 如图是 Puppeteer 的官方架构：\n说明：\nPuppeteer 使用 DevTools Protocol 与浏览器 Browser 进行通信。 Browser 浏览器实例可以包含多个浏览器上下文 BrowserContext。 BrowserContext 用于保持浏览器 session，一个浏览器上下文可以包含多个页面。 Page 一个 Page 最起码包含一个 frame，即 main frame，允许存在其他的 frame，这些frame 可以用 [iframe] 创建。 Frame 一个 Frame 最起码有一个 Javascript 执行上下文环境，即默认的执行上下文环境。Frame 允许存在额外附加的上下文环境 Worker 存在唯一的上下文环境，并可与 WebWorkers相互协作。 Puppeteer 的安装 因为 Puppeteer 实际是一个 Node 库，所以安装非常简单：\n1 \u0026gt; npm install puppeteer 在安装时会同时安装 chromium，但因为众所周知的原因，国内会下载失败。所以建议使用国内源安装即可\n1 2 3 \u0026gt; npm install -g cnpm --registry=https://registry.npm.taobao.org \u0026gt; cnpm install puppeteer 安装后可以使用以下命令检查下安装的版本，确认安装正确\n1 \u0026gt; npm ls puppeteer Hello World 通过一个简单的例子看下 Puppeteer 的基本用法。\n因为 Puppeteer 是通过 CDP 协议直接控制浏览器，所以可以实现很多浏览器层面的直接操作，比如下面这段代码，我们控制浏览器 (正常模式) 在访问我的博客网站时弹出一个对话框：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const puppeteer = require(\u0026#39;puppeteer\u0026#39;); HelloWorld(); async function HelloWorld(){ const browser = await puppeteer.launch({ headless:false }); const page = await browser.newPage(); await page.goto(\u0026#39;https://chengxiaqiucao.github.io/\u0026#39;); await page.evaluate(()=\u0026gt;alert(\u0026#39;hello world!\u0026#39;)); await browser.close(); } 具体的 js 语法如 async，await 以及箭头函数等的用法，这里不多介绍了，大家可以先查阅下 js 相关文档。\n通过 node.js 执行这个 js 文件，即可运行。\nnode pupp_sample.js\n执行效果：\nPuppeteer 的主要特性 前文是一个 Puppeteer 的简单示例。我们可以看到 puppeteer 的基本用法。其实 Puppeteer 作为一个强大的 headless，有很多功能，择要总结如下：\n设置浏览器启动参数 在启动浏览器的方法中，我们通过设置一些参数来配置浏览器，常用的参数有：\nheadless: true/false 设置是否启动无头模式\ndevtools: true/false 是否同时启动 devtool\nslowMo：毫秒数。运行在 slow 模式下，每步骤操作间隔\ntimeout: 毫秒数，设置启动超时时间，默认值 30000，即 30 秒\nexecutablePath: 可以使用已安装的 chrome 浏览器替换默认的 chromium 浏览器，此处设置浏览器执行文件路径\nargs：设置 chrome 浏览器支持的配置参数。 支持的详细参数参见：chrome浏览器参数。 比如 args: [\u0026quot;--start-maximized\u0026quot;] 可以设置启动浏览器默认最大化。\n还用上文的代码，修改一下：\n1 2 3 4 5 6 7 8 9 10 11 12 const browser = await puppeteer.launch({ headless:false, devtools:true, slowMo:1000, args:[\u0026#34;--start-maximized\u0026#34;] }); const page = await browser.newPage(); await page.goto(\u0026#39;https://chengxiaqiucao.github.io/\u0026#39;); await browser.close(); 执行后会运行在 slow 模式下，默认开启了 devtool 并且自动进行了最大化。\n模拟设备显示 Puppeteer 还支持设置模拟移动设备界面。通过 page.emulate() 方法可以模拟一些主流的移动设备界面。具体支持的设备清单可以参见 官方提供的清单\n用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import puppeteer from \u0026#39;puppeteer\u0026#39;; import {KnownDevices} from \u0026#39;puppeteer\u0026#39;; iphone15(); async function iphone15() { const iPhone = KnownDevices[\u0026#39;iPhone 15 Pro\u0026#39;]; const browser = await puppeteer.launch({ headless:false, devtools:true }); const pages = await browser.pages(); const page = pages[0]; await page.emulate(iPhone); await page.goto(\u0026#39;https://chengxiaqiucao.github.io/\u0026#39;); } 执行效果：\n除了模拟终端设备的方法。还可以通过 Page.setViewport 来设置分辨率，比如如下语句设置页面采用 1920 * 1080 分辨率\n1 2 3 4 await page.setViewport({ width: 1920, height: 1080 }); 元素定位 作为一款可进行自动化测试的工具，Puppeteer 自然也需要能够识别页面中的相关元素。 Puppeteer 中可通过 page.$(selector) 和 page.$$(selector) 来获取元素。selector 参数使用Css Selector语法来进行元素定位。css selector 的语法可以参见：css selector。如定位博客页面种中的归档栏目：\n1 await page.$(\u0026#39;#main-menu \u0026gt; li:nth-child(2) \u0026gt; a\u0026#39;) 一般在 chrome 中获取元素的对应 selector 描述，可以打开 chrome dev tools，定位到元素后，右键拷贝即可。\n除了使用 selector ，也可以通过 xpath 路径进行识别: page.$x(expression), 如\n1 await page.$x(\u0026#39;//*[@id=\u0026#34;main-menu\u0026#34;]/li[2]/a\u0026#39;) 页面操作及键盘输入 自动化测试中最常用的操作自然是驱动页面执行相关的操作。在 Puppeteer 中可以使用相关已封装的方法完成对应操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 获取焦点 await page.focus(selector); //点击元素 await page.click(selector) await page.tap(selector) //手机端 //输入内容 await page.type(selector, \u0026#39;输入内容\u0026#39;) //直接通过键盘输入 await page.keyboard.type(\u0026#39;输入内容\u0026#39;) await page.keyboard.press(\u0026#39;KeyA\u0026#39;) 获取元素属性 有时候我们会需要获取页面上元素的属性以进行后续操作，可以使用 page.$eval(selector,pagefunction) 实现，如：\n1 2 //获取链接地址 const preloadHref = await page.$eval(\u0026#39;link[rel=preload]\u0026#39;, el =\u0026gt; el.href) 截图 Puppeteer 可以通过 page.screenshot() 方法实现页面截图, 有如下一些非常有用的参数：\npath：指定截图后的文件保存路径\ntype：指定保存的文件类型，jpg或png\nquality：图片质量，0-100\nfullpage：是否保存完整的页面\nclip：指定截图区域 {x,y,width,height}\nomitBackground：去除白色背景\nencoding：图片编码，base64 或 binary\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 const browser = await puppeteer.launch({ headless:false }); const pages = await browser.pages(); const page = pages[0]; await page.goto(\u0026#39;https://chengxiaqiucao.github.io/\u0026#39;); await page.screenshot({path: \u0026#39;screenshot.png\u0026#39;,fullpage:true}) await browser.close(); 保存 PDF Puppeteer 还有一个功能是可以直接将页面保存为 PDF 文件：\n1 2 3 4 5 6 7 8 9 10 11 12 const browser = await puppeteer.launch({ headless:false }); const pages = await browser.pages(); const page = pages[0]; await page.goto(\u0026#39;https://chengxiaqiucao.github.io/\u0026#39;); await page.pdf({path: \u0026#39;blogList.pdf\u0026#39;, format: \u0026#39;A4\u0026#39;}); await browser.close(); 网络请求拦截 Puppeteer 可以对页面的网络请求进行拦截处理。如下例会拦截 博客网站的头像图片加载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const browser = await puppeteer.launch({ headless:false }); const pages = await browser.pages(); const page = pages[0]; await page.setRequestInterception(true); page.on(\u0026#39;request\u0026#39;, request =\u0026gt; { if(request.url().includes(\u0026#39;automnGrass\u0026#39;)) request.abort(); else request.continue(); }); await page.goto(\u0026#39;https://chengxiaqiucao.github.io/\u0026#39;,{timeout:100000}) await browser.close(); 效果如图： 性能指标录制 Puppeteer 另一个非常有用的特性是可以录制下性能跟踪指标，供共享进行性能分析。\n使用非常简单，在需要记录性能指标的操作前后，用 page.tracing.start() 和 page.tracing.stop()标记\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const browser = await puppeteer.launch({ headless:false }); const pages = await browser.pages(); const page = pages[0]; await page.tracing.start({path: \u0026#39;trace.json\u0026#39;}); await page.goto(\u0026#39;https://chengxiaqiucao.github.io/\u0026#39;); await page.tracing.stop(); await browser.close(); 将保存的 trace.json 文件上传到 chrome dev tools 的 performance 栏下，即可进行对应的性能分析。如图： Puppeteer 结合 Jest 自动化测试实例 现在我们来结合一个具体的 UI 自动化测试案例来看看 Puppeteer 的使用。\n测试需求如下：\nCase 1:\n打开 秋草观\u0026quot;测\u0026quot;台 确认站点加载正确 Case2:\n定位归档页面 进入归档栏目 Case3:\n获取当前页面的文章清单并输出到控制台 Puppeteer 是一个 node 的无头浏览器控制库，本身并没有包含测试框架功能，所以一般我们会借助其他测试框架来配合进行测试调度、执行、断言。这里以前端测试中常用的框架 Jest 为例，来看看如何用 Puppeteer 完成上述自动化需求。\nJest 的安装和基本使用不是本文重点，这里不再进行详细说明，大家可以自行搜索学习一下，这里简单说明；\n1 \u0026gt; npm install jest 要使用 Jest，需要在 项目目录下配置 package.json，包含：\n1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;jest\u0026#34; } 默认会自动识别以 .test.js 结尾的脚本作为测试脚本。通过 npm run test 驱动执行即可。\n以下为具体实现代码，关键处已添加注释，不再另行赘述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 const puppeteer = require(\u0026#39;puppeteer\u0026#39;); let browser, pages, page; //Jest 默认超时时间为 5s, 太短。修改为 60s， jest.setTimeout(60000); // 测试 Setup，总体准备动作 beforeAll(async () =\u0026gt; { // 关闭浏览器无头模式，并运行在 slow 模式下 // 每个页面的默认 viewport 设置 1024 * 768 browser = await puppeteer.launch({ headless:false, slowMo:100, defaultViewport:{width: 1024, height: 768} }); //打开新页面 page = await browser.newPage(); //设置页面默认超时 60S await page.setDefaultTimeout(60000); }); // 测试 Teardown，总体清理动作 afterAll(async () =\u0026gt; { await browser.close(); }); //每个用例的 setup 准备操作 beforeEach(async () =\u0026gt; { //todo }); //每个用例的 Teardown 清理操作 afterEach(() =\u0026gt; { //todo }); test(\u0026#39;Case1：进入博客主页\u0026#39;,async ()=\u0026gt;{ await page.goto(\u0026#39;https://chengxiaqiucao.github.io/\u0026#39;); //验证页面正确加载 let title = await page.title(); expect(title).toBe(\u0026#39;秋 草 观 “测” 台\u0026#39;); }) test(\u0026#39;Case2：访问归档栏目\u0026#39;, async ()=\u0026gt;{ await page.waitForSelector(\u0026#39;#main-menu \u0026gt; li:nth-child(2) \u0026gt; a\u0026#39;) await page.click(\u0026#39;#main-menu \u0026gt; li:nth-child(2) \u0026gt; a\u0026#39;); //等待加载完成 await page.waitForFunction(() =\u0026gt; { return document.readyState === \u0026#39;complete\u0026#39;; }); }) test(\u0026#39;Case3：获取文章清单\u0026#39;, async ()=\u0026gt;{ //css selector 定位到 测试 栏目并打开 const ArticleTitles = await page.$$eval(\u0026#39;h2.article-title\u0026#39;, els =\u0026gt; Array.from(els).map(el =\u0026gt; el.textContent)); console.log(ArticleTitles); }) 执行输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 PS C:\\\u0026gt; npm run test \u0026gt; test \u0026gt; jest console.log [ \u0026#39;大话Https协议\u0026#39;, \u0026#39;软件分支策略和集成模式梳理\u0026#39;, \u0026#39;Git工作原理和常用指令\u0026#39;, \u0026#39;Pytest中自动指定可引用fixture\u0026#39;, \u0026#39;用SeleniumBase制作产品Demo\u0026#39;, \u0026#39;适合用来自动化测试练手的项目\u0026#39;, \u0026#39;用Typer快速开发python命令行应用\u0026#39;, \u0026#39;PostmanV11更新便览\u0026#39;, \u0026#39;Selenium Manager用法详解\u0026#39;, \u0026#39;理解敏捷宣言背后的文化逻辑\u0026#39;, \u0026#39;如何及时掌握各种常用框架的最新变化？\u0026#39;, \u0026#39;软件测试的目的到底是什么？\u0026#39;, \u0026#39;Pytest中fixture的范围\u0026#39;, \u0026#39;Pytest使用Fixture进行参数化及中文乱码问题\u0026#39;, \u0026#39;Win11操作小技巧二则\u0026#39;, \u0026#39;Hugo+Github搭建博客小记\u0026#39;, \u0026#39;AI测试之TestGPT\u0026#39;, \u0026#39;提 Bug 的艺术\u0026#39;, \u0026#39;Postman高级篇\u0026#39;, \u0026#39;Postman自动化篇\u0026#39;, \u0026#39;Postman进阶篇\u0026#39;, \u0026#39;Postman基础篇\u0026#39; ] at Object.log (pupp.test.js:60:13) PASS ./pupp.test.js (14.525 s) √ Case1：进入博客主页 (5420 ms) √ Case2：访问归档栏目 (4011 ms) √ Case3：获取文章清单 (2464 ms) Test Suites: 1 passed, 1 total Tests: 3 passed, 3 total Snapshots: 0 total Time: 14.578 s, estimated 15 s Ran all test suites. 结语 以上就是 关于Puppeteer 的基本用法介绍。可以看到 Puppeteer 作为 chrome 官方出品的浏览器控制库，功能强大，可以从浏览器底层完成很多控制操作。无论是 UI 自动化还是作为爬虫，都大有用武之地。直接基于 Node.js 环境运行，安装运行简便。对于针对浏览器前端的 E2E 测试来说，Puppeteer 是一个上佳的选择。\n不过 Puppeteer 作为一个控制库，在自动化测试本身的框架构成上比较单一，一般需要和其他框架配合使用。\n关注 城下秋草， 测试技术不迷路~~\n","date":"2024-09-30T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/028-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7puppeteer%E7%AE%80%E4%BB%8B/puppeteer_hu_9259f3efcfd71706.png","permalink":"https://chengxiaqiucao.github.io/post/028-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7puppeteer%E7%AE%80%E4%BB%8B/","title":"自动化测试工具Puppeteer简介"},{"content":"大家现在访问网络，浏览网页，注意一下的话，网址前面基本上都是一个 https:// 的前缀，这里就是说明这个网址所采用的协议是 https 协议。那么具体应该怎么理解 https 呢？ 本文我们就力争能清楚地解释明白这个我们目前应该最广的协议。\n理解HTTP协议 要解释 https 协议，当然首先应该知道 http 协议。http 协议可以说是现代互联网的基础。在现代网络的 OSI 七层模型中，http 是典型的第 7 层应用层协议。也就是它是基于网络通信的实际应用，比如浏览器呈现网页内容，这就是网络通信的具体应用。\n如下图分别是 http 协议的消息请求和响应报文的协议定义格式：\n访问百度的请求解析如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 GET https://www.baidu.com/ HTTP/1.1 #请求方法 URL HTTP协议版本 Host: www.baidu.com #请求服务器地址 #以下是消息头内容 Connection: keep-alive #连接方式：长连接 Cache-Control: max-age=0 #请求缓存控制，需确认请求内容是否有修改 Upgrade-Insecure-Requests: 1 #支持https协议 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36 #请求客户端，浏览器版本 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 #支持的响应内容类型 Accept-Encoding: gzip, deflate, br #支持的编码类型 Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 #支持的语言 Cookie: BAIDUID=C0A2... #携带的cookie信息 #未携带请求消息体，body为空 响应解析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 HTTP/1.1 200 OK #协议版本 消息状态码 状态描述 Bdpagetype: 2 Bdqid: 0x8707d7d80001f34e #自定义消息头 Cache-Control: private #缓存控制策略 Connection: Keep-Alive #长连接 Content-Type: text/html;charset=utf-8 #响应内容类型 Date: Sat, 22 Dec 2018 08:54:51 GMT #响应时间 Expires: Sat, 22 Dec 2018 08:54:51 GMT #过期失效时间 Server: BWS/1.1 #服务器系统及版本 Set-Cookie: BDSVRTM=372; path=/ Set-Cookie: BD_HOME=1; path=/ Set-Cookie: path=/; domain=.baidu.com #设置客户端cookie Strict-Transport-Security: max-age=172800 #严格安全传输，有效时间 X-Ua-Compatible: IE=Edge,chrome=1 #兼容浏览器版本 Content-Length: 191722 #消息体长度 #以下消息体内容 \u0026lt;!Doctype html\u0026gt; \u0026lt;html xmlns=http://www.w3.org/1999/xhtml\u0026gt;\u0026lt;head\u0026gt; ... 关于 http 协议的详细说明，可以参照我之前的博文 接口测试工具Postman-基础篇中关于 http 协议基础的部分\n那这里其实请求的地址 Url 是 https://www.baidu.com， 是https协议，为什么这里又说它是 http 协议呢？ 这两者到底是什么关系？\nHTTPS协议和TLS、SSL 其实 https 协议是指 HyperText Transfer Protocol over Secure Socket Layer，也就是基于SSL之上的HTTP协议。\nSSL(Secure Socket Layer) 指安全套接字层，是互联网鼻祖公司网景（Netscape）提出的为网络通信提供安全性和隐私保护的标准协议。 发展到 SSL3.0版本后，标准组织 IETF 对 SSL 协议进行了标准化，并重新命名为 TLS(Transport Layer Security，传输层安全)。目前更新到 TLS1.3 版本。\n所以说SSL和TLS其实是一脉相承的，可以认为二者其实是不同时期的同一个协议。而HTTPS协议其实就是：\nHTTPS = HTTP + SSL/TLS\n为什么需要 https 协议呢？ 因为http协议本身在传输过程中，传递的信息基本都是透明的，传输过程中的任何节点，其实都可以看到传输的消息体内容。\n因此为了安全起见，就有了对传输内容加密的需求，SSL/TLS 协议的作用，其实就是为了保护这个内容安全而推出的。\n从 TLS 协议的命名也可以看出，它其实是在 TCP 协议（传输控制协议）的基础上，增加了安全特性的一个协议。\nHTTPS 协议基于HTTP协议，所以它还是属于应用层协议，而TLS 是在第四层的TCP协议基础上，一般认为是属于第五层即会话层。\n通过TLS，可以实现网络通信传输过程中，通信数据的加密\n关于加密 那么理解 https 协议，这里也就是要搞清楚 TLS 是怎么对通信数据完成加密的。\n对称加密 我们正常理解加密，就是通过双方约定的一个规则，也就是通过加密算法，把原始字串变更为一个只有通信双方知道的密文，这样其他人即便知道通信内容，就并不能知道原始的信息。\n比如我们看谍战片，传递情报一般都有个重要的东西叫做 密码本, 这里密码本其实就是加密算法，也就是密钥。\n这种加密方式，双方是对等的，对通信内容加密和解密使用的是同一个密钥，因此叫 对称加密\n但这种加密方式，有一个最大的问题，就是这里的密码本。谍战片中，情报人员舍生忘死也要保护密码本，否则一旦泄露，情报就存在泄露风险。\n网络通信也是一样，这里最大的问题，就是这里的密钥如何避免泄露。但只要密钥本身也需要通过网络通信来传输，那么依然不安全。\n这个过程好比：\n1 2 3 4 A: 跟你说个秘密，我下面的话你不要直接听，我全部说第几页第几行第几列，你去《红楼梦》找到对应的字连起来读。你回话也告诉我对应字的位置就行 B: 好嘞，《红楼梦》已摆好，你说吧 。。。。 C：我偷听到啦，赶快买本《红楼梦》去... 非对称加密 而除了对称加密之外，还有一种加密方式是 非对称加密， 这种方式会采用一些特殊的加密算法，生成两份密钥，分为 公钥 和 私钥, 通过其中一把钥匙加密的内容，只能通过另一把要是才能解密。并且这个算法是很难通过暴力破解逆向还原推导仿冒出另一把钥匙。\n类似古代调遣军队的虎符，只有双方严丝合缝对得上才能验证为真。\n有了这个机制，就可以把私钥保存在自己这里，并且绝不外传，而公钥可以公告天下，通过网络正常传递，谁都有可能拿到。这样，对方要给我发送加密信息，只要使用公钥加密，而解密只能在我自己这里才能完成。\n所以，非对称加密大致的过程就是：\n1 2 3 4 5 6 A: 我有点秘密想跟你说, 不能被其他人听到.... B：稍等，我给你个公钥，你上个锁以后再说给我听。拿到公钥先念下公钥上的字给我看看对不对 A: 收到公钥，上面写着“我是王大锤” B: 对，你收到的就是我给你的公钥，用它上锁吧 A：公钥加密上锁，打包发给B B：取出私钥，打开包裹，阅读内容... 相比 对称加密，非对称加密明显更加安全，但这种方式的缺点是计算量比较大，加解密过程效率不高，速度较慢，所以实际应用中，通常是两种方式结合使用。\n也就是 TLS 加密过程：\n双方会首先通过非对称加密过程，协商出一个用于通信的对称密钥；这个对称密钥的生成都在各自的本地完成，而完成密钥协商后，后方各自都有了一个相同的对称密钥，就可以基于这个相同的密钥进行后续对称加密通信。\n因为这个对称密钥是通过非对称加密的方式得到的，所以并不会在双方的通信过程中传递。这样就兼顾了安全和效率。\n签名和证书 不过用非对称加密，还是存在一个漏洞。\n就是在服务器和客户端通信的过程中，通信过程其实会通过大量中间环节，如果存在一个恶意的劫持者，它在收到服务端信息后，想自己假冒服务端，篡改信息后再发给客户端。\n这时它其实可以伪装成服务端，自己给客户端发放公钥，拿到客户端的信息后，用自己的私钥解密，再用真正的服务端公钥重新加密，发给服务端。\n这个风险其实就是安全领域中的 中间人攻击 漏洞。\n而为了规避这个问题，需要服务端应该证明自己的身份，然后客户端还可以验证这个身份。因此就有了签名和证书。\n签名就是服务端表明自己的身份，拿到公钥的客户端就可以通过签名判断这个发送端是正确的服务器。这里的签名和公钥其实都保存在一个文件中，也就是服务端的签名证书。\n而为了防止中间人伪造证书，这时就引入了CA（Certificate Authority)，也就是权威的第三方证书颁发机构。这些权威的第三方颁发机构会用私钥对服务端的签名进行加密，这样客户端就可以通过机构的公钥来验证这个签名是否是对应的服务端。验证无误，就可以用证书中携带的公钥来完成和服务端后续的通信协商。\nHTTPS协议交互过程 有了上面的基础，我们来具体看一下访问一个 https 网站的具体通信过程。\nTLS因为有不同的版本，并且支持多种不同密钥交换和加密算法，所以在通信前，首先要完成使用何种加密算法、用什么密钥生成方式等过程。而 TLS 是基于TCP协议之上的，所以在 TCP 典型的 3次握手完成建链之后，会进行 TLS 的握手建链过程：\n比如客户端从浏览器访问网站， 这时浏览器会首先发送Client Hello 消息到服务器，这个消息中主要包含了客户端支持的加密套件ciphersuites， TLS 版本信息和客户端随机数。（明文传输） 服务器接收到消息后，返回自己支持的ciphersuites， TLS 版本，自己的数字证书和服务器端生成的随机数等几项内容。（明文传输） 客户端对收到的数字证书进行验证。验证无误之后生成一个新的密钥，也就是预主密钥pre-master key，并使用证书中携带的公钥来对pre-master key进行加密，发送给服务器。（此时是非对称加密传输） 服务器接收到客户端的密文，使用私钥进行解密，获得了pre-master key。（非对称加密传输） 到这里为止，服务器和客户端都有了三组数字，分别是客户端的随机数、服务端的随机数和pre-master key。前两个随机数虽然是明文传输，有泄露风险，但 pre-master key并没有在通信中传递，是计算而得到的安全密钥。 所以再将这三者结合，使用之前协商好的特定的加密算法再生成一个密钥，这个密钥称为shared secert。也就是之后的会话密钥，这个密钥是后续对称加密的密钥。 客户端在计算出对称加密的密钥之后，使用该密钥对通信内容进行对称加密，告知服务器之后都使用该密钥进行对称加密。（对称加密传输） 服务器接收到密文后，使用之前计算出的密钥来进行对称解密，解密成功之后，同样再使用该密钥进行对称加密通信。并告知客户端密钥确认无误，可以使用该密钥进行通信。（对称加密传输） 至此，整个TLS的握手过程完整，之后就可以开始对称加密的通信了。\n通过 WireShark 抓包的话，通常是这样的一个过程：\n具体的交互过程，参考下图 (图片来自网络\n以上就是关于 Https 协议通信过程的整体梳理，更多测试和技术相关文章，欢迎关注 城下秋草的博客 或公众号（秋草说测试）\n","date":"2024-09-28T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/021-%E5%82%BB%E7%93%9C%E5%BC%8F%E7%90%86%E8%A7%A3https%E5%8D%8F%E8%AE%AE/Pasted-20240928-1_hu_522a7fdc9d4079c7.png","permalink":"https://chengxiaqiucao.github.io/post/021-%E5%82%BB%E7%93%9C%E5%BC%8F%E7%90%86%E8%A7%A3https%E5%8D%8F%E8%AE%AE/","title":"大话Https协议"},{"content":"前言 软件代码是任何一个软件研发团队的核心资产。而软件的分支管理就是团队中多人合作时，如何协调处理不同人员的代码同步、集成并解决冲突的主要方式。\n本文根据软件大牛Martin Flower的分支模型阅读笔记整理\n基础模式 源分支 所有修改都记录到同一分支\n分支的定义： 创建分支： 不同的两个开发者基于主分支拉去各自的开发分支： Jonny LeRoy 指出我们绘制分支线时，其实忽略了随着时间，导致的复杂度提升 主干的定义： Master、Trunk\n是反映产品当前实际状态的唯一公用分支\n可以随时获得当前产品版本状态，并基于此进行开发\n健康分支： 为每一次提交进行自动化构建、测试，确保没有在当前分支引入故障（可工作的无故障分支）\n优点：\n健康的公用分支，可以避免从这个分支上拉取的新分支工作在错误的基础上 健康分支更易入直接发布到产品 随时保持一个健康分支能极大降低集成的工作量并减少潜在风险。 便于进行差异调试。（可以将调试失败的commit去除，仅保留健康的commit） 在集成到主干时如果出现问题，就可以非常明确地确认是冲突导致而非代码错误 可能是公用分支、也可以是自己的分支。 自测代码是健康分支的核心，自测应可以快速得到结果（分钟级）\n集成模式 主线集成 开发从主干拉取代码进行开发，集成，并将健康的更改推送回主干 从主干拉取分支到本地，并在本地分支上进行开发\n开发过程中，其他开发已经提交了变更到主干分支 此时如需向主干提交，则首先需要合入其他的变更 有时，本地的修改和已经提交的变更会有冲突，此时需要先解决冲突 再重新将修改并自测后的健康代码提交到主干分支\n使用主干时，意味着我们会实行主干集成模式\n特性分支 为每一个功能特性拉取它独立的分支，并在feture完成后集成回主干\n从主干拉取不同的特性分支并分别进行开发 开发过程中会持续从主干拉取最新代码，如果有其他功能变更，要及时进行集成解决冲突（本地）。\n特性完成开发后，集成回主干。（受影响的冲突已在本地解决，所有其他特性分支上直接拉取变更，不会存在冲突需要解决）\n低频集成 两条独立的开发分支上分别进行了几次本地提交，但没有向主干推送 主干上合入了变更\n开发分支需要拉取变更并合入到本地分支（解决冲突）\n分支A上继续完成了4，5两个提交，然后推送大主干 分支B上完成了4，5，6几个提交后，需要在本地合入主干上A的提交，集成后推送到主干。（本地合入的大小代表工作量）\n高频集成 每次提交都向主干进行集成和推送呢？ V完成第1次提交后就推送回主干\nS在完成第1次提交后就进行本地合入，并推送回主干 S的第2次推送，主干没有变更，没有本地合入工作 V完成第2次提交和本地合入，推送 S的第3次提交，需要本地合入，推送 如此，每次本地的提交，都会向主干进行推送\n比较二者，高频集成会有更多的本地集成工作，但这些集成的工作量比低频集成低得多。 同时，比工作量减少更重要的是，这样做减少了风险。（虽然大多情况下，进行大的合入也能顺利完成，但有时却会有严重的冲突问题难以解决。这种情况，偶发的巨大问题比常规的小问题更糟糕） 如果每次常规集成10分钟，但50次集成合在一起要6小时，看起来6小时比500分钟还是要少，但是这会导致集成恐惧（if it hurt，do it more often）\n而且高频集成模式下，可以更早发现代码间的冲突情况，并避免在冲突代码在后期才发现而导致中间持续产生了很多本不应该存在的更多冲突代码。\n源码控制系统其实更多是一个沟通平台，可以意识到其他团队成员的工作\n持续集成 开发者一旦完成一个健康的提交，就会尽快完成主干集成，一般不超过1天。\n（如果高频集成更有效率且可实施，但使用特性分支，意味着限制了变更不能比一个特性更小，那么集成频次就成了问题？）\n持续集成-只要特性上的开发是有进展并且是健康的，就可以向主干集成。唯一的原则就是每天都要进行集成（甚至更短）\n开发团队需要习惯在主干上存在未完成特性的情况并考虑如何在产品中不暴露这些特性。（通过隐藏入口、配置控制），有时我们还可以实现灰度发布。\n在持续集成模式下，开发着往往不需要创建自己的特性分支，只要在本地的主干分支上工作即可。\n特性分支和持续集成的区别不在于是否有特性分支存在，而在于何时向主干集成。\n两者的比较：\n两种模式的差异更多取决于特性的大小，如果特性足够小（一天以内可以完成），就可以同时实行特性分支和持续集成。\n特性分支最明显的问题在于合并的工作量和不确定性，然而更大的问题是它可能阻止重构。重构是软件优化最有效的途径，但是重构会产生冲突，当解决冲突工作量太大时，重构往往需要极大的勇气。\n功能分支 持续集成 - 可以将某个功能中的所有代码作为一个单元进行质量评估\n- 功能完成后才将功能代码添加到产品中\n- 合并频率较低 - 支持比特征长度更高的频率集成\n- 减少发现冲突的时间\n- 规模较小的合并\n- 鼓励重构\n- 需要致力于健康的分支（从而实现自我测试代码）\n- 科学证据表明它有助于提高软件交付性能 特性分支和开源软件 github的特性分支？pull request模式 上下文不同：分散、不定时、团队成员不了解 vs 全职、熟悉的团队成员、可靠\n提交的审核review\n代码审核· 集成受阻 模块化的重要性 发布模式 主干分支是活动分支，代码持续在其上开发。如果能保持主干的健康状态，任何人都可以从一个稳定的基础开始自己的工作。 而且足够健康的话，也可以直接从主干分支进行产品的发布\n对于实施CI/CD的团队，一个常用的实践是通过打Tag标记来跟踪每一个发布的版本。但不实践CD的团队，则需要其他的发布模式\nRelease Branch 发布分支 预备发布的分支，只接受以版本稳定和交付为目标的提交 （一般系统测试阶段） Release分支从主干分支中拉取，不再接受任何新feature的合入。工作在release分支上的开发工作主要是修复发现的bug或影响交付的功能。所有的修改最终还需要合并回主干。 尽管release分支上的工作往往比新feature的开发工作量更小，但是如果在其上的开发时间过长依然会导致合并回主干非常困难（主干上的提交越多，合入就越困难）\n实际工作中，因为release分支的存在，合并回主干的操作往往容易被忽视，特别是有困难的冲突需要解决并且存在发布压力的情况下。\n所以有的开发会采用另一种方式，继续在主干上开发，然后通过cherry-pick将只和发布相关的提交合入到release分支。这种方式的缺点是很多时候chrry-pick有时也很困难（对之前的commit有依赖的情况），在实际发布之前对release分支往往有一些重做工作。\n对于只有一个产品版本的团队来说，使用单一的release分支就好。但很多情况下，会存在需要支持多个产品版本的情况，比如客户本地部署的软件，可能会长时间运行在一个历史版本上，但是又需要继续做一些bug fix或者一些特别的需求，此时就需要维护多个不同的release 分支，并定期保持和主干同步\n对开发团队这明显是大大增加了维护难度和工作量，但这更多是产品策略带来的成本。唯一可以做的就是鼓励客户更及时地升级到最近版本（保持产品稳定非常关键，一旦产品不稳定导致问题，会使客户更倾向不再升级）\nRelease分支对于难以保持主干分支持续在健康状态的团队非常有必要，团队可以关注在产品发布的功能验证上。但对于单一产品的团队，release分支并不必要，使用主干分支并保持健康状态即可（发布的版本进行Tag标记） 另外，对于发布流程存在很多阻塞的团队，relase分支也是必要的（比如有比较缓慢的审核流程，在应用商店上线的时间窗、安全、法务、合规等的审核等）\n成熟分支 分支的head总是标记为最近版本的成熟代码基线\n根据团队对产品成熟度的不同定义，拉取出的对应的成熟分支。比如QA分支（提测）、Staging分支（预发）、production分支（上线）\n但很多情况下，使用清晰定义的Tag机制就可以代替成熟分支的作用。比如“成熟级别-内部版本号”，“qa-233”，“prod-445” 长期发布分支 release分支一般在产品发布后就可以删除，但我们也可以维持一个长期的发布分支。它的作用可以看作是发布分支和成熟分支的集合。这个分支上进行release前的fix工作并合并回主线，并在实际发布时打上发布Tag，然后进入下一个版本的发布准备。 环境分支 通过不同的提交来配置代码的运行环境 不同的产品运行环境往往会有不同的配置代码（测试环境、开发环境、性能验证、安全验证环境、预发环境、产品环境等），环境分支会包含这些配置的变更提交并触发对应的构建、部署。\n环境分支一般也用作成熟分支，比如QA的成熟分支，会包含QA环境的配置变更。\n但是环境分支并不是好的实践，不同的环境需要不同的编译代码会引入风险。如果产品程序在不同的环境上有不同的行为表现会使问题的修复、定位变得极其困难。所以最好保证不同环境下运行的可执行代码都是相同的，环境的配置都通过显式的配置文件或变量来控制。环境变更导致的任何更改都不应包含在源码控制系统中\n环境分支只应是缺乏这种环境切换控制机制团队的应急机制存在。\nHotfix 用于进行紧急产品故障修复的分支\n从主线分支对应的release版本拉取hotfix分支，并在完成后合入回主线（如果release时间比较久，合并工作可能会比较大） 对使用release 分支的团队，也可以直接在release分支上进行hotfix，此时相当于将原release分支转变为hotfix分支 对于实践CD的团队，甚至可以直接在主干上完成hotfix（还是会拉取hotfix分支，但会从最新的提交拉取），因为一般团队已经具备了不公开未发布特性的能力。而且在hotfix过程中，不允许向主线进行任何新的提交。（hotfix优先）\n如何定义hotfix？对于可以发布频率较高的团队，一般可以将问题纳入日常发布节奏而不需要进行hotfix。取决于团队发布频率和对业务的实际影响\nrelease train 象火车发车一样有定期的发布间隔，特性完成后选择放入哪一次发布（和SAFe的Agile release train不是一个概念，那更多是组织层面的实践） 团队定义定期的发布计划，并确定每列发布列车上的功能，据此承诺、安排各自的工作任务。一旦火车发车，当前分支就转化为release分支，只会接受bug fix。发布列车一般会和feature分支一起使用。对于发布流程中存在较多阻塞的团队来说，release train是非常有用的，不会因为这些阻塞而影响后续功能的研发。 但比较明显的缺点是，如果一个功能很早就完成，也需要等到发车时间才能上线。\nrelease train可以看作是团队release流程的一个提升手段，对与很难进行稳定发布的团队，实施CD往往不够现实 ，此时release train会是一个好选择。\nloading future trains 和旧列车发车后再向新的列车上装载需求不同，可以使用这种模式的变种。如果一些功能不能确定是否能在预定发车前完成，可以同时开启两列train（预期发车时间不同），在三月列车上完成的开发工作同时向4月列车上提交并在三月列车发车后继续在4月列车上完成剩余工作。\n这种模式可以让4月列车上的工作不影响三月列车，但缺点是如果4月列车上的变更影响到3月的功能，会是后续的合并工作更加复杂。\n和主线发布比较 release train的主要好处是可以有一个定期的产品发布日历，但是多个分支依然会引入复杂性。 其实使用主线模式也可以如此工作，在主线上开发，到发布日期后增加一个对应的发布分支即可。 预发布主线 确保主线是绝对健康状态，并且主线的head永远能被直接发布到产品环境。（每个提交都具备直接发布的健康状态，但是只有实际发布的提交才需要加上tag） 其他发布模式 实验分支 在代码基线上收集用于实验的工作，这些功能不会被直接合入产品环境\n实验性的点子 功能的不同实现方式\n未来分支 一个用于对其他分支侵入性太大的变更分支\n较少使用的模式，只会从主线pull而不会merge回其他分支。一旦使用，意味着团队中存在一个独立的代码特区。应尽可能缩短这个分支存在的时间。\n合作分支 用于开发者之间协同工作，但不需要进行正式的集成的情况。\n团队集成分支 在向主线集成前，允许子团队间先进行互相集成。（大型项目）\n原文参考Martin的博客 Branch Patterns\n","date":"2024-09-27T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/branch_hu_75a9f470170817f9.png","permalink":"https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/","title":"软件分支策略和集成模式梳理"},{"content":"序言 作为一个有追求的测试工程师，现如今敏捷起来，需要和开发人员紧密配合，像配合单元测试、集成测试，都是需要直接面对开发代码的。而且自己做的自动化测试，本身也是代码，因此代码管理其实也是现在做测试绕不过的一个技能。\n而在和开发人员相爱相杀的过程中，直接冲进代码库，看看都写了什么见不得测试的勾当，也是咱们深度测试的高阶招数。\n不过这里首要一关，就是跟代码库打交道。所以本文我们来了解下现在最主流的 Git 代码分支管理工具， 如何用正确的姿势操作代码库。\nGit是什么？ Git的作者是大名鼎鼎的Linus Torvalds, 众所周知，著名的 Linux 之父。\nLinux虽然获得了极大的成功，吸引了众多的开发者参与项目，但在早期，作为Linux项目的管理者，Linus主要还是通过手工方式来合并大家的代码。并没有借助任何代码管理工具。\n倒不是说 Linus 喜欢这种方式，而是因为他对代码版本管理工具非常挑剔，商用的 clearcase，开源的 CVS、SVN等等都不符合他对代码分支管理的预期。\n直到 2002 年，Linus 才相中了一款商用的分布式版本控制系统 BitKeeper，而基于Linux极大的号召力，BitKeeper也愿意让 Linux 社区免费使用。但到2005年，一位社区开发者在未经允许的情况下逆向了BitKeeper并利用了它未公开的接口，导致 BitKeeper 收回了社区的免费使用权。\n回到原点的Linus这时就决定自己开发一个代码的版本控制系统，对这个系统的基本诉求是：\n速度 设计简单 允许大量并行开发的分支 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目 然后，大神的效率，Linus 只用了 10 天时间就推出了 Git 的第一个版本。并且给这个版本起了一个略带嘲讽意味的名字——Git（英语俚语中表示“不愉快的人”）。\nThe name \u0026ldquo;git\u0026rdquo; was given by Linus Torvalds when he wrote the very first version. He described the tool as \u0026ldquo;the stupid content tracker\u0026rdquo; and the name as (depending on your way)\n当然，在 Linus 推出 Git 的第一个版本后，社区中开始有其他感兴趣的成员(Junio Hamano)开始参与并逐渐接手了 Git 的日常维护，Linus 则继续将主要精力放回到了 Linux 内核的维护上。\nGit vs SVN 在 Git 之前，最流行的代码版本管理用工具应该是 SVN。\n不能说 SVN 有很大缺点，但 Git 和 SVN 的应用场景确实有较大区别，这里列表做个比较\n特性 Git SVN 分支 轻量级分支，创建快速 分支是代码库的完整拷贝 分支合并 快进式合并，合并快速 需要手动合并修改 分布式 是，设计为分布式 不是，不支持完全分布式 快照 保存更改的快照 保存文件的差异 速度 快，分布式设计 慢，中心化设计 权限控制 通过Git Hooks和Gitolite控制 通过钩子脚本控制 学习曲线 较高，需要理解命令和概念 较低，容易上手 标签 轻量级标签，可以后续修改 不可变的静态标签 历史记录 保留所有历史记录 只保留最近的历史记录 合并冲突 需要手动解决 自动尝试解决，有冲突时需手动介入 命令行工具 是，Git命令行强大灵活 较为简单，主要用于管理和操作仓库 总体来说，现在 Git 更为流行，围绕 Git 的生态更加健全，因此逐渐成为了目前最主流的版本控制工具\nGit的工作原理 那 Git 到底是如何进行工作的呢？\ngit 在架构上其实是一个三层架构，\n工作目录（working directory）： 这是项目文件所在的实际目录。对工作目录中的文件所做的修改被认为是“未跟踪”状态，直到显式地进行 commit 操作。 暂存区（staging area）：暂存区充当工作目录和 .git 目录之间的缓冲地带。暂存区域中的文件处于“暂存”状态，以便在下一次 commit 时包含。是允许选择和控制更改的手段。 本地库（local repository）：也就是 .git 目录， 它是Git版本控制系统的核心容器，包含各种元数据、对象数据库和配置信息。.git 目录存储 commit 的快照，并管理项目的历史记录，接受git的各种操作指令。 而除了本地代码管理的这三层，还存在一个远程库的概念，用于不同成员间对同一个项目代码进行协作。\n远程仓库（remote repository）： 远程仓库是一个中心仓库，用于团队成员协作，通过push、pull、merge等方式确保代码的同步和协同。 结合上面这个架构和主要的Git操作命令，我们理解一下 git 的运作过程：\n首先我们通过 git init 或者 git clone 建立起本地的git仓库，也就是会包含 .git 这个本地库目录。 本地新增或修改的代码，这时其实是处于 未跟踪(untracked) 状态 执行 git add .指令，这时相关变更会进入 暂存区， 对应的状态是 已缓存(staged) 或者 已修改(modified) 这时再执行 git commit指令， 作用是从暂存区将变更提交到本地库中，对应状态是已提交(committed) git diff 是查看变更的命令，可以看到，它其实比较的是工作目录和暂存区的区别，而 git diff HEAD 则比较本地库和工作目录 git push 会将本地库中的内容，提交到远程库 git fetch 用于将远程库同步到本地库 我们常用的git pull则是将远程库直接拉取到本地的工作目录下 常用 Git 命令 借用一个中文的Git cheatsheet，便于速查。\n详细的命令用法这里就不再罗列了，核心命令主要也就是上面原理图中提及到的几个。\n进一步学习的话，也可以利用在线的学习工具，这里推荐一个：\nhttps://learngitbranching.js.org/\n","date":"2024-09-26T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/024-git%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/git_hu_77a1641cfb2ed205.png","permalink":"https://chengxiaqiucao.github.io/post/024-git%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","title":"Git工作原理和常用指令"},{"content":"在我们使用 Pytest 框架进行自动化测试时，强大的 fixture 夹具为框架的灵活应用提供了极大的便利。比如我们可以利用 fixture 的autouse属性，使它在测试方法的不同范围层级上自动生效。但如果要引用fixture的返回，我们通常还是要明确指定，稍显麻烦\nautouse指定fixture，但还是需要显式携带为参数才可调用 以Selenium 自动化时最常用的webdriver为例， 实现自动化时，因为webdriver 对象通常会在整个执行期间都生效，而且会频繁地进行调用。\n通常的做法是可以在 conftest.py 文件中编写一个session层级的通用driver夹具，设置 autouse为启用：\nconftest.py\n1 2 3 4 5 6 7 @pytest.fixture(scope=\u0026#34;session\u0026#34;,autouse=True) def driver(): option = webdriver.ChromeOptions() driver = webdriver.Chrome(options=option) driver.implicitly_wait(3) driver = webdriver.Chrome() yield driver 然后我们在另一个测试文件中，编写测试类和测试方法时，就可以直接引用这个driver夹具\ntest_auto_driver.py\n1 2 3 4 class TestDriver: def Test_open_blog(self, driver): driver.get(\u0026#34;https://chengxiaqiucao.github.io/\u0026#34;) assert driver.title == \u0026#34;秋 草 观 “测” 台\u0026#34; 但如果整个测试工程比较大，类似的测试类、测试方法比较多的时候，每定义一次测试方法都要指定这个通用fixture，才能引用driver对象，是不是总感觉不太优雅？\nPytest内置Fixture： Request 其实大家学习过通过Fixture来参数化的方法的话，应该知道通过Fixture进行参数化，是通过pytest的一个内部fixture request来完成的。 request应该是pytest中最为重要的一个内置夹具了。而利用这个fixture，我们其实可以实现隐式地将一些通用fixture默认地传递给各个测试类\nrequest简介 通过官方文档的介绍：\nrequest 是一个用于提供当前测试方法上下文信息，以及通过param参数实现参数化的一个内置夹具。\n利用request，我们可以在运行过程中获取当前fixture的诸多上下文信息。比如夹具名称、路径、当前的session、模块、类信息等。\n下图是引用fixture时，断点得到的request对象属性\n那上例中作为一个在session级别生效的通用的fixture，我们可以通过它的session属性，获取当前session中的所有类，再将driver对象赋值给相关类属性，这样我们在定义测试类时，就可以无需另外指定fixture，直接通过类属性根据需要引用即可。\n实现fixture自动赋值到类属性 所以修改上面案例的代码如下：\nconftest.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @pytest.fixture(scope=\u0026#34;session\u0026#34;,autouse=True) def driver(request): \u0026#34;\u0026#34;\u0026#34; 自动应用fixture，并设置到调用的类属性中 :param request: pytest内置fixture，用于获取fixture的上下文 :return: \u0026#34;\u0026#34;\u0026#34; driver = webdriver.Chrome() try: session = request.node for item in session.items: cls = item.getparent(pytest.Class) setattr(cls.obj, \u0026#39;driver\u0026#39;, driver) yield finally: driver.quit() 这里我们将driver对象添加为类属性，而fixture本身不再yield任何对象返回\n相应的，测试脚本中，直接通过self.driver 易用类属性即可\ntest_auto_driver.py\n1 2 3 4 class TestDriver: def Test_open_blog(self, driver): self.driver.get(\u0026#34;https://chengxiaqiucao.github.io/\u0026#34;) assert self.driver.title == \u0026#34;秋 草 观 “测” 台\u0026#34; 执行效果, 用例同样正确完成执行。 以上~~\n","date":"2024-09-24T13:16:16+08:00","image":"https://chengxiaqiucao.github.io/post/017-pytest%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8C%87%E5%AE%9A%E5%8F%AF%E5%BC%95%E7%94%A8fixture/pytest_hu_51d6830fd3f75222.png","permalink":"https://chengxiaqiucao.github.io/post/017-pytest%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8C%87%E5%AE%9A%E5%8F%AF%E5%BC%95%E7%94%A8fixture/","title":"Pytest中自动指定可引用fixture"},{"content":"Selenium作为目前最为流程的开源Web自动化测试框架，已经发展了20年。功能强大，它的webdriver协议也已经成为自动化测试领域的一个事实标准。而基于Selenium这个框架，又诞生出很多基于它封装的拓展框架。比如本文我们介绍的SeleniumBase\nSeleniumBase是什么？ SeleniumBase是一个基于Selenium框架基础上，进一步进行了脚本增强的Python库。 在Selenium原有的功能基础上，简化了自动化脚本的编写和调用方式，并且和pytest框架进行了深度集成。最主要的是它提供了多种不同的脚本模式, 包括脚本录制、运行慢放、运行中Debug，以及我们本文要介绍的演示功能。\n虽然SeleniumBase十分强大，但底层自动化的实现逻辑上依然沿用Selenium的主要特性。所以这里我们不特别介绍SeleniumBase在自动化脚本编写上的封装。但这个库有一个非常棒的地方是它通过JS的注入让自动化运行过程更加直观和便于展示。\n比如我们下面看到的演示制作\n通过自动化脚本完成演示的优点 作为测试工程师，特别是随着现在敏捷研发的流行，迭代结束通常都有个迭代回顾和演示环节。而作为测试工程师，很多迭代中的功能演示这个工作是由我们来完成的。\n包括有时在向客户、领导介绍产品功能时，通过实际的产品操作来说明功能也必不可少。\n但实际操作中，如果能提前将一些需要说明的重点，在自动化测试执行的同时展示出来，效果就非常好，并且还能避免一些临时的误操作。\n所以SeleniumBase的这个功能就能在这里发挥优势了\n用SeleniumBase制作产品演示流程 先看一下用SeleniumBase完成的我的博客网站的中一个开源更新信息的演示\n其实它的原理也比较简单，就是通过它封装的BaseCase类，在对应的操作步骤执行同时，注入封装好的Js来突出执行的元素，给出一些指引提示。\n这里对应的基类中的create_introjs_tour()方法，创建演示导引。这里它还有不同的js主题选择，非常强大。\n然后就是add_tour_step()添加步骤，play_tour() 执行步骤.\n对应的演示生成代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from seleniumbase import BaseCase BaseCase.main(__name__, __file__) class MyTourClass(BaseCase): def test_blog_tour(self): self.open(\u0026#34;https://chengxiaqiucao.github.io/\u0026#34;) self.wait_for_element(\u0026#39;[class=\u0026#34;site-logo\u0026#34;]\u0026#39;) self.set_introjs_colors(\u0026#34;#f34565\u0026#34;, \u0026#34;#c55409\u0026#34;) self.create_introjs_tour() # self.add_tour_step(\u0026#34;Selenium Base制作Demo演示\u0026#34;, title=\u0026#34;城下秋草的Demo\u0026#34;) self.add_tour_step(\u0026#34;查看热门开源项目\u0026#34;, \u0026#39;#main-menu \u0026gt; li:nth-child(6) \u0026gt; a\u0026#39;) self.play_tour() self.highlight_click(\u0026#39;#main-menu \u0026gt; li:nth-child(6) \u0026gt; a\u0026#39;) self.wait_for_element(\u0026#39;[class=\u0026#34;article-title\u0026#34;]\u0026#39;) self.create_introjs_tour() self.add_tour_step(\u0026#34;选择Selenium项目查看\u0026#34;, \u0026#39;#seleniumpageselenium-10 \u0026gt; a\u0026#39;) self.play_tour() self.highlight_click(\u0026#39;#seleniumpageselenium-10 \u0026gt; a\u0026#39;) self.ad_block() self.wait_for_element(\u0026#39;[class=\u0026#34;section-title\u0026#34;]\u0026#39;) self.create_introjs_tour() self.add_tour_step(\u0026#34;返回主页\u0026#34;, \u0026#39;[class=\u0026#34;site-logo\u0026#34;]\u0026#39;) self.play_tour() self.highlight_click(\u0026#39;[class=\u0026#34;site-logo\u0026#34;]\u0026#39;) self.wait_for_element(\u0026#39;[title=\u0026#34;搜索\u0026#34;]\u0026#39;) self.create_introjs_tour() self.add_tour_step(\u0026#34;3秒停顿后继续...\u0026#34;) self.add_tour_step(\u0026#34;开始下一个演示:\u0026#34;) self.play_tour(interval=3) 而实际演示的注入Js，我们还可以通过self.export_tour这个语句导出对应的js脚本，便于后续直接使用。\n类似的还有他的Demo模式，其实和演示导引模式比较类似，只是更多时自动把自动化执行步骤放慢并高亮，突出验证点。\n以上就是关于SeleniumBase库这个帅气功能的分享~\n","date":"2024-09-23T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/019-%E7%94%A8seleniumbase%E5%88%B6%E4%BD%9C%E4%BA%A7%E5%93%81demo/seleniumBase_hu_143997b48b9a9e7b.png","permalink":"https://chengxiaqiucao.github.io/post/019-%E7%94%A8seleniumbase%E5%88%B6%E4%BD%9C%E4%BA%A7%E5%93%81demo/","title":"用SeleniumBase制作产品Demo"},{"content":"很多初学自动化测试的朋友，看过很多教程，但是苦恼于没有合适的项目用来进行练习，这里就分享下笔者收集的一些不错的练习项目\nDemoQA DemoQA 是一个专门的用于练习如Selenium这样的web自动化测试的练习网站。 针对Web自动化学习过程中的各种常用元素、控件都有覆盖，可以比较全面地学习对页面的处理 The-internet The-Internet 也是一个面向初学者的专门用于自动化测试练习的项目，和DemoQA比较类似。场景上可以用来互补。 除了在线使用，也可以通过它的github项目下载源码自行部署（基于Ruby）。\nSauceLab App SauceLab 是一个测试服务提供商，SauceDemo 这个站点是它提供于自动化测试练习的一个项目\n这个项目除了Web版本之外，还提供有移动版本my-demo-app，可以用于Android/IOS应用自动化测试的练习, 可以通过SauceLab的github项目获取。\nhttps://github.com/saucelabs/my-demo-app-android\nhttps://github.com/saucelabs/my-demo-app-ios\nSahi Test Sahi Test 是一个测试博主自建的用于自动化测试练习的一个项目，包含了非常丰富的场景\nGURU99 Demo Demo Guru99 是Guru99 网站集成的用于自动化测试练习的多个项目集成，包括保险、银行、电信以及传统自动化测试工具QTP自带的Tour项目\nJpetStore JpetStore是由mybatis 提供的一个宠物商店应用。项目地址：https://github.com/mybatis/jpetstore-6\nOpenCart 除了上面这些专门提供给自动化测试练习的项目外，我们练习时也可以找一些功能更齐全的开源免费站点来使用。\n比如OpenCart 就是一个开源的电商网站，可以基于它的Demo站点来练习\nOrangeHRM OrangeHRM 是一个功能强大的开源人事管理系统，作为自动化测试的练习网站同样是一个很好的选择\n以上就是笔者收集整理的一些常用的可以用于自动化测试练习的网站。当然，开源网站上其实有大量比较成熟的web应用，我们完全可以在本地完成搭建以后再进行练习。 大家如果有其他比较好的练习项目推荐，欢迎评论补充哦~~\n","date":"2024-09-20T15:24:19+08:00","image":"https://chengxiaqiucao.github.io/post/012-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%E6%94%B6%E9%9B%86/autotest_hu_ea64827a510d9b7a.png","permalink":"https://chengxiaqiucao.github.io/post/012-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%E6%94%B6%E9%9B%86/","title":"适合用来自动化测试练手的项目"},{"content":"在Python语言中，开发命令行程序，最基本的方式是通过Python标准库argparse来进行命令行参数和各种交互定义。但相对来说还比较复杂，一些常用的场景也需要我们单独封装。\n本文我们介绍另一个非常强大，也非常容易上手使用的python命令行工具库typer，看看如何利用它来帮我们快速完成一个命令行应用的实现。\n安装和基本使用 安装 typer 是一个由 热门开源web接口框架 FastAPI推出的命令行实现工具。和其他 python 第三方库类似，安装很方便。\npip instal typer\n基本用法 姿势一 编写一个最基本的hello world程序user_typer.py\n1 2 3 4 5 def main(): print(\u0026#34;hello world!\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 直接通过typer命令调用 运行：\nDemo\u0026gt;typer use_typer.py run\nhello world!\n姿势二 也可以在代码中引入typer，然后用它的run方法直接在程序中调用\n1 2 3 4 5 6 7 import typer def main(): print(\u0026#34;hello world!\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: typer.run(main) 运行：\nDemo\u0026gt;python use_typer.py\nhello world!\n姿势三 或者将程序声明为一个应用，然后用注解指定应用的每一个支持的命令\n1 2 3 4 5 6 7 8 9 import typer app = typer.Typer() @app.command() def main(name): print(\u0026#34;hello world!\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: app() 运行：\nDemo\u0026gt;python use_typer.py\nhello world!\n而且运行 python user_typer.py --help， 可以看到已经自动生成了必要的帮助说明。 这里我们在main函数中加了一个参数，可以看到typer 其实还会自动将对应的函数携带的参数解析为命令参数，无需重新定义。\n命令帮助和默认值 当然作为命令行程序，命令的帮助信息定义是一个重要部分。\ntyper也提供了很方便的添加命令和参数帮助的途径。 比如我们再添加一个命令\n1 2 3 4 5 6 @app.command(help=\u0026#34;问候指定的小伙伴\u0026#34;) def hello(name:Annotated[str,typer.Argument(help=\u0026#34;被问候的伙伴姓名\u0026#34;)]=\u0026#34;城下秋草\u0026#34;): \u0026#34;\u0026#34;\u0026#34; 这里也可以直接作为命令帮助，和command的help参数作用一样， 但优先级没有command注解高 \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;你好，{name}\u0026#34;) 命令本身的帮助信息可以直接在command注解中通过help参数说明，或者也可以通过函数本身的docstring，typer也会把它解析为命令帮助。但如果command注解中已经指定，则会以command注解中指定的帮助信息为准\n而指定的参数name, 这里是通过python的类型扩展库，再通过type.Argument的help参数来指定，并且同时还可以指定参数的默认值。 可选参数和参数名 这里我们通过type.Argument指定的参数，其实是必填参数。那如果我们希望某一个参数是可选的呢？ 这里typer中是根据两个不同类型来区分。定义上来说，\ntyper.Argument 是必选 typer.Option 是可选 对应到帮助信息中的 Arguments 和 Options 两个不同的pannel。 但是否必须输入，其实是根据是否指定了对应参数的默认值来确认的，如果没有指定默认值，那么就代表这个参数是必须输入的。\n另外 Option 和 Argument 的不同还在于 Option 是需要指定option名称, 也就是形如 --name, --help 这用带 -- 或者 - 短参数标记\n默认 typer.Option是直接将参数名转化为长标记，也可以自行指定其他别名。 同时也可以指定指定短标记\n比如我们可以再增加一个参数 last_name\n1 2 3 4 5 6 7 @app.command(help=\u0026#34;问候指定的小伙伴\u0026#34;) def hello(last_name:Annotated[str,typer.Option(\u0026#34;--last\u0026#34;,\u0026#34;-l\u0026#34;,help=\u0026#34;被问候的人员姓什么\u0026#34;)], name:Annotated[str,typer.Argument(help=\u0026#34;被问候的伙伴名称\u0026#34;)]=\u0026#34;城下秋草\u0026#34;): \u0026#34;\u0026#34;\u0026#34; 这里也可以直接作为命令帮助，和command的help参数作用一样， 但优先级没有command注解高 \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;你好，{name} {last_name}\u0026#34;) 更丰富的界面增强 typer 除了在参数定义上的灵活简便外，对于交互界面也提供了很多增强\n颜色和结构化数据的显示支持 比如针对命令行，不同颜色的信息区分，这里它利用了另一个第三方库 rich， 可以简单地用rich库中的print方法替代掉python官方的简单打印语句，实现更丰富的颜色控制和结构化数据展示等\n1 2 3 4 5 6 7 8 9 10 def main(): print(\u0026#34;显示结构数据:\u0026#34;) print(data) print(\u0026#34;不同颜色和emoji:\u0026#34;) print(\u0026#34;[bold red]警告！[/bold red] [green]数据data[/green] 不匹配！ :boom:\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: typer.run(main) 执行效果 提示信息 typer.Option 可以支持转为提示模式，也就是对于需要的参数，可以提示输入\n比如上面的例子，加上prompt=True就会在没有输入参数时提示输入\n1 2 @app.command(help=\u0026#34;问候指定的小伙伴\u0026#34;) def hello(last_name:Annotated[str,typer.Option(\u0026#34;--last\u0026#34;,\u0026#34;-l\u0026#34;,help=\u0026#34;被问候的人员姓什么\u0026#34;, prompt=True)] 运行： 密码和信息隐藏 对于一些密码类的参数，还支持隐藏和确认的选项，比如我们增加一个passwd参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @app.command(help=\u0026#34;问候指定的小伙伴\u0026#34;) def hello(last_name:Annotated[str, typer.Option(\u0026#34;--last\u0026#34;, \u0026#34;-l\u0026#34;, help=\u0026#34;被问候的人员姓什么\u0026#34;, prompt=True)]=\u0026#34;黄\u0026#34;, passwd:Annotated[str,typer.Option(prompt=True, confirmation_prompt=True, hide_input=True)]=None, name:Annotated[str,typer.Argument(help=\u0026#34;被问候的伙伴名称\u0026#34;)]=\u0026#34;城下秋草\u0026#34;): \u0026#34;\u0026#34;\u0026#34; 这里也可以直接作为命令帮助，和command的help参数作用一样， 但优先级没有command注解高 \u0026#34;\u0026#34;\u0026#34; if passwd == \u0026#34;123\u0026#34;: print(f\u0026#34;你好，{name} {last_name}\u0026#34;) else: print(\u0026#34;[bold red]密码输入错误，不能展示！[/bold red]\u0026#34;) 进度条实现 typer还能比较方便地支持进度条类的信息交互，同样可以利用rich中progress的增强\n1 2 3 4 5 6 7 8 9 10 11 from rich.progress import track def running(): total = 0 for value in track(range(100), description=\u0026#34;正在执行中....\u0026#34;): # Fake processing time time.sleep(0.01) total += 1 print(f\u0026#34;已处理 {total} 任务\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: typer.run(running) 多层命令嵌套 对于多层的命令嵌套，typer当然也提供了良好的支持。这里是通过声明不同的应用，再利用add_typer方法完成层级的关联。\n官方给出的示例体现的很清楚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import typer app = typer.Typer() items_app = typer.Typer() app.add_typer(items_app, name=\u0026#34;items\u0026#34;) users_app = typer.Typer() app.add_typer(users_app, name=\u0026#34;users\u0026#34;) @items_app.command(\u0026#34;create\u0026#34;) def items_create(item: str): print(f\u0026#34;Creating item: {item}\u0026#34;) @items_app.command(\u0026#34;delete\u0026#34;) def items_delete(item: str): print(f\u0026#34;Deleting item: {item}\u0026#34;) @items_app.command(\u0026#34;sell\u0026#34;) def items_sell(item: str): print(f\u0026#34;Selling item: {item}\u0026#34;) @users_app.command(\u0026#34;create\u0026#34;) def users_create(user_name: str): print(f\u0026#34;Creating user: {user_name}\u0026#34;) @users_app.command(\u0026#34;delete\u0026#34;) def users_delete(user_name: str): print(f\u0026#34;Deleting user: {user_name}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: app() 用--help看一下这样处理的效果 以上就是关于命令行工具 typer的用法梳理。\n","date":"2024-09-19T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/014-%E7%94%A8typer%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91python%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/Typer_hu_8880eb8b29a76533.png","permalink":"https://chengxiaqiucao.github.io/post/014-%E7%94%A8typer%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91python%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/","title":"用Typer快速开发python命令行应用"},{"content":"Postman迎来V11大版本更新 Postman作为接口测试中，被广泛应用的一款主流工具，以其丰富的功能，灵活方便的使用方式，广受欢迎。最新发布的V11版本则在向协作平台转型的过程中一路狂奔，增加大量全新的协作支持。下面我们就一起来看看都有哪些变化吧\n协作增强 - Comments评论入口更便捷 作为一个协作平台，在之前的版本中，Postman已经提供了评论功能。可以通过右侧边栏打开评论窗口，针对不同的接口添加评论，这样对于团队协作来开发调试同一个接口时，可以实现团队的交互 但这里的评论是针对接口层面的，但实际大家在协作时，往往更多是要针对具体的消息体，消息参数、包括接口脚本进行针对性的讨论，所以新版本的改进，就是在这些地方增加了评论入口，便于针对不同的对象直接添加评论，并进行关联\n而评论窗口中也会现实具体评论关联的相关元素，便于团队成员针对具体的对象完成探讨 代码复用，引入package library 另一个更新，是关于代码复用。Postman支持灵活的脚本功能，但是之前的版本，当我们想在不同的接口中，使用同一段脚本时，一般还是拷贝粘贴。为了解决这个问题，类似于JMeter中的测试片段，Postman这个版本中引入了一个新的功能模块，Package Library，也就是可以把经常复用的脚本、函数保存为package，然后在任何需要使用的地方，引入这个packag而进行使用即可\n在Scripts（目前版本将原先的PreRequest和Tests脚本统一放到了scripts tab页下了）中，原先右侧的代码辅助栏中增加了这个新入口 在这个模块中，可以主动地将需要需要复用的代码添加为Package 或者也可以从已有代码中，选中需要复用的代码，添加到package中 使用的话，直接在package 搜索框中检索需要复用的代码package，就会自动插入对应的代码，实现复用\n1 const checkStatOk = pm.require(\u0026#39;@qiucao-testing/check_stat_ok\u0026#39;); 官方的VSCode支持插件 另一个更新是这个版本官方正式推出了VsCode的官方插件。从插件中心，搜索安装以后，需要登录Postman账号，然后就可以在VsCode直接使用Postman完成接口调测了。和桌面端的功能基本类似。\nWorkspace update，接口变更的分享 Postman在向协作平台转变的过程中，它的Workspace是核心概念。而对于团队协作来说，针对接口共同开发，团队成员能及时获知大家共同协作的这个空间中的相关变化非常关键。\n而新版本中提供的workspace update功能，其实比较类似代码管理中的commit 记录，可以记录空间中的接口变化、便于回溯历史，并及时知会到团队成员。\n当然这个update目前只针对团队空间以及公共空间有效。 PostBot， 接口AI机器人 新版中另一个比较重磅的更新是极大增强了Postman助手机器人的AI能力。\n比如可以通过postbot帮助我们生成一些对应的校验脚本 或者，也可以针对collecion，通过呼出postbot，通过它提供的generate tests功能自动帮助我们生成一系列针对接口定义的测试用例，非常的方便，极大节省了接口自动化用例的开发成本 随着AI的能力增强和测试工具和AI的集成，通过AI来辅助测试人员提升测试效率和提高产出已经越来越成为明显趋势。\n以上就是关于Postman最新发布版本相关新功能的分享。 欢迎关注~\n","date":"2024-09-12T14:57:14+08:00","image":"https://chengxiaqiucao.github.io/post/015-postmanv11%E6%9B%B4%E6%96%B0%E4%BE%BF%E8%A7%88/v11-Launch-Blog_hu_7ee912cc08b7b0eb.jpg","permalink":"https://chengxiaqiucao.github.io/post/015-postmanv11%E6%9B%B4%E6%96%B0%E4%BE%BF%E8%A7%88/","title":"PostmanV11更新便览"},{"content":"Selenium诞生于2004年，以其开源、功能全面长期以来长期排名Web 自动化测试工具领域的Top1，是目前最主流的Web自动化测试工具，而Selenium的核心Webdriver 更是作为W3C的通行标准，被各类工具广泛参照。可以说是目前web自动化测试的事实标准。\nSelenium 4带来的变化 Selenium本身经过多年的演进，目前已经发布到V4.24版本。 虽然目前网上还广泛流传V3版本相关的用法和资料，但Selenium 4 其实是一个非常大的更新版本。它的几个核心组件都进行的极大程度的重构。\nWebDriver 从原先的Json Wire Protocol 切换为了W3C的标准定义 Selenium IDE 完成重构和功能优化 Selenium Grid 完成重构，支持更灵活的云服务架构 此外Selenium 4中还引入了一个很重要的工具，也就是本篇我们要重点来介绍的Selenium Manager（实际是V4.6才引入，到V4.12 功能才基本完备\n原先的浏览器驱动方式带来的问题 要了解Selenium Manager，我们还是要先了解下Selenium的工作原理。\nSelenium工作原理 下图是官网给的Selenium本地运行的基本架构。 可以看到，Selenium实际上完成自动化，是通过webdriver协议驱动不同类型的浏览器（Chrome、Firefox、IE、Edge、Safari等）完成指定的动作，以此达到自动化执行的目的。\n而驱动浏览器的关键，是和浏览器对应的浏览器Driver驱动，比如Chrome对应的ChromeDriver， FireFox对应的GecoDriver等。\n而Selenium本身，则是基于WebDriver协议和浏览器Driver完成交互。\n导致的问题 这个架构和工作原理虽然清晰，但是有一个问题，就是浏览器的版本是不断更新的。而浏览器驱动版本需要和浏览器版本匹配，不匹配的驱动和浏览器版本，共同工作可能存在各种预期外的异常，所以Selenium要正常工作，再用Selenium库完成编码前，首先就是要保证浏览器驱动和浏览器版本的部署和匹配。\n但浏览器版本和对应的驱动，通常都是由浏览器厂商维护的。\n所以这里的自动化测试环境准备就会变得比较复杂，要安装对应被测版本的浏览器，同时还要找到对应这个版本的驱动，再把相关路径配置给Selenium，然后Selenium才能完成正常的驱动。\n此外，浏览器的版本，一般还有自动更新功能，可能在用户没感知的情况，其实版本已经变化了，但此时驱动版本并不会同步更新，所以也导致驱动和浏览器版本不匹配的潜在问题。\n这个问题，其实长期没有得到很好地解决，Selenium 3和Selenium 4的早期版本，我们部署Selenium 自动化环境，浏览器版本和驱动版本的获取和匹配一直是一个比较麻烦的工作，也因此劝退了不少自动化测试小白。\nChrome对驱动问题的应对 既然这个问题由来已久，浏览器厂商其实也意识到驱动和浏览器版本不匹配，给自动化测试带来的困扰。\n以Chrome为例，我们去到 ChromeDriver官方下载 网址的话，会看到这样的页面\n可以看到，这里对Chrome Driver的下载只提供到了114版本，而最新的Chrome其实已经到了128版本。 对于115版本以后，Chrome浏览器其实调整了driver的发布策略，也就是Chrome driver会跟随 Chrome for Testing 版本同步发布。严格保证driver和浏览器版本的同步匹配。\n那这里为什么有一个Chrome for Testing版本呢？\n我们之前提到，浏览器版本，会有自动更新，如果进行自动更新，driver版本不会同步更新，所以导致dirver和浏览器的不匹配。\n所以Chrome for Testing与正式版本的主要区别，其实就是 for Testing版本是不会进行自动更新的。\n这样，再加上版本号和浏览器版本的共用，就能很方便地保证浏览器和驱动的一致。\nSelenium应对驱动匹配问题的解决方案 那上面是浏览器对驱动匹配问题给出的解决方法，但其实还是没有完全解决浏览器、Driver需要分别获取和指定的问题。那么Selenium官方对这个问题的解决方案，就是Selenium Manager。它其实是一个包含在Selenium库中，无需额外安装的可执行程序。\n我们目前使用Selenium V4来执行一个简单的自动化测试脚本的话:\n比如通过百度，搜索城下秋草 测试, 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from selenium import webdriver from selenium.webdriver.common.by import By from time import sleep def test_baidu_search(): option = webdriver.ChromeOptions() option.browser_version = \u0026#39;117\u0026#39; driver = webdriver.Chrome(options=option) driver.get(\u0026#34;https://www.baidu.com\u0026#34;) driver.find_element(By.ID,\u0026#39;kw\u0026#39;).send_keys(\u0026#39;城下秋草 测试\u0026#39;) sleep(2) driver.find_element(By.ID,\u0026#39;su\u0026#39;).click() sleep(3) driver.close() 只要安装了Selenium库，执行的时候，就可以正常地驱动, 并不需要特别地去获取驱动和配置。\nSelenium 4 启动自动化执行源码分析 这里我们从Selenium的Python源码来分析下它的启动过程：\ndriver = webdriver.Chrome(options=option) 这行代码其实会调用Slenium库中Chromium基础浏览器的webdriver初始化代码，位置在.venv/Lib/site-packages/selenium/webdriver/chromium/webdriver.py\n初始化时，可以看到，会通过DriverFinder方法来获取浏览器和Driver的路径\n1 2 3 4 5 6 7 finder = DriverFinder(self.service, options) if finder.get_browser_path(): options.binary_location = finder.get_browser_path() options.browser_version = None self.service.path = finder.get_driver_path() self.service.start() 而获取路径的方法，其实就是调用了SeleniumManager模块的binary_paths方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def get_browser_path(self) -\u0026gt; str: return self._binary_paths()[\u0026#34;browser_path\u0026#34;] def get_driver_path(self) -\u0026gt; str: return self._binary_paths()[\u0026#34;driver_path\u0026#34;] def _binary_paths(self) -\u0026gt; dict: if self._paths[\u0026#34;driver_path\u0026#34;]: return self._paths . . . output = SeleniumManager().binary_paths(self._to_args()) . . . return self._paths 而SeleniumManager模块，则会执行SeleniumManager的二进制程序，根据相关参数，获取浏览器和驱动版本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def _run(args: List[str]) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34;Executes the Selenium Manager Binary. :Args: - args: the components of the command being executed. :Returns: The log string containing the driver location. \u0026#34;\u0026#34;\u0026#34; command = \u0026#34; \u0026#34;.join(args) logger.debug(\u0026#34;Executing process: %s\u0026#34;, command) try: if sys.platform == \u0026#34;win32\u0026#34;: completed_proc = subprocess.run(args, capture_output=True, creationflags=subprocess.CREATE_NO_WINDOW) else: completed_proc = subprocess.run(args, capture_output=True) stdout = completed_proc.stdout.decode(\u0026#34;utf-8\u0026#34;).rstrip(\u0026#34;\\n\u0026#34;) stderr = completed_proc.stderr.decode(\u0026#34;utf-8\u0026#34;).rstrip(\u0026#34;\\n\u0026#34;) output = json.loads(stdout) if stdout != \u0026#34;\u0026#34; else {\u0026#34;logs\u0026#34;: [], \u0026#34;result\u0026#34;: {}} except Exception as err: raise WebDriverException(f\u0026#34;Unsuccessful command executed: {command}\u0026#34;) from err SeleniumManager._process_logs(output[\u0026#34;logs\u0026#34;]) result = output[\u0026#34;result\u0026#34;] if completed_proc.returncode: raise WebDriverException( f\u0026#34;Unsuccessful command executed: {command}; code: {completed_proc.returncode}\\n{result}\\n{stderr}\u0026#34; ) return result 所以，目前的Selenium 4版本执行时，会通过SeleniumManager程序来确定需要的浏览器和对应的driver版本。\nSelenium Manager 命令行程序 而通过SeleniumManager，根据我们配置的浏览器类型和版本，它可以自动的匹配相关的driver版本，并自行联网，获取相关驱动和浏览器版本的文件，供Selenium调用。 比如上例中，我们指定了浏览器版本为 117, 执行以后，在用户目录的 .cache\\selenium目录下其实就会保存下载的浏览器和对应的驱动版本。下图是当前执行更新的117 版本的驱动。\n这里Selenium调用的是Selenium-manager这个命令行程序\n我们可以直接执行这个程序，加上--help看一下支持的参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 selenium-manager 0.4.24 Selenium Manager is a CLI tool that automatically manages the browser/driver infrastructure required by Selenium. Usage: selenium-manager [OPTIONS] Options: --browser \u0026lt;BROWSER\u0026gt; Browser name (chrome, firefox, edge, iexplorer, safari, safaritp, or webview2) --driver \u0026lt;DRIVER\u0026gt; Driver name (chromedriver, geckodriver, msedgedriver, IEDriverServer, or safaridriver) --grid [\u0026lt;GRID_VERSION\u0026gt;] Selenium Grid. If version is not provided, the latest version is downloaded --driver-version \u0026lt;DRIVER_VERSION\u0026gt; Driver version (e.g., 106.0.5249.61, 0.31.0, etc.) --browser-version \u0026lt;BROWSER_VERSION\u0026gt; Major browser version (e.g., 105, 106, etc. Also: beta, dev, canary -or nightly-, and esr -in Firefox- are accepted) --browser-path \u0026lt;BROWSER_PATH\u0026gt; Browser path (absolute) for browser version detection (e.g., /usr/bin/google-chrome, \u0026#34;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\u0026#34;, \u0026#34;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\u0026#34;) --driver-mirror-url \u0026lt;DRIVER_MIRROR_URL\u0026gt; Mirror for driver repositories (e.g., https://registry.npmmirror.com/-/binary/chromedriver/) --browser-mirror-url \u0026lt;BROWSER_MIRROR_URL\u0026gt; Mirror for browser repositories --output \u0026lt;OUTPUT\u0026gt; Output type: LOGGER (using INFO, WARN, etc.), JSON (custom JSON notation), SHELL (Unix-like), or MIXED (INFO, WARN, DEBUG, etc. to stderr and minimal JSON to stdout) [default: LOGGER] --os \u0026lt;OS\u0026gt; Operating system (i.e., windows, linux, or macos) --arch \u0026lt;ARCH\u0026gt; System architecture (i.e., x32, x64, or arm64) --proxy \u0026lt;PROXY\u0026gt; HTTP proxy for network connection (e.g., https://myproxy.net:8080) --timeout \u0026lt;TIMEOUT\u0026gt; Timeout for network requests (in seconds) [default: 300] --ttl \u0026lt;TTL\u0026gt; TTL (time-to-live) for discovered versions (online) of drivers and browsers [default: 3600] --cache-path \u0026lt;CACHE_PATH\u0026gt; Local folder used to store downloaded assets (drivers and browsers), local metadata, and configuration file [default: ~/.cache/selenium] --clear-cache Clear cache folder (~/.cache/selenium) --clear-metadata Clear metadata file (~/.cache/selenium/selenium-manager.json) --debug Display DEBUG messages --trace Display TRACE messages --log-level \u0026lt;LOG_LEVEL\u0026gt; Level for output messages. The possible values are: info, debug, trace, warn, error --offline Offline mode (i.e., disabling network requests and downloads) --force-browser-download Force to download browser (even when browser is already in the system) --avoid-browser-download Avoid to download browser (even when browser-version is specified) --language-binding \u0026lt;LANGUAGE_BINDING\u0026gt; Selenium language bindings that invokes Selenium Manager (e.g., Java, JavaScript, Python, DotNet, Ruby) --avoid-stats Avoid sends usage statistics to plausible.io -h, --help Print help -V, --version Print version 我们可以执行看一下这里输出信息，其实selenium在执行时就是调用的这个命令行程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026gt;selenium-manager.exe --browser firefox --debug #debug参数显示详细输出 [2024-09-10T13:35:56.007Z DEBUG] geckodriver not found in PATH # 首先在系统Path路径中根据指定的浏览器判断是否存在驱动 [2024-09-10T13:35:56.010Z DEBUG] firefox not found in PATH # 同样根据Path路径中是否包含firefox浏览器安装路径 [2024-09-10T13:35:56.010Z DEBUG] Running command: REG QUERY HKCU\\Software\\Mozilla\\Mozilla Firefox /v CurrentVersion [2024-09-10T13:35:56.034Z DEBUG] Output: \u0026#34;\u0026#34; [2024-09-10T13:35:56.036Z DEBUG] firefox not found in the system # 通过注册表查找firefox浏览器安装路径 [2024-09-10T13:35:56.037Z DEBUG] Required browser: firefox 130.0 -- 未指定浏览器版本，根据联网信息获取最新版本 [2024-09-10T13:35:56.037Z DEBUG] Downloading firefox 130.0 from https://ftp.mozilla.org/pub/firefox/releases/130.0/win64/en-US/Firefox%20Setup%20130.0.exe # 从官网下载 [2024-09-10T13:36:13.320Z DEBUG] firefox 130.0 is available at C:\\Users\\Administrator\\.cache\\selenium\\firefox\\win64\\130.0\\firefox.exe # 完成下载 [2024-09-10T13:36:14.367Z DEBUG] Valid geckodriver versions for firefox 130: [\u0026#34;0.35.0\u0026#34;, \u0026#34;0.34.0\u0026#34;] # 获取可用driver 版本 [2024-09-10T13:36:14.369Z DEBUG] Required driver: geckodriver 0.35.0 [2024-09-10T13:36:14.372Z DEBUG] Downloading geckodriver 0.35.0 from https://github.com/mozilla/geckodriver/releases/download/v0.35.0/geckodriver-v0.35.0-win64.zip # 下载对应driver [2024-09-10T13:36:18.238Z INFO ] Driver path: C:\\Users\\Administrator\\.cache\\selenium\\geckodriver\\win64\\0.35.0\\geckodriver.exe [2024-09-10T13:36:18.239Z INFO ] Browser path: C:\\Users\\Administrator\\.cache\\selenium\\firefox\\win64\\130.0\\firefox.exe # 输出browser和driver路径，其实selenium调用时的返回值就是这个信息 而除了Browser和Driver外，Selenium-manager其实还支持grid版本的下载。通过--grid 参数就可以直接下载grid的最新版本。\n1 2 3 4 5 6 \u0026gt; selenium-manager.exe --grid --debug [2024-09-10T13:47:41.793Z DEBUG] Sending stats to Plausible: Props { browser: \u0026#34;grid\u0026#34;, browser_version: \u0026#34;\u0026#34;, os: \u0026#34;windows\u0026#34;, arch: \u0026#34;amd64\u0026#34;, lang: \u0026#34;\u0026#34;, selenium_version: \u0026#34;4.24\u0026#34; } [2024-09-10T13:47:41.795Z DEBUG] grid not found in the system [2024-09-10T13:47:43.667Z DEBUG] Required driver: selenium-server 4.24.0 [2024-09-10T13:47:43.669Z DEBUG] Downloading selenium-server 4.24.0 from https://github.com/SeleniumHQ/selenium/releases/download/selenium-4.24.0/selenium-server-4.24.0.jar [2024-09-10T13:47:51.547Z INFO ] Driver path: C:\\Users\\Administrator\\.cache\\selenium\\grid\\4.24.0\\selenium-server-4.24.0.jar 通过以上介绍，可以看出，通过引入Selenium-manager，Selenium在环境准备时已经可以非常灵活地实现对浏览器、驱动包括grid server等资源的自动获取和配置，极大提升了使用Selenium的便利性。\n","date":"2024-09-07T18:03:04+08:00","image":"https://chengxiaqiucao.github.io/post/013-selenium-manager/Se-m_hu_f281fc6a0d3d0fa4.png","permalink":"https://chengxiaqiucao.github.io/post/013-selenium-manager/","title":"Selenium Manager用法详解"},{"content":"敏捷是现今被广泛应用的一种研发理念和思想。著名的敏捷宣言也广为流传，被翻译为了60多种语言。\n这个宣言其实更多是提出了软件研发中的一些被这些先驱者们认为更重要的价值观，传递的是一种不同于传统研发的新理念。\n但提出这些理念背后的逻辑，又是什么呢？\n我们还是应该搞清楚为什么有这样的一个宣言，否则大家虽然都号称在施行敏捷，但又有点似是而非，甚至因为敏捷又搞出很多流程、仪式和各种敏捷工具，兜兜转转又回到原点。\n这里笔者尝试理解下敏捷宣言的背后逻辑和真正作用，抓住这个核心，其实就理解了敏捷的本质。\n敏捷的核心是文化 敏捷宣言中提倡的个体和互动、可工作的软件、客户合作、响应变化，其实都不是一些具体的实践，说是价值观可能更合适。\n而价值观，其实就是建立文化的重要要素。\n任何组织，发展到一定阶段，都会开始强调文化的重要性。\n因为成熟的组织，在经过规范化的发展，有成熟的制度体系后，会发现依然有很多事情是无法依靠制度就能很好解决的。这时，冀望解决的途径就是依靠文化的力量。\n敏捷正是在传统严重依赖流程、制度的研发流程基础上，针对大量无法依靠流程、规范来成功完成软件研发的经验教训，而提出的从文化层面上去指导大家建立正确的软件研发文化，去主动改进而不是否定原有流程、规范的作用。\n所以，这里思考的结论就是：\n敏捷其实是一种思想转变，是建立软件研发正确行为方式的一种价值观。实现途径可能千差万别，本质就是强调建立正确的研发价值观，比具体的流程、规范更为重要。\n文化是制度的升华 所以这里把敏捷理解为建立文化的行为，也就理解了敏捷各种实践、提倡做法的背后逻辑。\n文化和制度是一个组织发展的支撑。它们都是为了指导组织成员去正确地做事\n制度通过各种明文规定、流程指引成员。遵守制度做事，是被动地正确行事 文化则是通过潜移默化，组织中大家拥有共同的使命、愿景、价值观，体现到成员的行为方式上。是主动地正确行事。 文化是什么？ 文化其实是实际中，组织成员的行为方式。\n了解企业文化，也会包括使命、价值观、愿景、战略这些文化的要素。\n它们的关系可以用下面这个图概括\n回到敏捷：\n敏捷宣言 其实是价值观 敏捷的12原则 其实是实施战略 敏捷的愿景 其实和所有产品一样，向用户交付价值\n最终，敏捷冀望达成的，就是建立起一种面向软件研发的新文化\n水无常形， 兵无常势。敏捷也不存在所谓的标准做法，符合敏捷价值观，达成共识并进行实践的团队，就是敏捷团队。\n推广下我的测试课程，感兴趣的小伙伴可以通过以下链接了解下哦\n❤️❤️❤️❤️ 城下秋草的测试职业进阶提升课 ❤️❤️❤️❤️\n","date":"2024-09-01T14:32:39+08:00","image":"https://chengxiaqiucao.github.io/post/008-understand-the-real-logic-behind-agile-manifesto/agile_mani_hu_bf195b0471a0dc51.png","permalink":"https://chengxiaqiucao.github.io/post/008-understand-the-real-logic-behind-agile-manifesto/","title":"理解敏捷宣言背后的文化逻辑"},{"content":"现今我们的自动化测试、测试工具、各种框架其实会依赖很多知名的开源框架，比如Pytest、Junit，Selenium、Appium、JMeter等等都是应用非常广泛的开源框架。而正因为用户广泛，社区繁荣，所以这些开源项目本身的更新迭代也是极为频繁的，不定期地会引入一些新功能，同时也会对一些历史版本中的原有功能进行调整或者废弃。\n这些频繁更新，在推动开源项目不断发展的同时，也为我们使用这些项目带来了一些困扰，就是不知道什么时候可能原来用的功能在新版本中就发生了变化，为我们及时应用新版本带来不少挑战。\n针对这个问题，通常的做法，其实就是去查看项目的发布记录，了解每个版本发布的主要变化，也了解相关项目本身的发展趋势。\n而测试工作牵涉到的各种主流开源项目又比较多，所以这里就有了自动收集各种主流版本发布记录并集中汇总的想法。\n下面就是我利用Github接口自动收集一些主流测试相关开源项目的版本更新记录，转化为网页放到个人博客 上的呈现效果，对于我们一站掌握各种主流开源框架的变更趋势带来一些便利。\n主页： 项目更新记录详情（目前保留最近10次更新） 核心方法其实就是下面这段，通过预定义的项目清单，获取对应项目的历史发布记录。分享如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def update_release_list(self): \u0026#34;\u0026#34;\u0026#34; 获取项目release清单并更新以保持清单列表文件 :return: \u0026#34;\u0026#34;\u0026#34; for project in self.projects: name = project[\u0026#34;name\u0026#34;] url = self.baseUrl + f\u0026#39;/repos/{project[\u0026#34;repo\u0026#34;]}/releases\u0026#39; res = requests.get(url, headers=self.headers) # 获取项目总页数 pages = APIs.github_page_count(res) total = pages[\u0026#39;last\u0026#39;] if \u0026#39;last\u0026#39; in pages else 1 # 已保存的release清单，作为当前清单基准 if not os.path.exists(os.path.join(self.release_dir, f\u0026#39;{name}.json\u0026#39;)): old_list = [] else: with open(os.path.join(self.release_dir, f\u0026#39;{name}.json\u0026#39;), \u0026#34;r\u0026#34;, encoding=\u0026#39;utf-8\u0026#39;) as file: old_list = json.load(file) release_list = old_list # 去除原清单中的状态字段, 用于比对 old_list = [{k: v for k, v in d.items() if k != \u0026#39;status\u0026#39;} for d in old_list] # 首页已获取，生成清单，默认状态False(未获取detail) if res.headers[\u0026#39;content-type\u0026#39;].find(\u0026#39;json\u0026#39;) \u0026gt; 0 and isinstance(res.json(), list): for release in res.json(): record = {\u0026#39;id\u0026#39;: release[\u0026#39;id\u0026#39;], \u0026#39;name\u0026#39;: release[\u0026#39;name\u0026#39;], \u0026#39;date\u0026#39;: release[\u0026#39;created_at\u0026#39;]} if record not in old_list: record[\u0026#39;status\u0026#39;] = False release_list.append(record) print(f\u0026#39;got release {release[\u0026#39;id\u0026#39;]}-{release[\u0026#39;name\u0026#39;]}, 1-{total}\u0026#39;) else: print(f\u0026#39;release {release[\u0026#39;id\u0026#39;]}-{release[\u0026#39;name\u0026#39;]} exist!\u0026#39;) # 获取后续页面清单 if \u0026#39;last\u0026#39; in pages and \u0026#39;next\u0026#39; in pages: for i in range(pages[\u0026#39;next\u0026#39;], total + 1): page_url = url + f\u0026#39;?page={i}\u0026#39; res = requests.get(page_url, headers=self.headers) if res.headers[\u0026#39;content-type\u0026#39;].find(\u0026#39;json\u0026#39;) \u0026gt; 0 and isinstance(res.json(), list): for release in res.json(): record = {\u0026#39;id\u0026#39;: release[\u0026#39;id\u0026#39;], \u0026#39;name\u0026#39;: release[\u0026#39;name\u0026#39;], \u0026#39;date\u0026#39;: release[\u0026#39;created_at\u0026#39;]} if record not in old_list: record[\u0026#39;status\u0026#39;] = False release_list.append(record) print(f\u0026#39;got release {release[\u0026#39;id\u0026#39;]}-{release[\u0026#39;name\u0026#39;]}, {i}-{total}\u0026#39;) else: print(f\u0026#39;release {release[\u0026#39;id\u0026#39;]}-{release[\u0026#39;name\u0026#39;]} exist!\u0026#39;) # 按id排序 release_list.sort(key=lambda x: x[\u0026#39;id\u0026#39;], reverse=True) # 更新清单文件 with open(os.path.join(self.release_dir, f\u0026#39;{name}.json\u0026#39;), \u0026#34;w\u0026#34;, encoding=\u0026#39;utf-8\u0026#39;) as file: file.write(json.dumps(release_list)) 再结合具体release的id获取详情信息，组装md文档直接用hugo生成页面文件就可以了.\n","date":"2024-08-31T14:27:02+08:00","image":"https://chengxiaqiucao.github.io/post/011-%E5%A6%82%E4%BD%95%E5%8F%8A%E6%97%B6%E6%8E%8C%E6%8F%A1%E5%90%84%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%80%E6%96%B0%E5%8F%98%E5%8C%96/Pasted-20240831-1_hu_e448b511818fc3e9.png","permalink":"https://chengxiaqiucao.github.io/post/011-%E5%A6%82%E4%BD%95%E5%8F%8A%E6%97%B6%E6%8E%8C%E6%8F%A1%E5%90%84%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%80%E6%96%B0%E5%8F%98%E5%8C%96/","title":"如何及时掌握各种常用框架的最新变化？"},{"content":"对测试工作目的的认识误区 在IT行业，其实一直对软件测试，测试这个工作的目的，一直有着不太准确的认识。\n各种说法都有，比较流行，被很多IT工作甚至测试从业者认可的有下面两种：\n测试是为了发现Bug 大家一般概念中通常都会把做测试和找Bug等同起来，也就是说软件测试的目的是为了发现产品中的问题。\n测试是为了验证产品满足需求 也有从测试执行的角度来说，测试工作是为了证明软件产品是符合产品需求定义，是为了验证需求是否实现的。\n那这些说法对不对呢？ 可以说对，也可以说不对\n确实，测试工作的主要产出就是我们发现的各种产品bug，而要验证需求则是我们测试工作的主要输入和评估标准。\n但这些就是我们要进行测试工作的目的吗？\n单纯把测试工作的目的从上面几点来看就狭隘了。\n测试是为了找Bug吗？ 我们做测试工作是为了发现bug吗？\nbug对于产品来说，意味着成本，bug本身对产品来说是不会产生价值的。被解决掉的Bug才会带来产品质量的提升，进而体现到产品的价值中去。bug的减少，对产品才有价值。\n所以，单纯地把发现更多bug作为测试工作目的是一个误区，这也是很多团队错误地把发现bug的数量作为测试工作成效依据的主要原因。如果bug发现得越多代表测试工作越好，测试人员是不是就不应该再早期阶段去参与？因为在前期就规避掉的问题其实会导致到测试阶段bug变少，如果测试工作是希望发现更多bug，是不是就应该希望产品提测的时候包含更多bug呢？ 这个导向显然是不符合产品利益的。\n因此把发现bug作为测试工作的目的是一个常见的，明显的对测试工作的认识误区\n测试就是为了验证需求吗？ 第二个对测试工作目的的认识误区，就是认为测试工作就是为了验证产品的需求。这其实是另一个被广泛接受的错误认识。甚至我们当今流传广泛的很多软件工程实践，都是建立在这个错误认识之上的。\n测试大牛James Bach有篇著名的论文，探讨了Testing跟Checking的区别。\n也就是测试工作远远不止是checking。而验证需求，这样的checking只是测试工作的一部分。测试要深入产品、发现潜在的深层问题，还需要除了checking之外的更多其他能力支撑，包括探索、试验、设问、推理等等\n所以，把验证需求，当作测试工作的目的，是不够的。像工厂质检那样依据严格的规程来确定产品是否合格，和软件产品这种偏创造性的行业也并不匹配。这也是我们说自动化测试更多是为了提升执行效率和快速得到已覆盖场景的验证结果反馈，但自动化测试本身并不能达到完成产品测试的目的。\n测试除了验证需求中明确的功能外，还需要针对交付产品进行更深度的探索，才更可能充分发现产品中的质量问题。这也是近年探索式测试被更多提及的主要缘由。\n软件测试工作的真正目的 好，那既然测试工作的目的既不是为了找Bug，也不是为了验证需求，那目的究竟是什么呢？\n软件测试的真正目的： 准确、及时地评估出被测对象的质量状态\n这里的核心是评估质量状态。质量是产品属性，只能通过产品本身的变更来调整，所以测试工作无法提高质量，也无法保证质量。但通过测试工作，我们可以通过暴露产品中的问题，反映出产品的质量状态。我们的主要作用是对当前产品的质量进行评估。再由产品或项目针对这个状态来对质量进行改进。\n所以测试工作对于质量的贡献更多体现在这个评估出的质量状态是否及时和准确两方面。\n准确评估 测试无法穷尽，在有限的时间内发现产品的所有问题也是不可能的。但测试的职责是需要在有限的时间内，尽可能多地将影响产品质量的问题暴露出来。这里除了数量外，我们还要看问题的影响，综合这两点，才是更准确地反映质量。\n及时评估 产品是无法进行无限测试的，而且测试工作其实本身是成本支出。所以通过测试工作得出产品质量状态的时效对于产品的质量改进和成本控制也尤为关键。问题发现得越早，修复成本就越低；得出质量状态评估的时间越短，产品进行针对性改进的空间就越大。所以测试工作的目的，还包括提高测试效率，通过自动化、测试左移等手段来尽可能及时地完成产品质量评估。\n所以这才是我们进行软件测试工作的真正目的，不是为了发现更多的bug，也不是仅仅是对需求实现的检查，而是通过我们的专业能力，在有限的时间内，及时、充分地反映出当前产品实际的质量状态。\n以上就是关于软件测试工作目的 的分享，我是城下秋草。 秋草观测台，观察测试业\n推广下我的测试课程，感兴趣的小伙伴可以通过以下链接了解下哦\n❤️❤️❤️❤️ 城下秋草的测试职业进阶提升课 ❤️❤️❤️❤️\n","date":"2024-08-30T20:35:21+08:00","image":"https://chengxiaqiucao.github.io/post/007-what-is-testing-goal/testing_hu_aabdee14167ac95.png","permalink":"https://chengxiaqiucao.github.io/post/007-what-is-testing-goal/","title":"软件测试的目的到底是什么？"},{"content":"pytest作为Python技术栈下最主流的测试框架，功能极为强大和灵活。其中Fixture夹具是它的核心。而且pytest中对Fixture的作用范围也做了不同区分，能为我们利用fixture带来很好地灵活性。\n下面我们就来了解下这里不同scope的作用\nfixture的scope定义 首先根据官网的说明，Pytest中fixture的作用范围支持5种设定，分别是function(默认值), classs, module, package, session\n作用范围 说明 function 默认值，对每个测试方法（函数）生效，生命周期在测试方法级别 class 对测试类生效，生命周期在测试类级别 module 对测试模块生效，生命周期在模块（文件）级别 package 对测试包生效，生命周期在测试包（目录）级别 session 对测试会话生效，生命周期在会话（一次pytest运行）级别 下面结合代码来说明，假设目前有这样的代码结构\nrun_params是被测方法\n1 2 3 4 5 6 7 8 9 10 def deal_params(p): print(f\u0026#34;input :{p}\u0026#34;) if type(p) is int: return p*10 if type(p) is str: return p*3 if type(p) in (tuple, list): return \u0026#34;_\u0026#34;.join(p) else: raise TypeError test_ch_param, test_fixture_scope中分别定义了参数化和在测试类中的不同测试方法\n1 2 3 4 5 import pytest @pytest.mark.parametrize(\u0026#34;param\u0026#34;,[10, \u0026#34;城下秋草\u0026#34;, \u0026#34;软件测试\u0026#34;, (\u0026#34;示例\u0026#34;, \u0026#34;代码\u0026#34;)]) def test_params_mark(param): print(deal_params(param)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import pytest class TestFixtureScope1: def test_int(self): assert deal_params(2) == 20 def test_str(self): assert deal_params(\u0026#34;秋草\u0026#34;) == \u0026#34;秋草秋草秋草\u0026#34; class TestFixtureScope2: def test_list(self): assert deal_params([\u0026#34;城下\u0026#34;,\u0026#34;秋草\u0026#34;]) == \u0026#34;城下_秋草\u0026#34; def test_dict(self): with pytest.raises(TypeError): deal_params({\u0026#34;name\u0026#34;: \u0026#34;秋草\u0026#34;}) 在公共方法文件conftest.py中定义fixture: prepare， 设置了autouse=True，即会根据fixture的设置范围自动应用\n1 2 3 4 5 @pytest.fixture(autouse=True, scope=\u0026#39;function\u0026#39;) def prepare(): print(\u0026#39;-----some setup actions.....\u0026#39;) yield print(\u0026#39;-----some teardown actions!!\u0026#39;) 这里我们分别调整prepare的scope为不同取值，然后得到对应的输出\nfunction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 (.venv) C:\\Chengxiaqiucao pytest ======================================== test session starts ========================================= collected 8 items BlogDemo/testDemo/test_ch_parm.py::test_params_mark[10] -----some setup actions..... input :10 100 PASSED-----some teardown actions!! BlogDemo/testDemo/test_ch_parm.py::test_params_mark[城下秋草] -----some setup actions..... input :城下秋草 城下秋草城下秋草城下秋草 PASSED-----some teardown actions!! BlogDemo/testDemo/test_ch_parm.py::test_params_mark[软件测试] -----some setup actions..... input :软件测试 软件测试软件测试软件测试 PASSED-----some teardown actions!! BlogDemo/testDemo/test_ch_parm.py::test_params_mark[param3] -----some setup actions..... input :(\u0026#39;示例\u0026#39;, \u0026#39;代码\u0026#39;) 示例_代码 PASSED-----some teardown actions!! BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_int -----some setup actions..... input :2 PASSED-----some teardown actions!! BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_str -----some setup actions..... input :秋草 PASSED-----some teardown actions!! BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_list -----some setup actions..... input :[\u0026#39;城下\u0026#39;, \u0026#39;秋草\u0026#39;] PASSED-----some teardown actions!! BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_dict -----some setup actions..... input :{\u0026#39;name\u0026#39;: \u0026#39;秋草\u0026#39;} PASSED-----some teardown actions!! ========================================= 8 passed in 0.27s ========================================== fixture运行了8次\nclass 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 (.venv) C:\\Chengxiaqiucao pytest ======================================== test session starts ========================================= collected 8 items BlogDemo/testDemo/test_ch_parm.py::test_params_mark[10] -----some setup actions..... input :10 100 PASSED-----some teardown actions!! BlogDemo/testDemo/test_ch_parm.py::test_params_mark[城下秋草] -----some setup actions..... input :城下秋草 城下秋草城下秋草城下秋草 PASSED-----some teardown actions!! BlogDemo/testDemo/test_ch_parm.py::test_params_mark[软件测试] -----some setup actions..... input :软件测试 软件测试软件测试软件测试 PASSED-----some teardown actions!! BlogDemo/testDemo/test_ch_parm.py::test_params_mark[param3] -----some setup actions..... input :(\u0026#39;示例\u0026#39;, \u0026#39;代码\u0026#39;) 示例_代码 PASSED-----some teardown actions!! BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_int -----some setup actions..... input :2 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_str input :秋草 PASSED-----some teardown actions!! BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_list -----some setup actions..... input :[\u0026#39;城下\u0026#39;, \u0026#39;秋草\u0026#39;] PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_dict input :{\u0026#39;name\u0026#39;: \u0026#39;秋草\u0026#39;} PASSED-----some teardown actions!! ========================================= 8 passed in 0.27s ========================================== test_ch_param中的测试方法，因为直接定义在文件中，也属于类级别，所以每次赋值参数，fixture也被调用。 而 test_fixture_scope中明确定义了两个测试类，所以运行了2次\nmodule 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 (.venv) C:\\Chengxiaqiucao pytest ======================================== test session starts ========================================= collected 8 items BlogDemo/testDemo/test_ch_parm.py::test_params_mark[10] -----some setup actions..... input :10 100 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[城下秋草] input :城下秋草 城下秋草城下秋草城下秋草 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[软件测试] input :软件测试 软件测试软件测试软件测试 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[param3] input :(\u0026#39;示例\u0026#39;, \u0026#39;代码\u0026#39;) 示例_代码 PASSED-----some teardown actions!! BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_int -----some setup actions..... input :2 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_str input :秋草 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_list input :[\u0026#39;城下\u0026#39;, \u0026#39;秋草\u0026#39;] PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_dict input :{\u0026#39;name\u0026#39;: \u0026#39;秋草\u0026#39;} PASSED-----some teardown actions!! ========================================= 8 passed in 0.27s ========================================== 修改为module范围后，可以看到，每个模块文件调用了一次fixture\npackage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 (.venv) C:\\Chengxiaqiucao pytest ======================================== test session starts ========================================= collected 8 items BlogDemo/testDemo/test_ch_parm.py::test_params_mark[10] -----some setup actions..... input :10 100 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[城下秋草] input :城下秋草 城下秋草城下秋草城下秋草 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[软件测试] input :软件测试 软件测试软件测试软件测试 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[param3] input :(\u0026#39;示例\u0026#39;, \u0026#39;代码\u0026#39;) 示例_代码 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_int input :2 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_str input :秋草 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_list input :[\u0026#39;城下\u0026#39;, \u0026#39;秋草\u0026#39;] PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_dict input :{\u0026#39;name\u0026#39;: \u0026#39;秋草\u0026#39;} PASSED-----some teardown actions!! ========================================= 8 passed in 0.27s ========================================== 修改为package， 这是因为两个测试文件位于同一个package内， 所以运行了一次\nsession 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 (.venv) C:\\Chengxiaqiucao pytest ======================================== test session starts ========================================= collected 8 items BlogDemo/testDemo/test_ch_parm.py::test_params_mark[10] -----some setup actions..... input :10 100 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[城下秋草] input :城下秋草 城下秋草城下秋草城下秋草 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[软件测试] input :软件测试 软件测试软件测试软件测试 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[param3] input :(\u0026#39;示例\u0026#39;, \u0026#39;代码\u0026#39;) 示例_代码 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_int input :2 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_str input :秋草 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_list input :[\u0026#39;城下\u0026#39;, \u0026#39;秋草\u0026#39;] PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_dict input :{\u0026#39;name\u0026#39;: \u0026#39;秋草\u0026#39;} PASSED-----some teardown actions!! ========================================= 8 passed in 0.27s ========================================== 最后，当设置为session时，也就是运行pytest的一次执行会话，才会触发一次fixture调用\n所以可以看到，我们通过fixture的不同scope定义，可以根据需要，来确定我们编写的fixture夹具的作用范围。有很好的灵活性\n复杂fixture的scope灵活定义 有时在实际使用的时候，特别是我们的一些fixture初始化工作比较复杂但同时在不同作用范围下都可能会用到，这时如果仅仅因为针对不同的作用范围，就要编写多个不同的fixture，代码就显得比较冗余。这时可以怎么处理呢？ 其实可以利用上下文contextmanager来灵活实现\n比如我们再编写一个fixture的基本代码上下文:\n1 2 3 4 5 @contextmanager def fixture_base(): print(\u0026#39;~~~~~base fixture setup actions.....\u0026#39;) yield print(\u0026#39;~~~~~base fixture teardown actions!!\u0026#39;) 然后针对不同的fixture，我们就可以根据不同的scope来定义不同的fixture并调用这里的context实现。 比如我们再定义一个scope为package的fixture\n1 2 3 4 5 6 7 @pytest.fixture(autouse=False, scope=\u0026#39;package\u0026#39;) def fixture_module(): \u0026#34;\u0026#34;\u0026#34; 对于复杂的fixture但希望灵活处理scope，可以将公共代码放到一个contextmanager中， 再针对不同scope定义相关对应fixture \u0026#34;\u0026#34;\u0026#34; with fixture_base() as result: yield result 👍👍这个方法来自pytest的社区总结，原始问题链接\n不同scope的执行顺序 上面例子中我们其实看到package和session的执行效果，因为测试方法都在同一个package中，所以效果上没什么差异。但其实不同scope也是有执行顺序的\n顺序总结如下：\nsession \u0026gt; package \u0026gt; module \u0026gt; class \u0026gt; function\n这里增加到两个fixture以后，执行的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 (.venv) C:\\Chengxiaqiucao pytest ======================================== test session starts ========================================= collected 8 items BlogDemo/testDemo/test_ch_parm.py::test_params_mark[10] -----some setup actions..... ~~~~~base fixture setup actions..... input :10 100 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[城下秋草] input :城下秋草 城下秋草城下秋草城下秋草 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[软件测试] input :软件测试 软件测试软件测试软件测试 PASSED BlogDemo/testDemo/test_ch_parm.py::test_params_mark[param3] input :(\u0026#39;示例\u0026#39;, \u0026#39;代码\u0026#39;) 示例_代码 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_int input :2 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope1::test_str input :秋草 PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_list input :[\u0026#39;城下\u0026#39;, \u0026#39;秋草\u0026#39;] PASSED BlogDemo/testDemo/test_fixture_scope.py::TestFixtureScope2::test_dict input :{\u0026#39;name\u0026#39;: \u0026#39;秋草\u0026#39;} PASSED~~~~~base fixture teardown actions!! -----some teardown actions!! ========================================= 8 passed in 0.27s ========================================== 可以看到 session 比 package 更早执行，同时更晚被销毁。\n那么以上就是关于pytest scope作用范围的总结\n推广下我的测试课程，感兴趣的小伙伴可以通过以下链接了解下哦\n❤️❤️❤️❤️ 城下秋草的测试职业进阶提升课 ❤️❤️❤️❤️\n","date":"2024-08-28T20:33:52+08:00","permalink":"https://chengxiaqiucao.github.io/post/018-pytest%E4%B8%ADfixture%E7%9A%84%E8%8C%83%E5%9B%B4/","title":"Pytest中fixture的范围"},{"content":"我们知道，Pytest是Python技术栈下进行自动化测试的主流测试框架。支持灵活的测试发现、执行策略，强大的Fixture夹具和丰富的插件支持。\n除了通过pytest的parametrize标签进行参数化外，我们通过fixture的param参数也可以比较方便地实现参数化测试的功能\nfixture参数化实现 假设我们有如下一段待测代码，根据传入参数的不同类型得到不同的输出\n1 2 3 4 5 6 7 8 9 def deal_params(p): if type(p) is int: return p*10 if type(p) is str: return f\u0026#34;输入了:{p}\u0026#34; if type(p) in (tuple, list): return \u0026#34;_\u0026#34;.join(p) else: raise TypeError 然后我们编写对应的测试代码，首先定义fixture，设定params参数列表， 再通过fixture本身的request获取param. 比如这里定义几个参数。当然此外我们还定义了fixture的前置和后置动作。测试方法就是调用被测函数执行。\n1 2 3 4 5 6 @pytest.fixture(params=[10, \u0026#34;城下秋草\u0026#34;, \u0026#34;软件测试\u0026#34;, (\u0026#34;示例\u0026#34;, \u0026#34;代码\u0026#34;)]) def fix_env(request): yield request.param def test_params(fix_env): print(deal_params(fix_env)) 运行得到如下输出： 可以看到，虽然参数化成功运行，但这里有个问题，就是输出的结果中，用例ID这里，显示的是乱码. 根据pytest的ID生成规则，如果是字符或数字，会显示传入的参数本身（当然也可以利用ids参数重新指定参数的对应ID），如果是元组、列表或字典，则会显示fixture的name+参数序号，比如这里的fix_env3\n那这里的字符是中文，显示成了unicode转义前的编码，所以还是中文转换有问题。也就是Pytest对于fixture参数的处理，默认会使用Ascii编码来进行显示，而对于中文，我们是希望用unicode编码显示。\n中文乱码解决方案一 所以，这里解决这个问题的第一个方法是可以利用Pytest的fixture集中配置文件conftest.py， 在其中利用Pytest的hook机制，修改用例收集方法中生成用例ID的部分. 对应代码：\n用例文件的同级conftest.py中定义：\n1 2 3 4 5 def pytest_collection_modifyitems(items): # item表示收集到的测试用例，对他进行重新编码处理 for item in items: item.name = item.name.encode(\u0026#34;utf-8\u0026#34;).decode(\u0026#34;unicode-escape\u0026#34;) item._nodeid = item._nodeid.encode(\u0026#34;utf-8\u0026#34;).decode(\u0026#34;unicode-escape\u0026#34;) 再次执行，可以看到已经正常显示了中文 中文乱码解决方案二 除了通过修改hook来对用例ID进行重新编码处理外，其实Pytest本身也提供了一个配置参数。只是这个配置并不是官方推荐的解决方法。在某些操作系统上的特定情形下，使用这个配置，可能会导致一些异常bug。但笔者在windows和Ubuntu上测试是没有问题的。\n这里对应的配置是：\n1 disable_test_id_escaping_and_forfeit_all_rights_to_community_support = True 从这个超长的配置名称也可以看出，就是禁用testID的转义但同时放弃了社区支持 😂😂\n在pytest.ini中加上这个配置，不使用上面hook的话，也能得到中文正常显示的效果。\n以上就是关于Pytest中参数化中文显示时，可能遇到的乱码问题的解决方案。\n我的测试职业进阶提升课程正在慕课网火热推广中，感兴趣的小伙伴可以以下链接了解下哦\n❤️❤️❤️❤️ 城下秋草的测试职业进阶提升课 ❤️❤️❤️❤️\n","date":"2024-08-24T00:11:46+08:00","image":"https://chengxiaqiucao.github.io/post/016-pytest%E5%8F%82%E6%95%B0%E5%8C%96%E6%97%B6%E7%9A%84%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/Pasted-20240824_hu_631ee5f64e0aad51.png","permalink":"https://chengxiaqiucao.github.io/post/016-pytest%E5%8F%82%E6%95%B0%E5%8C%96%E6%97%B6%E7%9A%84%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","title":"Pytest使用Fixture进行参数化及中文乱码问题"},{"content":"Windows11 右键恢复传统菜单 win11相比以前的版本进行了很多界面上的优化，不过有一个优化带来了不小的困扰，就是它的右键菜单，会默认折叠掉一些非系统的菜单项，必须多点击一步 显示更多选项 才能看到原来默认一些其他菜单项。\n这里其实有两个方法恢复传统方式：\n在点击菜单时，同时按下shift键，这时就会直接打开被折叠的菜单 （推荐） 另一种方式，彻底恢复的话，可以添加一个注册表项 1 \u0026gt; reg.exe add \u0026#34;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\u0026#34; /f /ve 执行后需要重启下资源管理器\n1 taskkill /f /im explorer.exe \u0026amp; start explorer.exe 这样就会彻底将右键菜单恢复成传统样式了。如果想恢复，删除改注册表项即可。\n剪贴板历史小工具 Win11下有一个很好用的小工具，可以记录多次剪贴板的历史记录。通过 win+v键可以呼出这个工具。\n除了可以方便地记录多次拷贝的历史记录，这个小工具还提供了插入emoji表情、颜文字、常用特殊字符以及gif图搜索等功能。\n❤️👍😎🏠🕍❄️ (●ˇ∀ˇ●)(❤️´艸｀❤️)◀▶◯◻\n要关闭剪贴板历史记录。可以去到 系统设置\u0026gt;系统\u0026gt;剪贴板 中关闭\n","date":"2024-08-22T15:40:10+08:00","permalink":"https://chengxiaqiucao.github.io/post/010-windows-system-tips/","title":"Win11操作小技巧二则"},{"content":" 虽然一直有码字，记录的习惯，但文章都比较零散。所以还是打算做一个自己的静态博客。之前一直知道Github是可以通过Github_Page直接发布一个github.io域名的静态页面的。然后目前我常用的写作工具是Obsidian，所以诉求就是可以通过Obsidian写完文章以后，可以做到比较方便地发布到github。\n于是便动手，经过两天多的摸索，总算比较满意地把这个博客搭了起来。这里记录下实现的过程，以便后续参考。\n效果图： Hugo静态页面框架 什么是hugo？ Hugo是一个用go语言编写的静态网站生成框架。具备性能好、快速易用、可配置的特点。可以依据MarkDown格式的文档，快速生成一个完全基于Html的网站。是一个生成博客站点的利器。\n安装 Hugo支持多种安装方式。 我是在windows系统上进行安装, 可以利用winget包管理器直接安装\n1 \u0026gt; winget install Hugo.Hugo.Extended 安装后，检查版本信息 完成安装以后，可以通过 hugo 命令来生成我们的博客站点\n1 \u0026gt; hugo new site BlogSite 会自动生成一个我们网站的结构\n-archetypes\n-assets\n-content\n-data\n-i18n\n-layouts\n-static\n-themes\n-hugo.toml\ncontent目录其实就是存放我们当前文章。theme中则存放网站可以应用的主题。assets中其实可以包含一些需要引用的资源。layout是网站后续渲染的结构\narchetypes中是可以定义页面的一些默认元数据信息(frontMatter), 一般放在default.md中， Hugo会根据这个配置在生成新的页面时自动添加这些元数据。并在渲染时根据配置生成页面\n我这里配置如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- title: \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; date: {{ .Date }} imageNameKey: Pasted draft: true Categories: tags: --- 而正式生成md文档后，比如当前这篇文章，在Obsidian中反映出来就是文档属性信息： Stack主题 生成网站后，我们可以从hugo官网丰富的模板中，选择一个中意的。这里我使用的是Stack主题。 从github上将theme clone到生成网站的Theme目录下\ngit clone https://github.com/CaiJimmy/hugo-theme-stack themes/stack 然后参照它的官方示例，在content目录下包含page、post目录以及主页index.md文件\n具体的配置信息需要参考Stack示例站点下的hugo.yaml进行设置，主要是站点各种样式组织上的配置信息，这里不再赘述。\n创建文章 因为我们创建文章时，经常需要引用一些图片，为了便于直接在文档中按相对路径引用. 创建文章，可以使用下面的方式，也就是不直接生成页面，而是生成文章目录，并在目录中使用index.md的方式创建\n1 \u0026gt; hugo new post/hugo+github搭建博客小记/index.md 在index.md中完成文章内容的编写\n生成示例站点 完成站点配置和必要的素材、文章编写后，可以执行下面的命令进行本地预览\n1 \u0026gt; Hugo Server --theme=stack --buildDrafts buildDrafts是会将有draft=true标记的文章一起渲染\n执行以后，显示如下信息： 这时就可以从http://localhost:1313 来预览当前的页面状态了\n没有问题后，可以使用正式生成站点的命令\n1 \u0026gt; hugo --theme=stack --baseURL=\u0026#34;https://chengxiaqiucao.github.io/\u0026#34; 这样就会在站点的public目录下生成我们需要的静态站点内容了 发布到Github Page github 仓库 完成本地调试后，要将我们的网站发布到Github上。首先当然是要有一个自己的Github账号。 然后创建一个自己账号的页面repo. 如chengxiaqiucao.github.io\n1 2 3 4 5 6 \u0026gt; cd public \u0026gt; git init \u0026gt; git remote add origin \u0026#34;https://github.com/chengxiaqiucao/chengxiaqiucao.github.io.git\u0026#34; \u0026gt; git add -A \u0026gt; git commit -m \u0026#34;first commit\u0026#34; \u0026gt; git push -u origin main 通过以上命令，就将pulic中的站点内容push到了github的页面仓库中了\n仓库配置 然后要发布这个页面的话，github上进行如下配置： 这样每次push新的内容到仓库中，就会触发构建。\n现在访问一下https://chengxiaqiucao.github.io/, 可以看到成果了\nObsidian设置 然后，我们用Obsidian写文章时，为了方便贴图，需要配置下图片附件的存放位置 另外这里还有一个坑，就是Obsidian在贴图时，会自动生成一个文件名，形如pasted image XXXXXX.png\n但这里有个问题，就是这个文件名中存在空格，会导致Stack主题无法解析，图片显示不出来。这里推荐大家可以使用一个Obsidian插件，paste image rename 可以自己设置贴图文件格式。 好啦，到这里我们就建好了一个属于自己的博客空间啦，可以快乐地码字了~~~\n","date":"2024-08-21T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/009-hugo+github-setup-blog/","title":"Hugo+Github搭建博客小记"},{"content":"如今最火热的技术莫非OpenAI的ChatGPT莫属，AI技术也在很多方面得到广泛应用。今天我们来聊的TestGPT就是一个软件测试领域当红的应用。\nTestGPT是什么？ TestGPT是一家总部位于以色列特拉维夫的初创公司 CodiumAI Ltd.，发布的一款用于测试领域的人工智能模型（AI model），由 OpenAI 的 GPT-4 大型语言模型驱动。\n官网地址： www.codium.ai\n从官网的介绍可以看出，它是一个旨在协助开发人员测试他们的代码，为开发人员提供自动生成的软件测试套件建议，从而加快编码和错误扫描的AI工具。\n如何使用？ 目前TestGPT提供了针对VsCode和JetBrains的插件支持 以VsCode为例，在vsCode的插件中心搜索CodiumAI即可安装\n安装后可以Github账户直接登录连接。\n下面我们来用一段有问题的python排序算法代码来看看它是如何使用的。\n1 2 3 4 5 6 7 8 9 10 11 12 def insert_sort(lists): # 插入排序 count = len(lists) for i in range(0, count): #range区间有误，这里是bug，应为(1, count) key = lists[i] j = i - 1 while j \u0026gt;= 0: if lists[j] \u0026gt; key: lists[j + 1] = lists[j] lists[j] = key j -= 1 return lists 切换到CodiumAI插件，连接后可以看到代码部分已经有了生成测试的入口\n尝试生成下看看效果，稍等片刻，就可以看到AI的成果了\nAI的辅助界面有三部分，分别是：\nTest Suite 测试用例 Code Analysis 代码分析 Code Suggestions 代码修改建议 在用例配置部分可以做测试的基本配置\nCoverage部分则可以看到AI生成的Case覆盖情况\nTest部分则是具体的测试用例，本例中生成了6条用例\n执行后可以看到用例的执行结果，但生成的测试代码都执行成功了，似乎没有通过测试代码测试出bug :(\nCode Analysis则给出了代码的分析说明，可以\n代码建议部分则给出了修改建议，这里倒是准确地指出了代码中的问题。\n按照建议直接应用，可以看到代码已经修改并加了注释\n总结 所以可以看到TestGPT还是非常优秀的，准确地分析出了代码的作用并发现了代码中有问题的地方。也帮助设计了测试用例覆盖及相关单元测试脚本。 善用这个工具已经无疑可以给开发工程师提供非常大的辅助，但是从初步的使用来看，自行生成的测试用例对于问题代码的覆盖还有不足，短期内应该还不足以代替测试设计。\n","date":"2023-10-21T00:00:00Z","image":"https://chengxiaqiucao.github.io/post/006-ai-testing-by-testgpt/20230626_203935_hu_71c167ed5a897e85.png","permalink":"https://chengxiaqiucao.github.io/post/006-ai-testing-by-testgpt/","title":"AI测试之TestGPT"},{"content":"前言 作为测试工程师最重要的工作产出，Bug Report（或者故障单、问题单）是测试工程师工作成果的直接体现，也是最能呈现测试工程师价值和能力的输出物。但项目干系人甚至测试工程师本身对Bug Report的重要性往往认识不足，Bug 单的内容及其提交方式、处理流程对项目推进、运作效率甚至团队士气都有重要影响。\n行业针对 Bug Report 的讨论和总结还比较少，本篇我们希望以笔者多年的从业观察出发，对 Bug report 的要素及专业测试工程师的处理方式给出一些总结和建议，意在抛砖引玉，错漏之处还请多多指正。\n主要包含以下内容：\nBug 是什么，Bug 报告单是什么 开发或项目团队看到 Bug 实际希望获取的信息是什么 测试小白在提 Bug 时的常见错误做法 提 Bug 与说故事 专业测试工程师如何高质量地提交 Bug 何为Bug？ Bug的历史 Bug 一词在英文中本是虫子，臭虫之意，现在 IT 行业用它来代指软件中存在的缺陷，其实这个历史还比较有意思：\n早在 1878 年，大发明家爱迪生就在给朋友的信中就用 bug 一词代指过电子电路中的故障（或可能导致故障的原因），但是真正在计算机行业载入史册还要到 1947 年 9 月 9 日。\n这时第一批写程序的程序员们正在哈佛大学研发 markII 计算机，其中 [Grace Murray Hopper][1] 在查找一个问题时，在中继器触点旁发现了一个飞蛾，用日志本拍死了它，并标记它为“第一个找到 bug 的真实案例”。由此 bug 一词便被用来代指计算机中的缺陷或故障。相应地 debug 则被用来指代去除故障的调测行为。\n下图即保存在美国管家博物馆的史上第一个 bug 实物： 史上第一批程序员，其中唯一的女性就是“虫”母： 总之，现在 Bug 一词可以代指软件或程序中存在的缺陷或者故障。但对于项目团队来说，建议不要简单地将 Bug 定义成故障，因为故障一词定性上有否定的意味，而将 Bug 视作缺陷、或者问题，强调可改进空间对项目团队更加有积极的引导作用。\nBug Report （问题单）是什么? report 这个词在英文中既可作动词也可作名词。所以 Bug report 既可表示发现问题并报告的这个动作，也可以指问题发现后提交的报告内容。 这里我们一般还是将它看作是问题报告(名词)，即 问题单，那么问题单到底是什么呢？\n测试大神 Cem Kaner 曾指出:\nThe purpose of testing is not to find bugs. The purpose is to get bugs fixed.\n测试的目的不是发现 Bug, 而是使 Bug 被修复。\n这个观点其实指出了很多测试人员认识上的一个误区，就是觉得测试工作就是尽可能多地发现 Bug。 其实对团队来说，发现的 Bug 再多，最终还是要解决掉才能体现这些 Bug 被发现的价值。\n而从发现到被解决， 问题单 是其中的主要媒介，既是测试人员测试工作的输出，又是开发人员解决问题的输入，重要性不言而喻。\n另外，虽然将发现的问题知会给开发人员有各种形式：口头告知、实际演示、电子邮件、IM聊天等等都可以起到知会的作用。但在现代软件研发过程中，一般还会有专门的系统来进行缺陷追踪，如 JIRA、禅道、bugfree、QC（HP quality center） 等软件都能进行缺陷的提交和跟踪。通过这些专门的系统，不仅能够起到记录和反馈的作用，还能够通过统计和分析更好地反映出项目整体的质量状况和研发进展。\n因此：\n问题单 是测试人员测试活动中发现缺陷后的输出\n问题单 是开发人员解决缺陷的输入\n问题单 是测试人员和开发人员之间针对 Bug 的沟通媒介\n问题单 还是项目团队评估当前研发状态和产品成熟度的指示器。\n问题单的作用和重要性 相信很多测试工程师在提交问题单后，都有得到如下一些反馈或抱怨的经历：\n你这个问题单到底想说明啥？\n在我这里运行没有这个问题\n为什么你提交的这个算是缺陷？\n一般人不会像问题单那样使用软件，脑子有问题的人才会那样用\n这个确实是问题，但是修复成本太大，而且也可以换种操作方式来规避\n你虽然认为这是个问题，但是实际用户不会觉得不好\n你提交的虽然确实是问题，但是影响用户很小。那些影响用户更大的部分为什么看不到多少问题单？\n\u0026hellip;\u0026hellip;\n测试人员当然不希望得到这样的反馈。但这些问题也从侧面反映出在对待 Bug 这件事上，开发人员或项目团队更加注重的其实是 Bug 如何解决（包括是否需要解决的判断），他们更希望从问题单中获知的是如下的一些信息：\n所发现的什么问题？\n问题现象是什么？ 总是会出现吗？ 发现这个问题时的背景、上下文是什么？ 除了看到的现象，系统同时还发生了什么？ 有没有截图、日志、录屏？ 为什么它是个问题？\n这个问题有什么影响？ 不解决它会怎么样？ 发生概率怎么样？ 有没有和其他问题重复？ 是做了什么操作，暴露出的这个问题？\n输入是什么？ 用了什么测试路径？测试数据？ 所在测试环境、软件版本如何？ 所以，作为测试，不应把问题单看作是一个简单的问题记录，它是测试和开发之间的重要沟通媒介，好的问题单可以极大减少双方的沟通成本，既极大减轻开发人员解决问题的工作量，同时也减少测试人员澄清、重复验证等的工作量。对项目来说，问题单的提交质量，影响的就是团队的生产力以及交付速度，不容小觑。\n问题单的要素 了解了问题单的作用，那么问题单中应该包含的要素也就比较清楚了，一般有以下方面：\n方便初步判断的标题\n标题应该能够比较清楚地概要说明问题，以及这个问题所处的模块。便于开发人员作一个初步的判断\n上下文及必要的关联信息\n发生问题时的上下文背景，关联的信息如软件版本、测试环境、配置情况、资源状态等\n准确合理的详细描述信息\n详细描述问题发现的步骤，操作预期，实际发生的状况。问题发生频率，所使用的测试输入、数据、文件等\n帮助问题解决的补充信息\n能够帮助开发人员加快解决问题进度的补充信息，比如截图、录屏、操作日志、系统日志等\n帮助项目决策的辅助信息\n测试人员作为 Bug 的第一判断者，应给出问题的严重程度、解决优先级建议。初步指派解决问题的开发人员，以及便于统计、追踪的关联信息标识。\n测试小白的错误做法 那么结合问题单的要素，我们可以初步总结一些测试小白或者不专业测试在提交 Bug 时常见的一些错误做法：\n标题不够明确\n标题非常简单，不便于初步判断问题。比如简单地写 “系统 crash”，太过笼统，而且过于简单的标题很容易产生雷同，对问题的集中回顾、评审都带来很多不便。\n或者过于复杂。太长的标题，容易导致阅读疲劳，没有重点。比如标题中详细描写操作步骤就没什么必要\n脱离实际，偏离需求场景。\n有时候测试小白会从个人偏好角度出发，想当然地提出一些问题。“我觉得”、“感觉上不好” 是这类小白问题中出现的高频词汇。\n不是问题\n测试小白，往往因为对系统实现原理理解上的错误或技能水平上的不足，提交出不是 bug 的问题单。\n还有因为测试小白的测试方法或者环境配置本身就是不正确的，由此导致的问题\n描述信息不足\n典型的，通过问题单的描述信息，开发人员不足以确认问题现象或自行复现。测试小白往往觉得发现问题就完成工作，没有把充分的信息提供给开发人员，比如截图、日志等。\n无关信息过多、格式杂乱\n有时小白的问题单中会包含太多冗余的嘈杂信息，很难看到重点。比如不分青红皂白把几万行的 log 贴到问题单中\n或者完全不进行排版，一大堆信息杂乱地混杂在一起，阅读难度极高\n问题过多\n问题单应该聚焦，有时测试小白会在同一个问题单中包含很多个不同的问题。这对于问题追踪和聚焦都非常不利\n只看现象不考虑本质\n有时候简单的问题现象，往往是一些严重问题的体现或线索。小白往往会忽视重要的风险，对一些看似蛛丝马迹的问题视而不见，将潜藏在现象之下的 Bug 轻易漏过。比如有些预期外的提示信息，往往是后台计算、统计准确性等 Bug 的体现。\n提 Bug 与说故事 再回到 提交 Bug 这件事，本质上，这其实是一个沟通的过程，问题单 承载了这个沟通媒介的作用，通过问题单，测试人员将自己在测试过程中看到的、发现到的问题描述出来，开发人员通过阅读问题单，掌握到对应信息并相应地去解决问题。\n所以提 Bug 其实和写一个小短文，说一个小故事一样，测试人员是作者，而开发人员是读者。\n我们在提问题单时，其实也是写作的一种。写作的 5W 要求也一样适用：\nWhat 内容\u0026ndash;具体的问题是什么？\nWhy 目的\u0026ndash;为什么要提出这个问题？为什么它是个问题？\nWho 主体-问题主体是谁？关联方有谁？？\nWhere 地点\u0026ndash;问题发生在哪？\nWhen 时间\u0026ndash;在什么时间和频率下发生？\n提 Bug 时思考这 5W，再结合上文提到问题单要素，一般就不会犯很多测试新手在提问题单时常犯的错误了。\n提 Bug 的艺术 上文阐述问题单的要素以及 提Bug 时应注意的一些细节，但是为什么我们还要说提 Bug 其实是一件艺术性的工作？\n我们来举几个问题单的例子：\n假设有一个商品管理系统，用户在某个特定商品分类下（水果）新增商品时会发生crash\n问题单 例一：\n1 2 3 用户新增商品，发生Crash 如图所示（crash界面截图） 这个问题单通过提供截图其实基本描述了问题现象。但是对开发人员来说，信息量太少，而且很有可能并不能第一时间复现问题（水果分类）。问题单中包含的信息太过于简单，可以说是非常糟糕的问题单案例。\n问题单 例二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 用户在新增商品时，会发生Crash 操作步骤： 1. 打开App 2. 用户登录系统，输入正确的用户名、密码并登录 3. 进入商品管理页面 4. 选择分类：水果 5. 点击新建商品按钮 6. 输入商品信息：********* 7. 点击提交按钮 预期结果：商品创建成功App 实际结果：发生 crash 使用的设备机型：xiaomi 8 操作系统版本：android 8.0 软件版本 V1.1 附件：crash截图 这个问题单，是很多测试小白常见的提单形式，包含了非常详细的操作步骤和相关辅助信息。但是这也是一个非常糟糕的问题单。 首先，这样的步骤描述毫无必要，开发人员不会连打开app、登录、提交这样的操作也不了解需要在问题单中交代 其次，辅助信息虽多，但是基本和问题原因无关，并不利于开发人员定位，反而引入了一些干扰信息。 这样的问题单，无法体现测试人员的专业价值，对问题的快速解决也没有好处\n问题单 例三：\n1 2 3 4 5 6 7 8 9 用户在水果分类下进行新增商品操作时，会发生Crash 操作步骤： 1. 选择水果分类，创建商品，发生crash 2. 选择非水果分类，创建商品，商品创建成功 已验证机型：xiaomi 8，huawei mate 7 等现象一致，应和机型、操作系统、版本无关 附件：错误截图、系统 crash 时的 logcat 日志 影响：用户无法新增水果分类商品，直接影戏用户使用。需高优先级解决 此问题单已经可以算比较合格的问题单了，比较明确地指明了问题发生的场景，并将一些无关信息进行了初步排除。开发人员可以聚焦在水果这个类别下的商品创建进行问题分析。 同时指出了问题对软件的影响和解决优先级建议，使项目团队明确知道这个问题的影响所在\n问题单 例四：\n1 2 3 4 5 6 7 8 9 10 11 12 用户在水果分类下进行新增商品操作时，会发生空指针Crash 操作步骤： 1. 选择水果分类，创建商品，发生crash 2. 选择非水果分类，创建商品，商品创建成功 3. 对已有水果分类下的商品进行编辑操作，可以编辑成功 后台数据库对水果分类因字段缺失insert操作出错，update操作正常。 已验证机型：xiaomi 8，huawei mate 7 等现象一致，应和机型、操作系统、版本无关 附件：错误截图、系统 crash 时的 logcat 日志 影响：用户无法新增水果分类商品，直接影戏用户使用。需高优先级解决 这个问题单，则在上一个问题单基础上更进一步，初步分析出了问题原因，新增操作时，有一个关键字段信息未包含，所以导致的crash。开发人员已经可以很明确地对问题进行修复了\n问题单 例五：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 用户在水果分类下进行新增商品操作时，会发生空指针Crash。导入商品操作旧模板也同样存在问题。 操作步骤： 1. 选择水果分类，创建商品，发生crash 2. 选择非水果分类，创建商品，商品创建成功 3. 对已有水果分类下的商品进行编辑操作，可以编辑成功 后台数据库对水果分类因字段缺失insert操作出错，update操作正常。 在商品管理导入商品功能中，新模板水果商品导入成功，使用旧模板（未包含新增字段）导入水果数据，也会发生失败。需一并修复。 已验证机型：xiaomi 8，huawei mate 7 等现象一致，应和机型、操作系统、版本无关 附件：错误截图、系统 crash 时的 logcat 日志、新旧模板导入日志 影响：用户无法新增水果分类商品，直接影戏用户使用。需高优先级解决 这个问题单，则在上一个例子的基础上，根据测试人员的经验，推理出有类似逻辑的导入功能，可能存在同样问题并进行了验证。很好体现了测试人员专业能力。\n通过以上这个简单的案例，我们可以看到，不同的问题单提法，对问题解决效果却有很大差距。\n包含的信息太少，开发人员难以确定产生 Bug 的根本原因，Debug 的工作量成倍上升。\n包含的信息过多，开发人员又会耗费额外的精力去分析那些冗余的信息，甚至干扰调试、解决的方向，同样造成很大的工作量浪费\n越是能清晰、明确地反映问题的根本原因，开发人员解决问题就越是高效。\n测试人员的经验和判断推理能力，通过问题单能够很好地得到体现\n所以为什么说提 Bug 是个艺术性的工作？问题单既不能太过简单，也不应太过冗杂，还要能够将信息尽可能准确、全面地传递给开发，这真的是一件非常艺术性的事情。\n结语 总而言之，提 Bug 在软件研发过程中，是一件相当重要的活动，问题单的质量直接影响团队的效率和产出。作为专业的测试人员，掌握提 Bug 的艺术，问题单不在是个简单的问题记录，更是测试和开发间的沟通桥梁，是帮助开发高效修复 Bug 的支撑。\n欢迎大家关注评论，也可关注公众号： 秋草说测试\n","date":"2023-08-19T00:00:00Z","permalink":"https://chengxiaqiucao.github.io/post/005-the-bugs-report-art/","title":"提 Bug 的艺术"},{"content":"前言 在之前的系列 中，我们从基础功能、脚本进阶和自动化实现几个方面向大家详细介绍了 Postman 工具在接口测试中使用的具体方法。而我们在工作中，除了这些通过本地工具实施的测试外，因为不同办公场所或团队协作的需要，还存在通过云端来统一管理接口用例以及依托云端来实现更多增值测试能力的需求。在本篇 Chat 中，我们就来学习 Postman 官方提供的 Cloud 高级功能服务。\nPostman cloud 服务介绍 使用 Postman Cloud 服务，首先我们需要注册一个官方的账号\n注册完成并登录以后，从官网主页面右上角的 dashboard 按钮即可进入 Cloud 云端管理页面。这里会显示自己的工作空间，除了自己的个人工作空间外，还可以创建用于团队共享的团队工作空间。\n工作空间及云端功能总览 工作空间是 Postman Cloud 的一个管理单元，通过云端的工作空间同步，我们可以达到以下本地端无法实现的的一些优势：\n可以便于个人工作通过不同的地点和设备进行组织、管理。比如在工作单位未完成的工作，回到家里也可以继续\n便于团队合作，通过将相关元数据共享以及团队工作空间，团队成员之间可以共同维护同一套接口，并共享工作成果。\n统一的工作空间，还使得团队能工作在同一维度下，避免不同团队成员工作进度、数据的不一致导致的理解和沟通差异。\n工作空间的历史记录功能，能帮助记录和回溯接口操作记录，便于保存工作过程和结果。\n下图是 Cloud 端进入工作空间后的界面，可以看到 Postman Cloud 云端能够提供的功能。默认显示当前空间中的 Collection 信息，其他的 Tab 页分别是接口操作历史、环境变量、监控任务、Mock 服务、API 集成能力、以及云空间相关的操作记录。\n如下是 History 接口操作记录以及 Activity 工作空间操作记录：\n账号体系及对应价格 在 Postman 官网注册账号后默认是免费账户，也可以升级到专业版或者企业版，目前对应的每月费用分别如下：\n免费版本包含的功能如下，可以看到功能基本都支持，区别主要在使用次数上的区别，免费账户的在线文档调阅、 Mock 请求、API 调用、监控调用等都限制在每月 1000 次，还是能基本满足个人学习和基本的测试需要的。如果是比较大型的团队共用，最好还是升级到高级版本或选择其他替代方案。\n本地端登录 在 Postman 工具端，我们也可以登录已注册的账号，登录后上方的 banner 即可显示登录后所在默认工作空间以及账户头像。\n登录后，本地 App 端会和云端保存的信息自动进行同步，保持数据的一致性。下面我们就分别来看看 Postman cloud 提供的服务。\nPostman Cloud 的在线接口文档 功能强大、格式优美的在线文档是 Postman Cloud 的一个重要服务。它具备如下一些主要的优点：\n支持私有文档及公开文档 当注册 Postman 账号后，默认其实已经开启了在线文档功能。登录 web 端工作空间后，点击 Collection 进入后，即可看到当前 Collection 的在线文档已同步生成。如图：\n上图是只有当前账号可以在工作空间中查看的私有文档。通过右上角的 Share 按钮还可以向其他工作空间或团队工作空间共享当前的文档。 而通过 Publish 按钮则可以将当前文档发布为公共文档让用户公开访问。\n在Postman App 端，也可以使用 Collection 菜单中的 Publish Docs 按钮来进行公开文档的发布。发布后会生成一个公共的访问 URL，通过这个 URL 即可访问到这个文档。\n文档自动生成 如上文所述，Postman 在线文档是自动生成的，省去了原来繁冗的文档编辑排版工作。它能够自动生成如下内容：\n请求示例，包括请求方法、uri、消息内容、消息头、参数等 保存为 Example 的接口响应信息 Collection、Folder、Request 上编写的 Description 描述。 自动化生成的多种主流语言的代码片段 如下图是 Collection 的描述信息编辑界面 支持 Markdown 语法 我们在编写 Description 时，是支持使用 Markdown 语法的，能进一步提升文档的阅读体验。如上面的图片就包含了 Markdown 中列表以及加粗的语法。\n支持基于 ID 的文档内链接 我们还可以利用 Postman 为每一个请求、folder 生成的唯一 ID 在文档内进行交叉引用。当我们点击右侧文档右侧导航栏对应元素，URL 中即可显示该元素的唯一 ID，如图：\n注：ID 信息我们也可以通过 Postman API 接口获取到。\n支持自动生成主流语言代码片段 Postman 在线文档另一个非常赞的特性是支持多种主流语言的代码片段，方便我们在使用相应语言进行代码调试时使用。如图： 支持评论功能 在团队空间等私有文档中，我们还可以使用评论功能，通过对接口进行标注来和团队成员进行沟通和进行信息的确认。\nPostman 在线文档使用限制 Postman Cloud 会限制私有文档和公开文档的被浏览次数。免费账号会分别有每月 1000 次的免费浏览限额。对于个人使用和学习还是勉强够用。如果是团队协作使用肯定是捉襟见肘，建议还是选择付费账号或者 Swagger 这样的开源免费替代方案。\n当前使用量可以在个人账号的 Resource Usage 页面查看：\nPostman 的 Mock Server 介绍 Postman Cloud 的另一个高级功能是提供了 Mock Server 的支持。\n在接口开发以及接口测试工作中，特别是多个团队并行研发的软件产品，比如前端、后端、APP 这些不同的团队共同来开发产品，经常出现的情况就是很多时候需要依赖其他团队的开发进度，比如 APP 要依赖后端接口来进行调试，或者依赖一些第三方团队提供的接口。如果接口还不具备联调条件，那么为了保证开发进度，按照一定的约定，进行接口的模拟就成为必然选择。\nMock Server 就是提供这种服务的功能模块。在 Postman 中，我们可以将一些响应保存为Example，然后就可以根据这些 example 来方便地创建 Mock 服务脱离原始接口进行消息的响应模拟。\n如图是 Postman App 中保存的一个响应 Example，针对同一个接口请求，我们可以将不同的响应结果保存对为多个不同的 example。\n创建 Mock Server 在 Postman 中创建 Mock Server 有如下几种方式：\nPostman App 中通过 New 按钮创建 在打开 Postman App 时自动弹出的 launch window 中也可创建 在 Collection 菜单中创建 通过 Postman API 创建 这里以通过 Collection 菜单创建为例，选中 Mock Collection:\n根据 Collection 信息设置 Mock Server： 创建成功，会生成一个在线的 Mock Servr 的访问 URL，本例中即 https://b0fadee4-7560-4b14-a201-599985ce4f0f.mock.pstmn.io\n如此我们就完成了当前 Collection 的 Mock 服务创建。这里 Postman 会默认生成一个和当前 Collection 同名的 Environment 环境，在这个环境中默认添加了 url 变量，取值即刚才的 Mock 服务地址。\nMock Server 的使用 完成 Mock 服务的创建以后，我们就可以通过之前生成的 Mock 服务地址来模拟接口的响应了。如图就是访问 Mock 服务已保存的接口，返回的是之前保存的响应 Example 内容。\nMock Server 的匹配算法 看到这里，大家一定会产生一个疑问，Mock Server 是如何根据请求来确定需要响应的内容的？特别是针对同一个请求，我们保存了多个 Example 的情况，模拟的时候响应的是哪一个呢？ 这就要向大家来介绍一下 Mock Server 的响应匹配算法了。\n如下图，是 Mock Server 用来进行响应匹配的算法顺序\n首先会根据需要响应的内容格式来筛选响应，比如是 json 格式还是 xml 格式 （根据请求的格式定义）\n会根据请求的 HTTP 方法来匹配，会剔除不匹配请求 HTTP 方法的响应\n根据请求的URL路径来匹配。优先匹配严格一致的路径，然后再匹配多层的带 / 的路径，再然后匹配忽略大小写以及 id 信息的路径，如果都没有匹配的情况下则返回没有找到对应的响应。\n可以通过在请求消息头中携带指定 header 值来确认响应消息。 Postman 支持在消息头中携带 x-mock-response-name、 x-mock-response-id、 x-mock-response-code ,分别可以指定响应的名称（保存的 example 名称）、响应 Example 的 ID（唯一 ID，可通过 API 查询得到）、响应状态码。\n在剩余的响应中按保存顺序倒序排列，选择最高阈值的进行响应。\n如图是创建 Repo 的 Mock 服务，存在多个响应的 Example。 这里匹配了请求方法和请求路径： 下图则是在请求中包含了指定的 Header，x-mock-response-code， 指定返回状态码为 422 的响应。 可以看到，通过 Postman 的 Mock Server 服务，我们可以在脱离原接口环境的情况下，模拟接口的响应，来完成我们业务调测的需要。 目前免费账号每月通过 Mock Server 提供的调用次数限额为 1000 次\nPostman 的监控功能 下面再介绍 Postman Cloud 提供的监控服务。\n对于互联网应用，我们的业务是否能够正确的提供服务，是否会因为服务异常或者网络问题导致业务中断？\n在和外部团队协作的过程中，如果对方的接口出现变化，我们如何能够及时地获知避免大量的无用功？\n因为这些问题的存在，自然对接口进行监控的重要性就显而易见了。Postman 对于接口的监控功能，其实简单来说就是在 Cloud 端提供的一个接口测试任务的定时执行并记录、通知结果的功能。大家也许会说，通过 Jenkins 这样的 CI 集成工具定时调度不是也可以吗？\n确实通过 CI 调度也能达到这样的效果，但是通过 Cloud 监控，还可以提供不同访问区域的选择以及针对监控结果的趋势可视化呈现分析等增值能力。\n如下图是在 Postman App 的 Collection 菜单中选择新建监控：\n下图是在 Postman web 工作空间中创建监控：\n下图是创建好的监控以及监控结果界面：\n除了通过在 App 和 在 Cloud web 端创建监控外，我们还可以通过 Postman API 来创建监控。\n另外需要跟大家说明的是，Postman 的监控功能有以下几个限制需要了解：\n因为是在云端进行执行的监控，所以监控对象接口需要可以通过互联网访问，对于在内网开发的接口，需要暴露公网访问接口。\nPostman 目前没有文件存储功能，所以不支持在接口请求中附加文件。\n同上，也不支持使用 data file 提供 data 变量。\n接口的执行记录不会记录请求和响应的消息体。\n目前免费账号的 monitor 接口执行次数限额为每月 1000 次。\nPostman 的开放 API 我们除了通过Postman App 以及 cloud 端的 web 界面来进行 Collection、Environment、Mock Server、Monitor 等的创建和管理外，Postman Cloud 也提供了自身的 API 接口，方便使用者从自研的工具或脚本中来调用，更加方便地对 Postman 提供的相关服务进行调度和管理。\nPostman 的 API 是通过云端的 Integration 来提供的。（对于专业版以上的账号，还可使用其他一些集成的第三方工具）\n获取鉴权码 要使用 Postman API，首先需要需要生成调用的鉴权码。从上图界面进入，选择 Get API Key：\n生成以后，可以在 Existing API Keys 中查看当前的 Key 值：\nPostman API 对于鉴权码的使用， 有两种方式：\n是通过在请求消息的 header 中 增加一个 X-Api-Key 的消息头来携带这个 key 值进行鉴权\n通过在请求 url 中携带查询参数 apikey 来携带，如：\n1 https://api.getpostman.com/collections?apikey={{postman_api_key}} 如果不携带鉴权码，则接口会返回如下报错：\n1 2 3 4 5 6 { \u0026#34;error\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;AuthenticationError\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Invalid API Key. Every request requires a valid API Key to be sent.\u0026#34; } } 访问频率限制 和大部分 Restful API 服务类似， 为防止 DDOS 攻击，Postman API 对于接口的访问频次也进行了限制，每分钟访问不超过 60 次，在响应消息中可以通过 X-RateLimit-Limit 、X-RateLimit-Remaining\t、X-RateLimit-Reset 等几个自定义消息头来获知此限制以及剩余次数、重置时间。如下面获取所有 Collection 的接口：\n调用实例 下面再来看几个 Postman API 的调用实例：\n获取 Collection 信息 在上一张频率限制的图片上，我们访问的获取当前账号下所有 Collection 的接口，响应如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \u0026#34;collections\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;7ea4592c-848a-4a76-a4e4-5b1b0d0594f7\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;PostmanAPI\u0026#34;, \u0026#34;owner\u0026#34;: \u0026#34;4793508\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;4793508-7ea4592c-848a-4a76-a4e4-5b1b0d0594f7\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;d6c64129-8c6c-48ec-968c-7f01a70a601b\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Postman Echo\u0026#34;, \u0026#34;owner\u0026#34;: \u0026#34;4793508\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;4793508-d6c64129-8c6c-48ec-968c-7f01a70a601b\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;f2777cee-5d92-4a0d-896e-e00ad27ef5bd\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;GitHub\u0026#34;, \u0026#34;owner\u0026#34;: \u0026#34;4793508\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;4793508-f2777cee-5d92-4a0d-896e-e00ad27ef5bd\u0026#34; } ] } 通过给定相关接口的 id，我们就可以获取单个 Collection 的详细信息，对应的接口：\n1 https://api.getpostman.com/collections/{{collectionID}} 比如这里可以利用 Postman 的 Pre-Script，先获取到指定名称如 PostmanAPI 的 Collection 的 id，再将 id 赋值给环境变量 {{collectionID}}, 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 pm.sendRequest(\u0026#39;https://api.getpostman.com/collections?apikey=\u0026#39;+pm.environment.get(\u0026#34;postman_api_key\u0026#34;), function (err, res) { if (err) { console.log(err); } else { var collections = res.json().collections for(let i=0;i\u0026lt;collections.length;i++){ if(collections[i].name == \u0026#34;PostmanAPI\u0026#34;){ pm.environment.set(\u0026#34;collectionID\u0026#34;, collections[i].id); } } } }); 如图 获取 Environment 信息 类似的，我们也可以这样来获取单个的 environment 信息：\npre-Script 代码如下；\n1 2 3 4 5 6 7 8 9 10 11 12 pm.sendRequest(\u0026#39;https://api.getpostman.com/environments?apikey=\u0026#39;+pm.environment.get(\u0026#34;postman_api_key\u0026#34;), function (err, res) { if (err) { console.log(err); } else { var environments = res.json().environments for(let i=0;i\u0026lt;environments.length;i++){ if(environments[i].name == \u0026#34;PostAPI\u0026#34;){ pm.environment.set(\u0026#34;envID\u0026#34;, environments[i].id); } } } }); 调用截图：\n运行指定 monitor 我们也可以通过接口来立刻执行指定的 Monitor,接口返回执行结果如图：\n除了上面的几个例子，关于Postman API 支持的详细接口说明可以参见 官方接口说明文档，同样，目前针对免费账号的接口调用次数限制也是 1000 次。\n结语 以上就是对 Postman Cloud 提供的高级功能的介绍。可以看到，通过 Postman Cloud 我们可以借助云端的服务资源完成一些本地 App 不易实现的增值功能，更加方便在团队内进行共享和协作，增强便利性的同时加速我们接口开发或测试进度。Postman 的免费版对于这些增值的服务也是完全支持的，但使用额度上会有一定限制。而这些增值服务，我们其实也可以通过一些开源工具来自行实现，后续有机会再向大家分享。\n本系列关于 Postman 工具的系统介绍到此就结束了。欢迎大家在读者圈或者加入微信群继续共同交流测试技术、分享行业动态，共同成长！\n","date":"2022-08-27T00:00:00Z","image":"https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png","permalink":"https://chengxiaqiucao.github.io/post/004-postman-advanced/","title":"Postman高级篇"},{"content":"前言 在前两篇 Chat《玩转Postman：基础篇》《玩转Postman：进阶篇》中，我们介绍了 Postman 作为一款专业接口测试工具在接口测试中的主要用法以及它强大的变量、脚本功能，给测试工作人员完成接口的手工测试带来了极大的便利。其实在自动化测试上，Postman 也能进行良好的支持。本篇我们就一起来了解如何利用 Postman 进行接口自动化测试。\n自动化测试概述 在继续本篇内容前，我们还是首先温习一下和自动化测试相关的一些基本概念。 百度百科中给出的定义：\n自动化测试就是将人为驱动的测试行为转化为通过机器来执行的一种过程。\n人为驱动的测试行为，从广义上理解可以包含从测试需求分析到测试设计、测试执行以及测试总结的全过程，而狭义的理解一般就是将测试设计通过测试代码来体现并通过代码的执行来自动地完成测试的执行并输出执行结果。 现在我们谈到自动化测试，更多还是在狭义层面，通过自动化测试来提升测试执行效率，通过快速得到测试用例的执行结果来尽快得到被测产品状态，更多是起到质量指示器的作用。\n在《玩转Postman：基础篇》中我们介绍了经典的自动化测试金字塔：\n这里根据不同测试类型对软件测试进行了分层：\n底层是针对的代码层面的单元测试。 中间层是 service 服务测试，现代软件的应用服务基本都是以接口 API 形式来体现，服务测试也可以理解就是接口 API 测试。 上层则是针对用户界面的测试。 这个模型体现在自动化测试中，表示越底层的自动化测试所占比重应该越大，这样才有更好的投入产出比。而中间这一层的 Service 测试它既不像 UI 层那样维护成本巨大，很难跟得上快速迭代的要求，同时它又比单元测试更能在业务逻辑上进行质量验证。所以现在一般认为 API 测试是自动化测试实施上的优先选择。\n借助一些自动化测试工具或者自动化测试框架的帮助，我们可以在测试执行的用例组织、执行策略、测试数据管理、结果报告等方面更加方便地进行自动化测试的实施。下面我们就来看看 Postman 在自动化测试上提供的支持。\nPostman的批量执行工具 Runner Runner 是 Postman 中用于批量执行接口用例的模块，我们可以通过 Runner 模块来完成已编写接口用例的自动化测试执行。\nRunner 功能介绍 在 Postman 主界面左上角，点击 Runner 按钮，即可打开 Runner 模块界面。如下图\n相关设置的作用如图上标注。选中待执行的 Collection 或 Folder 后，点击运行按钮，会开启如下运行页面，并显示执行结果。相关界面元素含义如图上标注\n接口的测试数据驱动 Postman 通过 引入 data 变量来支持 Runner 运行时的测试数据加载和数据驱动。在上一篇 Chat《玩转Postman：进阶篇》中，我们简单介绍了 data 变量的使用方法。这里我们再结合一个 GitHub API 的例子回顾一下：\n数据文件中给出一组 Repositories 的信息（测试数据），我们运行一个和这组数据相关的接口：获取 repo、获取 repo 的 contributor、获取 repo 的 tag、获取 repo 的 topic，并分别进行相关校验\nPostman 支持两种外部数据类型，json 格式或者 txt/csv 格式。这里我们假设将 repositories 数据以 json 格式保存在数据文件中，给出如下一些主流的开源自动化测试框架\n1 2 3 4 5 6 7 8 9 10 11 12 13 [{ \u0026#34;owner\u0026#34;: \u0026#34;junit-team\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;junit5\u0026#34; }, { \u0026#34;owner\u0026#34;: \u0026#34;robotframework\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;robotframework\u0026#34; },{ \u0026#34;owner\u0026#34;: \u0026#34;appium\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;appium\u0026#34; },{ \u0026#34;owner\u0026#34;: \u0026#34;SeleniumHQ\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;selenium\u0026#34; }] 在 Test 脚本中编写校验，在上一讲中我们提到一个技巧，对于重复使用的脚本我们可以把它们保存到 global 变量中，需要时执行这个变量内容即可。本例中我们需要执行的几个接口，都会用到是否正确返回成功响应的校验。 所以可以设置一个 global 变量 checkOK。变量值即需要执行的校验脚本\n不同的接口中均包含了相应 repo 信息作为路径参数，然后我们再添加对应的校验\n获取 repo 接口 /repos/:owner/:repo\n1 2 3 4 5 6 7 8 9 10 11 eval(pm.globals.get(\u0026#34;checkOK\u0026#34;)); //判断是否存在 stargazers_count 字段 pm.test(\u0026#34;存在 Star 数据\u0026#34;,function(){ pm.response.to.have.jsonBody(\u0026#34;stargazers_count\u0026#34;) //获取 star 数量 let star = pm.response.json().stargazers_count // 将Star数显示到Test Result中，并判断是否 超过 1000 Star pm.test(\u0026#34;当前repo【\u0026#34;+ pm.variables.get(\u0026#34;repo\u0026#34;) +\u0026#34;】star数【\u0026#34;+ star +\u0026#34;】超 1000\u0026#34;,function(){ pm.expect(star).to.gt(1000) }) }) 获取 Contributor 接口（因接口默认返回数量为 30， 这里用 per_page 参数指定每页返回数量 100） /repos/:owner/:repo/contributors?per_page=100\n1 2 3 4 5 6 7 8 9 10 11 eval(pm.globals.get(\u0026#34;checkOK\u0026#34;)); //遍历当前返回数组长度 var contributor=0; for(var c in pm.response.json()){ contributor++; } //判断贡献者是否超过5人 pm.test(\u0026#34;贡献者数量【\u0026#34; + contributor + \u0026#34;】超过 5 人\u0026#34;,function(){ pm.expect(contributor).to.gt(5) }) 获取 Tag 接口（因接口默认返回数量为 30， 这里用 per_page 参数指定每页返回数量 100） /repos/:owner/:repo/tags?per_page=100\n1 2 3 4 5 6 7 8 9 10 11 eval(pm.globals.get(\u0026#34;checkOK\u0026#34;)); //遍历当前返回数组长度 var tag=0; for(var c in pm.response.json()){ tag++; } //判断标签是否超过5个 pm.test(\u0026#34;tag数量【\u0026#34; + tag + \u0026#34;】超过 5 个\u0026#34;,function(){ pm.expect(tag).to.gt(5) }) 获取 Topic 接口 /repos/:owner/:repo/topics\n1 2 3 4 5 6 eval(pm.globals.get(\u0026#34;checkOK\u0026#34;)); //判断返回Topic names，并显示到Test Result pm.test(\u0026#34;当前repo【\u0026#34;+ pm.variables.get(\u0026#34;repo\u0026#34;) +\u0026#34;】Topic：\u0026#34; + pm.response.json().names,function(){ pm.response.to.have.jsonBody(\u0026#34;names\u0026#34;) }) 在 Postman 中设置 Runner 配置并运行\n结果如图：\n从结果中我们可以看到，所有定义在 GithubRepos.json 这个文件中的 Repo 信息均按照上述流程进行了正确的执行。\n接口的流程控制 除了这样按顺序的执行，在我们的实际测试工作中，很多情况下还会希望根据接口测试的执行结果来决定后续执行的测试用例，这就是接口的流程控制功能。Postman 的 Runner 模块也可以支持这种流程控制，它是借助 Postman 的脚本封装方法 postman.setNextRequest()来实现的。\n比如上面介绍的数据迭代过程，在获取 repo 后，如果成功响应，我们继续执行 GetTag 接口，否则退出。 我们修改 GetRepo 这个接口的 Test 脚本如下：\n1 2 3 4 5 if(pm.response.code == 200){ postman.setNextRequest(\u0026#34;GetTag\u0026#34;) }else{ postman.setNextRequest(null) } 再修改测试数据，给出一个不存在的 Repo 信息模拟匹配不到返回错误的情况\n1 2 3 4 5 6 7 [{ \u0026#34;owner\u0026#34;: \u0026#34;junit-team\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;junit5\u0026#34; }, { \u0026#34;owner\u0026#34;: \u0026#34;chengxiaqiucao\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;errorRepo\u0026#34; }] 再次重新执行，我们可以看到：\nGetRepo这个接口，返回正常时，跳转到 GetTag 这个接口执行，这里跳过了按正常顺序应该执行的 GetContritutor;\n而当执行到错误的 Repo, 得到 404 Not Found 响应，此时 Runner 中断了执行\n执行结果如图：\n注意：\n无论 postman.setNextRequest() 方法在脚本的什么位置，它总是在脚本的最后执行跳转操作\npostman.setNextRequest() 方法有自己的作用域，当选择 collection 执行时，所选择的 request需要在当前collection中，当选择 Folder 执行时，所选的 request 需要在当前 folder中\n命令行自动化工具 NewMan Newman 是 Postman 官方提供的专门用于自动化测试执行的命令行工具，使 Postman 具备了支持自动化测试扩展以及和第三方系统集成调度的能力。\nNewMan 的安装 因为 Newman 基于 Node.js，所以首先要保证机器上具备 Node.js 环境，此处不再另外介绍 Node.js 的安装。 Node 环境具备的话，运行如下命令能正确显示版本号即可\n1 2 c:\\\u0026gt;node --version v6.9.0 安装 Newman 使用如下命令：\n1 \u0026gt; npm i newman -g 安装完成后检查版本，能正确显示即安装成功\n1 2 c:\\\u0026gt;newman -v 4.3.1 NewMan 功能介绍 Newman 命令行工具的主要命令是 newman run，命令格式如下\n1 \u0026gt; run [options] \u0026lt;collection\u0026gt; 这里的 Collection 可以是从 Postman 中导出的 Collection 文件，也可以是通过 Postman 账号 share 出来的在线 Collection URL 地址。\nCollection 从 Postman 中导出方法如下：\n此时会提示选择版本，建议选择推荐的Collection 2.1 版本。导出后会保存为一个 json 文件。\n下面介绍几个 newman 运行时常用的参数：\n-e, \u0026ndash;environment \u0026lt;path\u0026gt; 指定 environment 环境变量，这里环境变量需要导出为文件( json 格式)\n-g, \u0026ndash;globals \u0026lt;path\u0026gt; 指定 global 环境变量，这里环境变量需要导出为文件( json 格式)\n-d, \u0026ndash;iteration-data \u0026lt;path\u0026gt; 指定运行 Collection 时使用的 data file 文件\n-n, \u0026ndash;iteration-count \u0026lt;n\u0026gt; 指定 Collection run 时的迭代次数 n\n-r, \u0026ndash;reporters [reporters] 指定运行完成后的结果报告类型，除默认命令行格式 cli外, 还支持 json, junit, progress 以及 emojitrain几种类型。\n如下是 newman 运行上文 Runner 中的 Collection 的输出示例：\n除了 newman 默认支持的几种报告格式， 我们还可以安装一个 html 格式的报告插件，安装命令如下：\n1 \u0026gt; npm install -g newman-reporter-html 如上例中的 newman 执行命令，此时带上 \u0026ndash;reporter html 参数，即可在当前目录的 newman 目录下生成一个 html 格式的报告\n1 \u0026gt;newman run GitHub.postman_collection.json -e GitChat.postman_environment.json --reporters html 报告形如：\n我们还可以在这个命令基础上增加--reporter-html-export 参数指定生成的 html 文件路径，命令如下：\n1 \u0026gt;newman run GitHub.postman_collection.json -e GitChat.postman_environment.json --reporters html --reporter-html-export c:\\newman\\result.html 这样我们就可以在指定目录下得到输出的 HTML 结果报告了。\n和持续集成工具 Jenkins 的集成 Jenkins 是目前最为流行的持续集成工具，在研发流程，特别是现今推崇 DevOps 的研发环境下，通过 Jenkins 将自动化测试纳入持续集成管道是其中的一项核心实践。下面我们就来具体看下如何结合 Jenkins 和 Newman 工具来完成持续集成中自动化测试任务的创建和调度执行。\nJenkins 的安装 首先还是看下如何安装 Jenkins。企业中一般由研发配置或支撑部门来维护 Jenkins。这里我们以 window 版本为例看下安装过程\n首先来到 Jenkins 的官网 https://jenkins.io/ ，进入 download界面，选择长期支持版本，根据操作系统类型选择对应安装包，这里选择 windows 版本 完成下载后的到一个 zip 文件，解压后执行 msi 安装文件，一路默认安装即可 安装完成后，我们可以来到 windows 系统的服务管理器中，可以看到已经自动创建了一个名为 Jenkins 的服务，会随系统自动运行，我们也可以根据需要改成手动。 此时访问 http://localhost:8080，会等待 Jenkins 完成系统部署和初始化 初始化完成，会要求输入初始密码，可以根据提示从初始密码文件中获取 输入密码后需要进行插件的安装，一般选择推荐配置即可 选择插件后，等待相关插件下载并完成安装 完成后设置用户名和账号 继续下一步，设置访问 URL 和端口，此处使用默认地址 重启服务后再访问 Jenkins 服务地址，登录后进入主界面，至此安装完成。 Jenkins 配置 Newman 执行自动化 进入 Jenkins 主页后，我们选择新建 Job，这里选择构建自由风格项目，创建一个新的持续集成任务\n点击 OK 后会进入配置页面，来到 Build 配置，选择执行Windows批处理命令, 如果是部署在其他操作系统如 Linux 系统，可以相应的选择执行shell\n输入前面我们执行自动化的 newman 命令，注意，因为 Jenkins 调度会从 Jenkins 工作空间目录执行，所以这里指定的 Collection 和 environment 文件需要给出绝对路径\n保存后即完成了一个最基本的自动化测试执行 Job 的创建。此时点击右侧的立即构建可立刻触发任务的执行\n点击构建编号(此处为 #1)，进入构建详情，通过打开右侧Console Output可以查看具体执行的控制台输出\nTips 1： 在本例中，我们可以看到出现了newman 不是内部或外部命令的错误，这是因为 NewMan 安装后，默认是将执行路径添加在当前用户的 Path 用户环境变量下，而通过 Jenkins 执行，没有路径访问权限，所以我们需要将 Newman 所在 npm 目录添加到系统环境变量 Path 中。如图\n修改变量后，通过 http://127.0.0.1:8080/restart 地址重启 Jenkins 使变量生效，再次执行构建：\n可以看到已经成功调度了自动化测试任务，但是控制台输出中存在乱码。如果你也出现这个问题，可按以下方法解决\nTips 2: 此处乱码是因为 Jenkins 使用的 jvm 环境未设置语言支持。我们同样方法添加如下 windows 系统环境变量，设置后重启 Jenkins 服务，再次执行即可正常看到执行结果了\nJAVA_TOOL_OPTIONS = -Dfile.encoding=UTF8\n生成测试报告 要在 Jenkins 中展示测试报告，首先我们要生成测试报告。根据上面 NewMan 执行参数的介绍，可以添加相关报告参数--reporters junit,html --reporter-html-export .\\newman\\result.html来生成。这里同时生成 junit 和 html 两种格式的报告到当前工作目录的 newman 目录下。完整命令如下\nnewman run c:\\GitHub.postman_collection.json -e c:\\GitChat.postman_environment.json \u0026ndash;reporters junit,html \u0026ndash;reporter-html-export .\\newman\\result.html\n而要在 Jenkins 中展示 HTML 报告，我们需要添加一个展示插件， 来到 Jenkins \u0026gt; 系统管理 \u0026gt; 插件管理 界面下，在 Availble 中查询并安装 HTML Publisher插件\n重启 Jenkins 后，我们就可以添加相关报告展示配置了。还是来到 Newman_Test这个任务下，配置Post-build Actions,分别添加 Junit 结果报告和 HTML 报告，如下图：\n完成报告配置后，我们再运行几次任务，这是在任务界面上就可以看到相关测试结果的报告链接以及执行趋势了（执行趋势为 Junit 报告产生）\n如图是 JUnit 报告: 如图是 HTML 报告； 配置任务定时执行 在持续集成中，自动化测试的自动触发是非常重要的，这是在任务配置的 Build Triggers 中进行配置的，如图是配置定时触发的方法。这里的触发计划符合 Linux Crontab 的语法。具体语法可以参照 Jenkins 给出的语法帮助\n自动发送测试结果邮件 同样，在持续集成中，及时将测试结果通知到相关人员非常重要。这里需要安装 Jenkins 的邮件通知扩展插件：Email Extension Plugin，同样参照上文插件安装的方法在插件管理界面中完成安装。\n要使用邮件通知，需要接收邮箱支持 smtp 服务。以 QQ 邮箱为例，在邮箱账号的设置界面中，开启 SMTP 服务，并生成对应的授权码\n回到 Jenkins，安装完插件以后，需要对插件进行配置。来到系统管理 \u0026gt; 系统设置中，首先设置管理员邮箱地址。\n在 Extend E-Mail Notification 配置中，如图进行配置，注意点开高级后，这里的用户密码是在 QQ 邮箱中生成的授权码\n同样 E-mail Notification 配置中进行类似配置。\n完成系统配置后，来到任务配置界面。在配置的最后添加 Post build Action，选择 Editable Email Notification，参见如图进行设置。\n保存后，触发构建。可以从 console output 中看到邮件是否有成功发送。发送后进入邮箱即可看到已经收到了对应的结果通知邮件。\n附件：结果邮件模板 附上这里使用的邮件模板文件，邮件模板中可以使用 Jenkins 的一些默认变量，如：项目名称 $PROJECT_NAME， 构建编号 $BUILD_NUMBER，构建状态 $BUILD_STATUS 等，大家可以参照模板内容对照看一下，也可以参考 Jenkins 官方给出的一些说明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;body\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;h2 style=\u0026#34;color: #5e9ca0; text-align: center;\u0026#34;\u0026gt;本邮件是 NewMan 自动化测试邮件，请勿回复！！！\u0026lt;/h2\u0026gt; \u0026lt;table class=\u0026#34;editorDemoTable\u0026#34; style=\u0026#34;height: 273px;\u0026#34; width=\u0026#34;430\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;background-color: #3498db; text-align: center;\u0026#34; colspan=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;span style=\u0026#34;color: #000000;\u0026#34;\u0026gt;NewMan 自动化测试执行报告\u0026lt;/span\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;项目名称：\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;$PROJECT_NAME\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;构建编号：\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;$BUILD_NUMBER\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;构建状态：\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;$BUILD_STATUS\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;触发原因：\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;${CAUSE}\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;构建日志地址：\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #00ccff;\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026lt;a style=\u0026#34;color: #00ccff;\u0026#34; title=\u0026#34;构建日志\u0026#34; href=\u0026#34;${BUILD_URL}console\u0026#34;\u0026gt;${BUILD_URL}console\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;构建地址：\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #00ccff;\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026lt;a style=\u0026#34;color: #00ccff;\u0026#34; title=\u0026#34;构建地址\u0026#34; href=\u0026#34;$BUILD_URL\u0026#34;\u0026gt;$BUILD_URL\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;测试报告地址：\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #00ccff;\u0026#34;\u0026gt;\u0026lt;a style=\u0026#34;color: #00ccff;\u0026#34; title=\u0026#34;NewMan测试报告地址\u0026#34; href=\u0026#34;${BUILD_URL}HTML_20Report/\u0026#34;\u0026gt;${BUILD_URL}HTML_20Report/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #808000;\u0026#34;\u0026gt;Junit测试结果地址：\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td nowrap=\u0026#34;nowrap\u0026#34; style=\u0026#34;border-color: gray;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: #00ccff;\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026lt;a style=\u0026#34;color: #00ccff;\u0026#34; title=\u0026#34;测试结果地址\u0026#34; href=\u0026#34;${BUILD_URL}testReport/\u0026#34;\u0026gt;${BUILD_URL}testReport/\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; 结语及预告 以上就是本篇 Postman 自动化测试相关内容的介绍，再简单总结下，在本篇 Chat 中，我们学习了：\n通过外部数据文件结合 Runner 模块完成数据驱动的自动化测试执行 通过 Postman 的内建方法 postman.setNextRequest() 来控制接口的流程走向 命令行工具 Newman 的安装和使用实例 持续集成工具 Jenkins 的安装配置以及如何与 newman 结合完成自动化测试脚本的触发，以及结果报告生成和通过邮件模板进行邮件通知。 通过本系列这三篇介绍，我们学习了 Postman 作为一个本地运行的接口测试工具的详细使用方法。但我们还知道使用 Postman 前还注册了一个官网账号，这个账号其实就关联了 Postman 的云端服务。而 Postman Cloud 向用户提供了很多高级增值功能，目前普通注册用户也能在一定限额下免费使用，完全可满足一般的测试、学习需要。在下一篇中我们就和大家再一起来学习 Postman 提供的云端增值高级功能。主要有：\nPostman 的在线文档功能 Postman 的 Mock 服务 Postman 的监控服务 Postman 的开放 API PS：欢迎大家到读者圈中共同讨论，携手进步。\n","date":"2022-07-18T00:00:00Z","image":"https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png","permalink":"https://chengxiaqiucao.github.io/post/003-postman-automation/","title":"Postman自动化篇"},{"content":"前言 在上一篇 《玩转Postman：基础篇》中，我们介绍了 Postman 工具的主要功能和一些基本用法。 其实 Postman 作为目前使用最为广泛的接口测试工具，除了能提供交互良好的 UI 界面以及完成基本的http协议的鉴权、header、body 等的设置以及请求提交和响应解析这些基本功能外，它还提供了非常丰富的测试辅助能力。本篇我们就来为大家详细介绍 postman 的脚本进阶功能。\nPostman的变量 在接口测试工具中，变量对于接口消息的重用和灵活匹配意义重大，作为一个专业的接口测试工具，对变量的支持是必须具备的。\n而 Postman 就提供了丰富的变量支持，在 Postman 中定义了5种不同作用范围的变量类型，在变量的使用和管理上更加地灵活和有针对性。下图是官方给出的不同类型变量的作用范围\n从外向内作用域逐渐变小，同时生效优先级越高，也就是当存在同一变量名时，内层变量类型的变量会优先生效。下面我们结合实例来具体说明一下这些变量类型的作用范围：\nglobal 变量 global 变量即全局变量，是作用范围最大的一种变量类型。设置好 global 变量后，可以在 Postman 工具中所有可以使用变量的地方生效。\n下面在 Postman 工具中看一下 global 变量的设置： 在工具右上角打开环境管理界面： 选择 global 变量管理： 添加 Global 变量： 此例中，我们设置一个 global 变量 name，取值为 1。 在 Postman 中，使用双花括号表示变量，形如 {{ variable }}。以 Github API 为例，比如我们获取用户名为变量 name 取值的用户信息。\nhttps://api.github.com/users/{{name}}\nurl中输入双花括号后会自动联想出我们需要的变量类型。\n发送请求后，检查 Postman 响应区，可以看到我们获取了 username 为 1 的用户信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 { \u0026#34;login\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;id\u0026#34;: 1825798, \u0026#34;node_id\u0026#34;: \u0026#34;MDQ6VXNlcjE4MjU3OTg=\u0026#34;, \u0026#34;avatar_url\u0026#34;: \u0026#34;https://avatars2.githubusercontent.com/u/1825798?v=4\u0026#34;, \u0026#34;gravatar_id\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://api.github.com/users/1\u0026#34;, \u0026#34;html_url\u0026#34;: \u0026#34;https://github.com/1\u0026#34;, \u0026#34;followers_url\u0026#34;: \u0026#34;https://api.github.com/users/1/followers\u0026#34;, \u0026#34;following_url\u0026#34;: \u0026#34;https://api.github.com/users/1/following{/other_user}\u0026#34;, \u0026#34;gists_url\u0026#34;: \u0026#34;https://api.github.com/users/1/gists{/gist_id}\u0026#34;, \u0026#34;starred_url\u0026#34;: \u0026#34;https://api.github.com/users/1/starred{/owner}{/repo}\u0026#34;, \u0026#34;subscriptions_url\u0026#34;: \u0026#34;https://api.github.com/users/1/subscriptions\u0026#34;, \u0026#34;organizations_url\u0026#34;: \u0026#34;https://api.github.com/users/1/orgs\u0026#34;, \u0026#34;repos_url\u0026#34;: \u0026#34;https://api.github.com/users/1/repos\u0026#34;, \u0026#34;events_url\u0026#34;: \u0026#34;https://api.github.com/users/1/events{/privacy}\u0026#34;, \u0026#34;received_events_url\u0026#34;: \u0026#34;https://api.github.com/users/1/received_events\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;User\u0026#34;, \u0026#34;site_admin\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Michael\u0026#34;, \u0026#34;company\u0026#34;: null, \u0026#34;blog\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;San Francisco, CA\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;mbalaban1989@gmail.com\u0026#34;, \u0026#34;hireable\u0026#34;: null, \u0026#34;bio\u0026#34;: null, \u0026#34;public_repos\u0026#34;: 3, \u0026#34;public_gists\u0026#34;: 0, \u0026#34;followers\u0026#34;: 15, \u0026#34;following\u0026#34;: 0, \u0026#34;created_at\u0026#34;: \u0026#34;2012-06-07T06:10:07Z\u0026#34;, \u0026#34;updated_at\u0026#34;: \u0026#34;2019-01-17T08:29:21Z\u0026#34; } Collection 与 Collection 变量 再来看另一个变量类型 Collection 变量。首先了解下 Collection 的概念。Collection 是 Postman 中组织接口的一个集合单位，Postman 中也主要以 Collection 为配置存储的一个基本单位。我们可以把 Collection 看作软件测试中测试用例集的概念。\nCollection 变量就是作用域在 Collection 上的变量类型，这种变量只会在设置变量的 Collection 上生效。 设置方法：选择 Edit Collection 在 variable 页中添加 Collection 变量，本例中我们在 Github 这个 Collection 添加一个同样命名为name 的变量 将上例中获取用户的接口保存到 Github 这个 Collection 中（我们可以在 Collection 下再创建一层子目录，注意目录是不支持设置目录级别的变量的，Collection 变量在子目录下的接口依然会生效），我们再提交一下这个接口 此时可以看到，我们设置的 Collection 变量已经生效，获取到的是 name 为 2 的用户信息。注意此时我们还设置了一个 name 为 1 的 global 变量，可以看到 Collection 变量的优先级高于 global变量。\n环境和 environment 变量 环境是 Postman 中的一个非常有用的概念。做过软件测试的同学都了解，我们在实际工作中会接触到不同的软件环境。对应于我们被测试系统的不同运行场景。比如一般互联网企业在研发中会存在以下的一些不同环境：\n开发环境 集成环境（联调环境） 系统测试环境 试生产环境 生产环境 性能测试环境 安全测试环境 不同的环境在接入途径、网络拓扑、访问权限以及硬件配置上往往都有较大区别。Postman 中引入 Environment 这个概念，通过 Environment 变量来管理一组环境配置，便于我们来方便地在不同环境间进行切换。\n在环境管理界面中，可以添加环境，以及该环境对应的相关变量。本例我们添加一个 GitChat 环境，并且设置一个 name = 3 的环境变量。 设置完环境后，我们再刚才的获取用户接口界面上，选择对应的 GitChat 环境，再重新提交请求。可以看到环境变量已经生效，获取了name为 3 的用户信息，同样可以看到，此时环境变量的优先级比 Collection 又要更高。 data 变量 另一种 Postman 中的变量类型是 data 变量，data 变量只能在 Postman Runner 中使用，也就是会在 Runner 运行时才生效，data 变量可以提供多组测试数据供接口测试时调用，为 Postman 提供接口批量数据验证能力。要使用 data 变量，打开 Postman Runner， 如下图，选择 data 变量定义文件加载 data 变量文件。\ndata 变量支持json或者txt/csv数据格式，json 定义格式如下，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [ { \u0026#34;id\u0026#34;:\u0026#34;11\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;user1\u0026#34; }, { \u0026#34;id\u0026#34;:\u0026#34;12\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;user2\u0026#34; }, { \u0026#34;id\u0026#34;:\u0026#34;13\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;user3\u0026#34; } ] txt/csv 格式如下：\n1 2 3 4 id,name 11,user1 12,user2 13,user3 在 runner 界面上可以通过 preview 查看运行时不同迭代所加载的变量取值，如下：\n如本例，点击 Run variables 会执行 3 次不同的迭代，通过 Postman Console查看运行日志，可以看到每次均使用了 data 变量中定义的对应变量值。 同样，虽然我们选择 environment，但可以看到 data 变量在 runner 运行时优先级更高。\nlocal 变量 Local 变量在 Postman 官方文档中并没有给出明确的定义。一般可以理解成 Postman 脚本中支持的 JS 变量，它的作用域只会在脚本中生效， 此时 Postman 界面引用的 {{variable}} 并不会取到 local 变量值。 脚本中直接引用的变量名会取local变量，其他数据类型则通过 Postman 对应的取值语句来获取。\n比如我们在 Pre-Request 中定义以下脚本并执行： 在 Console 中查看结果如下，可以比较清楚地看到每次执行在预执行脚本中不同变量的当前取值 通过以上实例，我们可以看到，Postman 针对不同的接口作用范围支持了丰富的变量类型，使我们在应用变量功能的时候可以更加的灵活\nPostman 脚本及其执行顺序 除了支持丰富的变量功能，Postman 还支持强大的脚本功能，测试人员在进行接口测试时，可以通过脚本来动态地对接口测试逻辑进行定制，再结合变量，就可以实现一些复杂的场景。\nPostman 的脚本功能是基于 Node.js 语言，Node.js 成熟的语法和丰富的扩展库给 Postman 提供了巨大的灵活性和强力的扩展能力。\n在 Postman 中，测试脚本 可以在接口发送之前和收到响应之后执行，分别对应 Pre-request Script 和 Test Script，如下图： 比如我们前文介绍变量时的实例，其实就是一个 pre-request 脚本 除了接口本身可以设置 pre-request 和 Test Script，我们在编辑 Collection 和 Collection 下的folder时，可以看到 Collection 和 Folder 也都支持设置 pre-request 和 test 脚本。 那这几种脚本的执行优先级或者说顺序是如何的呢？ 下图就是这几个不同位置脚本的调用执行顺序： 对TestNG 或者 Junit 等测试框架有所了解的同学，应该知道这些测试框架也有类似的运行时概念，也就是 Setup 和 teardown 方法，而且也有 case、class、suite 这样的层次。不过这些不同层次的方法都是成对出现的，即 case 的 setup 和 teardown 在 case 执行前和结束后会执行。 而 Postman 的 Script 执行顺序和这个稍有差别，是按层级顺序排列，而不是成对出现的。大家参照图片注意理解下差异。\n大家也可以自己验证下这个执行顺序，分别在Collection、folder 以及 folder 下的请求中定义相关脚本，如： 执行，查看 console 输出： 可见 Postman 对不同脚本的执行顺序和前文所述一致。\nPostman脚本-PreRequest Pre-request 脚本，顾名思义，其实就是在接口消息发送前，可以进行一些预处理动作，类似于 Junit 或 TestNG 等测试框架中的 Setup 方法。 利用 Pre-Script 脚本，我们就可以在发送接口请求前来完成一些需要动态处理的动作，比如调整变量取值，或者对一些动态参数进行一些特殊处理。\n下面我们就以 GitHub API 中的一个实例来看下 Pre-Script 脚本的主要作用。（关于GitHub API 的一些具体说明，大家可以先看下我在上一篇 Chat 《玩转Postman：基础篇》中的介绍）\nGitHub API 中一个经常使用到的接口是查询接口\n根据 GitHub API 官网的定义说明，查询 repositories 的接口定义如下：\nGET /search/repositories\n其中参数 q 是主要的查询参数，具体定义参见 https://help.github.com/articles/searching-for-repositories/\n比如我们要查询包含在指定日期 2018-11-11 后创建且包含关键字 automation 的 repository 信息。 可知 GitHub 上存在这样的 repo 数量有七千多个。\n在这个例子中，因为查询条件包含一个日期参数，而实际测试工作场景中，很多时候我们希望日期是动态生成的，比如根据当前日期取一年以前作为查询参数值，这时我们就需要对参数进行一些预处理，这就是 Pre-Script 的用武之地了。\n这时我们可以首先设置一个环境变量 created，再在 pre-script 脚本中动态预处理这个日期，来完成日期动态设置的目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 pm.environment.set(\u0026#34;created\u0026#34;,getCreated(new Date(), -1) ); /* 获取\u0026#34;YYYY-MM-DD\u0026#34;格式的日期 第一个入参为日期对象 第二个入参为年份偏移量，负数为向前偏移 */ function getCreated(date, yearOffset) { var seperator1 = \u0026#34;-\u0026#34;; var year = date.getFullYear() + yearOffset; var month = date.getMonth() + 1; var day = date.getDate(); if (month \u0026gt;= 1 \u0026amp;\u0026amp; month \u0026lt;= 9) { month = \u0026#34;0\u0026#34; + month; } if (day \u0026gt;= 0 \u0026amp;\u0026amp; day \u0026lt;= 9) { day = \u0026#34;0\u0026#34; + day; } var currentDate = year + seperator1 + month + seperator1 + day; console.log(currentDate) return currentDate; } 在 Postman中执行如图，获取当前日期一年以来创建的 repositories 信息。 在 Pre-Script中，主要是围绕 Postman 的变量来进行预处理，所以主要使用的就是 Postman 的变量域的一些封装方法。\npm.globals.has(variableName:String) 是否存在某全局变量\npm.globals.get(variableName:String) 获取全局变量\npm.globals.set(variableName:String, variableValue:String) 设置全局变量\npm.globals.unset(variableName:String) 取消当前全局变量设置\npm.globals.clear() 清空全局变量\npm.environment.has(variableName:String) 是否存在某环境变量\npm.environment.get(variableName:String) 获取环境变量\npm.environment.set(variableName:String, variableValue:String) 设置环境变量\npm.environment.unset(variableName:String) 取消当前环境变量设置\npm.environment.clear() 清空环境变量\npm.variables.get(variableName:String) 根据变量名获取变量\npm.sendRequest() 发送请求\nPostman脚本-Test脚本 Postman 的 Test 脚本是 Postman 另一个值得称道的特色功能，在 Test 脚本中，Postman 封装了很多丰富的校验逻辑，并结合 JS 脚本本身语言的灵活性，给测试人员对接口的判断、校验和响应处理带来极大的便利性。\n下面我们重点介绍下 Test 脚本中封装一些主要的校验方法。\n判断接口响应状态码 对接口响应状态码的校验，是接口测试校验的常用手段。关于状态码的详细说明也可参见我的上一篇 Chat 《玩转Postman：基础篇》 ， 下面看一个 Postman 中进行接口校验码校验的代码:\n1 2 3 pm.test(\u0026#34;判断返回成功状态码\u0026#34;,function(){ pm.response.to.have.status(200); }); 或者也可以使用第三方校验库 chaijs 的expect 方法来进行校验。 Chaijs 对常用的校验方式按照行为驱动开发（BDD）的描述方式进行了封装，使校验判断的代码编写方便了很多。\n1 2 3 pm.test(\u0026#34;expect方法判断返回成功\u0026#34;,function(){ pm.expect(pm.response.code).to.equal(200) }); 再或者我们还可以直接使用 Postman 对返回状态码的封装方法来进行判断\n1 2 3 pm.test(\u0026#34;Postman封装方法判断返回成功\u0026#34;,function(){ pm.response.to.be.ok }); Postman 中直接封装了常见的返回状态校验方法：\npm.response.to.be.info 校验 1XX 信息状态码\npm.response.to.be.success 校验 2XX 成功状态码\npm.response.to.be.redirection 校验 3XX 重定向状态码\npm.response.to.be.clientError 校验 4XX 客户端错误状态码\npm.response.to.be.serverError 校验 5XX 服务端错误状态码\npm.response.to.be.error 校验 4XX 或 5XX 错误状态码\npm.response.to.be.ok 检验 200 的 OK 返回\npm.response.to.be.accepted 校验状态码 202 的接受返回\npm.response.to.be.badRequest 校验状态码 400 的请求消息错误\npm.response.to.be.unauthorized 校验状态码 401 的认证错误\npm.response.to.be.forbidden 校验状态码 403 的访问受限\npm.response.to.be.notFound 校验状态码 404 的资源未见错误\npm.response.to.be.rateLimited 校验状态码 429 的访问频次限制错误\n校验响应时间 除了对于返回码的校验，我们还会经常校验的一个响应指标是响应时间。Postman 对于响应时间的校验也非常简单\n1 2 3 pm.test(\u0026#34;响应时间小于1s\u0026#34;, function () { pm.expect(pm.response.responseTime).to.be.below(1000); }); 校验消息内容 对接口返回内容的校验是我们判断业务逻辑正确性与否的必要手段。响应的消息头或者消息体内容我们可以通过 pm.response.header 或者 pm.response.text 、 pm.response.json 来获取。在相应的校验代码中我们就可以根据获取到的内容来进一步判断响应的正确性\n1 2 3 4 5 6 7 8 pm.test(\u0026#34;校验消息头Content-Type\u0026#34;, function () { pm.expect(postman.getResponseHeader(\u0026#34;Content-Type\u0026#34;)).to.include(\u0026#34;application/json\u0026#34;) }); pm.test(\u0026#34;校验消息体返回数量大于1000\u0026#34;, function () { var jsonData = pm.response.json(); pm.expect(jsonData.total_count).to.gt(1000) }); 在 Postman 中执行以上校验，可以在 Response 的 Test Results 中看到校验结果 Postman脚本-接口的关联 在接口测试中，经常出现的一种情况是：我们需要从另一个接口的响应中获取某些值作为当前测试接口的输入来使用。结合 Postman 的 Pre-Script 脚本和 Test 脚本以及变量功能，我们可以方便地完成内容获取和参数传递的场景。\n以下面的场景为例：\n从 Junit5 这个 repo 的接口信息中，获取该 repo 的创建时间，再查询在这个时间之后创建的所有包含 Junit5 字样的 repo 信息，判断 repo 数量是否超过 1000\n方法一：\n设置一个环境变量 created 在获取 repo 接口 GetRepo 的 Test 脚本中获取 Junit5 这个 repo 的创建时间 在 Test 脚本中将获取到的创建时间赋值给环境变量 created 在查询 repo 接口中使用环境变量 created 在查询 repo 接口中添加判断返回数量的校验代码 通过 Runner 执行器按顺序执行这两个接口，完成关联执行 如图： 在 Runner 执行器中执行结果 方法二：\n在方法一中我们利用环境变量来传递参数，这种方法需要依赖 runner 执行器对接口的执行顺序来保证 GetRepo 接口在 SearchRepo 接口之前执行。\n我们也可以利用 Postman 提供的请求发送方法 pm.sendRequest 在 SearchRepo 的 pre-Script 脚本中直接完成前置请求的发送和参数获取。\n1 2 3 4 5 6 7 pm.sendRequest(\u0026#39;https://api.github.com/repos/junit-team/junit5\u0026#39;, function (err, res) { if (err) { console.log(err); } else { pm.environment.set(\u0026#34;created\u0026#34;, res.json().created_at); } }); 此时不需要利用 runner 执行器，直接执行 SearchRepo 接口，也可得到同样的结果 Postman脚本-代码复用 Postman 作为一个接口测试工具而不是专业的代码编辑 IDE， 并没有提供脚本的复用以及代码片、模块定义之类的功能。但借助 Postman 强大的变量和 js 语法的良好支持，我们可以变通地实现代码复用。\n我们可以将一些常用的代码片段保存到 global 变量中， 在需要使用的时候，直接调用这个 global 变量即可。\n比如上面判断返回 repo 数量是否超过 1000 这段校验代码：\n1 2 3 4 5 6 7 8 pm.test(\u0026#34;判断返回成功状态码\u0026#34;,function(){ pm.response.to.have.status(200); }); pm.test(\u0026#34;校验消息体返回数量大于1000\u0026#34;, function () { var jsonData = pm.response.json(); pm.expect(jsonData.total_count).to.gt(1000) }); 我们将它设置在 global 变量 checkRepoCount 中，在需要调用的地方，以如下代码代替即可：\n1 eval(globals.checkRepoCount) Postman 中如图： Postman脚本-一个结合第三方库的复杂场景案例 Postman 为便于接口脚本的编写，内建支持了丰富的第三方库，官方文档中列出了详细清单 除了前面提到的 BDD 校验库 chai, 下面我们再结合第三方时间处理库 moment 来完成一个相对复杂的场景案例实现：\n1 2 3 4 5 1. 获取最近 6 个月包含有 Junit5 字样且 Star 数 \u0026gt;1 的 repo 信息 2. 判断返回 repo 数量是否 \u0026gt;0, 结果显示到 Test Result 3. 如果数量 \u0026gt;0 , 获取 star 数最多的 repo 信息 4. 判断自己是否已经 star 过这个repo 5. 如果没有 star 过，执行 star操作 相关的接口如下：\n查询接口，查询关键字 junit5，star 数 \u0026gt;1 , 创建时间 6 月内， 按 star 数降序查询 /search/repositories?q=junit5+stars:\u0026gt;1+created:\u0026gt;{{created}}\u0026amp;sort=stars\n查询是否 star 了某 repo GET /user/starred/:owner/:repo\n已 star 返回 204，未 star 返回 404\n执行 star repo 操作 PUT /user/starred/:owner/:repo\n成功则返回 204\n在查询repo接口的 Pre-Script 脚本中引入事件处理库 moment，可以看到 moment 库相比 js 本身的 date 方法，对日期的处理更加方法灵活，利用 subtract 方法可简单获取半年前的日期，无需考虑日期补零、跨年等判断，代码如下：\n1 2 3 4 var m = require(\u0026#34;moment\u0026#34;) //利用 moment 库获取六个月前日期 let createDate = m(m.now()).subtract(6,\u0026#34;months\u0026#34;).format(\u0026#34;YYYY-MM-DD\u0026#34;) pm.environment.set(\u0026#34;created\u0026#34;, createDate); 在查询repo接口的 Test 脚本中编写校验和后续逻辑代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //获取符合条件repo总数量 let count = pm.response.json().total_count pm.test(\u0026#34;覆盖条件repo数量为 \u0026#34;+count, function(){ if( count \u0026gt; 0 ){ //保存repo的owner和repo名称，查询条件为按star排序，所以index为0的repo即star数最多 var repoName = pm.response.json().items[0].name var owner = pm.response.json().items[0].owner.login pm.test(\u0026#34;当前star数最多的repo是【\u0026#34;+ pm.response.json().items[0].full_name + \u0026#34;】\u0026#34;, function(){ //需要定义请求信息，指定header和执行方法。不指定的话直接在SendRequest中使用默认为GET方法，不携带Header const getStarReq = { url: \u0026#34;https://api.github.com/user/starred/\u0026#34;+owner+\u0026#34;/\u0026#34;+repoName, method: \u0026#39;GET\u0026#39;, //接口需要经过鉴权，代码中不能使用Postman界面设置，将鉴权信息携带在header中 header:\u0026#39;Authorization:Bearer 84fb9e0706bab75f1d4b6f4e3586683d8c4605af\u0026#39; } pm.sendRequest(getStarReq, function (err, res) { if (err) { console.log(err); } else { let stared = pm.test(\u0026#34;当前repo已star\u0026#34;,function(){ if (res.code === 404){ const starRequest = { url: \u0026#34;https://api.github.com/user/starred/\u0026#34;+owner+\u0026#34;/\u0026#34;+repoName, method: \u0026#39;PUT\u0026#39;, //接口需要经过鉴权，代码中不能使用Postman界面设置，将鉴权信息携带在header中 header: \u0026#39;Authorization:Bearer 84fb9e0706bab75f1d4b6f4e3586683d8c4605af\u0026#39; } pm.sendRequest(starRequest, function (starErr, starRes){ if (starErr) { console.log(starErr); } else { pm.test(\u0026#34;已star成功\u0026#34;,function(){ pm.expect(starRes.code).to.equal(204) }) } }) } pm.expect(res.code).to.equal(204) }) } }) }) } }) Postman 中执行效果如图： 结语及预告 以上就是关于 Postman 的脚本进阶使用的介绍。简单总结一下：\nPostman 提供了 5 种不同的变量类型，且分别对应不同的作用域。灵活使用这些变量，可以帮助我们实现动态匹配、参数传递、代码复用等场景。\npostman 在 Collection、Folder、接口本身三层上都分别提供了两种脚本沙箱：Pre-Script、Test。Pre-Script是在接口请求之前执行，Test 是在接口响应之后执行。注意三层对象上不同的执行顺序。\nPostman 脚本基于 Node.js，内建支持了丰富的第三方库，并且 Postman 自身也封装了很多上层方法，可以参考 Postman 官方沙箱方法参考\n所以Postman 通过丰富的变量以及强大的 js 脚本支持，可以非常灵活地帮助我们更好地完成接口测试中一些复杂的场景。\n虽然目前两篇 Chat 主要介绍了 Postman 在接口手工测试中的主要功能和使用技巧，但 Postman 其实也能非常方便地应用在自动化测试中，欢迎大家继续关注下一篇 《玩转Postman：自动化篇》，我们将一起来学习：\nPostman 的批量执行工具 Runner 详解 Postman 实现接口的流程控制 Postman 的命令行自动化工具 NewMan 详解 结合持续集成工具 Jenkins 实现 Postman 接口脚本的自动调度和执行 ","date":"2022-06-22T00:00:00Z","image":"https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png","permalink":"https://chengxiaqiucao.github.io/post/002-postman-middle/","title":"Postman进阶篇"},{"content":"前言 本教程将结合业界广为推崇和使用的RestAPI设计典范Github API，详细介绍Postman接口测试工具的使用方法和实战技巧。\n在开始这个教程之前，先聊一下为什么接口测试在现软件行业如此重要？ 为什么我们要学习Postman？\n现代软件行业已经从传统的万维网发展到移动互联网，云计算，如今更进入到万物互联时代。软件和网络会连接我们生活的方方面面，不同的设备，不同的软件系统之间存在各式各样的联系。而接口就是不同设备、系统之间联系的桥梁，所以接口在现今和未来的软硬件产业当中都具有越来越高的重要性和地位。\n什么是接口？ IT行业从WWW万维网时代的C/S，B/S架构，到移动互联网时代的大前端时代，发展到云计算时代以IaaS（基础架构即服务），PaaS（平台即服务），SaaS（软件即服务）为代表的云端架构，如今更是进入到万物互联的物联网时代，网络连接着我们生活的方方面面，而承载这些连接的连接点，就是网络接口，接口是不同网络应用之间联系、交互、相互作用的入口和桥梁。\n如下图，是接口在软件系统中所处位置的示意图 这里UI接口和API接口分别代表用户交互接口和应用程序接口\n接口测试 了解了接口的概念，我们再看什么是接口测试？\n以下是百度百科中给出的定义:\n接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。\n可以看到，针对接口定义阐述后，说明了接口测试的重点包括交互的数据、过程以及背后的业务逻辑。\n再进一步看更常用的API测试的定义，这个百度没有收录，可以看下Wiki百科的定义：\nAPI testing is a type of software testing that involves testing application programming interfaces (APIs) directly and as part of integration testing to determine if they meet expectations for functionality, reliability, performance, and security.[1] Since APIs lack a GUI, API testing is performed at the message layer.[2] API testing is now considered critical for automating testing because APIs now serve as the primary interface to application logic and because GUI tests are difficult to maintain with the short release cycles and frequent changes commonly used with Agile software development and DevOps.[3][4]\n它是直接针对API进行测试的一类集成测试，注意wiki把接口测试归类在集成测试阶段。也就是说它更多是在系统集成时实施。然后也说明了接口测试不单纯是功能测试，还需考虑可靠性、安全、性能等。API接口测试和GUI测试不同，更多体现在消息层，并且因为GUI层在自动化测试上的先天劣势，API自动化目前是自动化测试领域以及敏捷、DevOps等研发模式的关键实践。\n下图是著名的测试金字塔，它根据不同测试类型对软件测试进行了分层，底层是针对的代码层面的单元测试，中间是service服务测试，而现今的应用服务更多是API形式来体现，服务测试也可以理解为API的测试，上层则是针对用户界面的GUI测试。\n这个模型体现出在自动化测试中，越底层的自动化测试所占比重应该越大，才有更好的投入产出比。中间这一层的API测试它既不像UI层那样维护成本巨大，很难跟上快速迭代的要求，同时它又比单元测试更能在业务逻辑上进行质量验证。所以现在一般认为API测试是自动化测试实施上的优先选择\nHTTP协议基础 在正式开始Postman的功能介绍前，首先还是要介绍Postman的测试对象。Postman主要是针对HTTP协议接口的测试工具，所以本章首先介绍一下HTTP协议的基础知识。\nHTTP，即超文本传输协议（HyperText Transfer Protocol)，是互联网上应用最为广泛的一种网络协议，目前主要使用的1.1版本，基于TCP/IP通信协议来传递数据(HTML，文件、数据、API接口消息等)\nhttp协议工作于客户端-服务器即C/S架构上 HTTP消息组成 客户端发送一个HTTP请求到服务器，请求消息包括以下格式：\n请求行（request line）、请求头部（header）、空行和请求数据四个部分。如图\n如下是一个请求百度首页的请求示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 GET https://www.baidu.com/ HTTP/1.1 #请求方法 URL HTTP协议版本 Host: www.baidu.com #请求服务器地址 #以下是消息头内容 Connection: keep-alive #连接方式：长连接 Cache-Control: max-age=0 #请求缓存控制，需确认请求内容是否有修改 Upgrade-Insecure-Requests: 1 #支持https协议 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36 #请求客户端，浏览器版本 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 #支持的响应内容类型 Accept-Encoding: gzip, deflate, br #支持的编码类型 Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 #支持的语言 Cookie: BAIDUID=C0A2... #携带的cookie信息 #未携带请求消息体，body为空 服务器接收并处理客户端发过来的请求，返回一个HTTP的响应消息。也由四个部分组成，分别是：\n响应状态行、消息报头、空行和响应正文。 如图\n如下是百度首页的响应示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 HTTP/1.1 200 OK #协议版本 消息状态码 状态描述 Bdpagetype: 2 Bdqid: 0x8707d7d80001f34e #自定义消息头 Cache-Control: private #缓存控制策略 Connection: Keep-Alive #长连接 Content-Type: text/html;charset=utf-8 #响应内容类型 Date: Sat, 22 Dec 2018 08:54:51 GMT #响应时间 Expires: Sat, 22 Dec 2018 08:54:51 GMT #过期失效时间 Server: BWS/1.1 #服务器系统及版本 Set-Cookie: BDSVRTM=372; path=/ Set-Cookie: BD_HOME=1; path=/ Set-Cookie: path=/; domain=.baidu.com #设置客户端cookie Strict-Transport-Security: max-age=172800 #严格安全传输，有效时间 X-Ua-Compatible: IE=Edge,chrome=1 #兼容浏览器版本 Content-Length: 191722 #消息体长度 #以下消息体内容 \u0026lt;!Doctype html\u0026gt; \u0026lt;html xmlns=http://www.w3.org/1999/xhtml\u0026gt;\u0026lt;head\u0026gt; ... HTTP方法 HTTP方法是请求消息中携带的关键信息，告知服务器本次请求希望进行的操作类型。目前在HTTP1.1版本中常见以下方法\nNo. 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 7 TRACE 回显服务器收到的请求，主要用于测试或诊断。 8 PATCH 从客户端向服务器传送数据，取代指定文档的部分内容 HTTP状态码 HTTP状态码定义了服务器端处理HTTP请求的结果信息，主要包含以下五类：\n状态码 描述 1XX 已接收，待处理 2XX 请求处理成功 3XX 重定向，资源位置发生变化 4XX 客户端请求信息错误 5XX 服务端处理发生错误 1xx 消息 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。[4] 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。\n2xx 成功 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。\n3xx 重定向 这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。\n4xx 客户端错误 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容\n5xx 服务器错误 表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。\n详细的状态码清单可参见附录\nGitHub API 本教程后续将主要使用Github API作为实战介绍API。 本章会简要介绍Github网站以及Github API。\nGitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。也是目前全球最大的代码托管平台，可以说是程序员的圣地，号称全球最大的同性交友平台:joy: (Github 国内有时会间歇性无法访问，可能需要科学上网)\ngithub 中的一些主要概念 提交（commit）：提交更改到仓库（本地Git仓库与GitHub仓库是两码事）。 提交信息（commit message）：每次提交的时候，需要提供一个信息，描述这次提交都做了什么。 分支（branch）：像树状图一样，每个独立的分支都是项目的一个版本，分支都可以与master合并。 主分支（master branch）：所有的Git项目在最初创建时，都会默认创建出一个分支，这就是主分支。在开发中，写一个新功能的时候，都是先建立一个分支，在该分支上完成功能并测试，通过后由项目leader将该分支merge到master上。 功能分支（feature branch）：没怎么用过 发布分支（release branch）：如果有一个手动QA（质量管理）流程，或者必须要支持旧版本的软件时，需要一个发布分支来存放必要的补丁与更新记录。功能分支和发布分支没技术区别，只是在团队间讨论的时候，有助于区分类别。 合并（merge）：merge可以将一个分支上的全部内容归并到另一个分支上，一般就是将分支merge到主分支。 标签（tag）：常用于记录发布版本，在版本发布的时候，给一个tag，这样就能够记录该版本的代码是何时生成的。 查看（check out）：一般就是查看某一个分支上操作的记录。 拉取（pull request）：一般用来从远程仓库拉取分支中的代码到本地，也可以从本地仓库中拉取分支代码到当前工程中。 提出问题（issue）：GitHub的提出问题的功能，一般遇到问题，可以将出现问题的场合，通过issue的方式记录。 维基（WIKI）：一个轻量级的Web页面创建方式，创建的Web页面之间可以通过链接互相联系。GitHub中的项目通常使用WIKi进行文档记录。 克隆（clone）：从GitHub上下载一个副本到本地，操作后可以pull上去。 分叉（fork）：A复制一个B的项目到自己的账户下，修改后再提交，B能看到A修改的内容，但是B原本的项目是不会有变动的。 github 主界面功能 图片转自george_zyf的博客\nGithub API 目前Github API最新的V4版本是基于GraphQL的API，但常用的还是V3的Restful API\ngithub API中几类主要资源及对应操作 User 资源\nRepo 操作\nissue 操作\n图片来自网络\ngithub 中的时间格式 github 中时间格式如下：\nYYYY-MM-DDTHH:MM:SSZ\ngithub 限流规则 github 为包含服务端负载压力，会对请求流量进行限制。在每个 github 的响应消息头中都会携带 github 的限流设置。\n头参数 含义 X-RateLimit-Limit 当前每小时最大请求限制，一般未鉴权请求60次，鉴权请求5000次 X-RateLimit-Remaining 当前剩余请求次数 X-RateLimit-Reset 剩余限制重置时间，毫秒 请求参数与分页 请求中可以携带参数，一般包含两种参数: 路径参数和查询参数 github API中默认支持两个分页参数：\npage 当前显示页数 per_page 每页显示结果数 Postman 基础 可以用于Rest接口测试的测试工具非常多，常见的有soapUI、Jmeter、fiddler等都经常用来做接口测试。但是目前在接口测试人员中最流行，最常见还是本章向大家介绍的Postman。\nPostman 的安装 Postman最早的版本，以及很长一段时间都是以Chrome插件的形式存在的。以至很多人甚至认为postman就是google的官方工具插件，我们目前能看到的大量资料也都是基于chrome的插件形式来进行介绍的。\n但是目前Postman其实已经推出了独立的本地App程序，并且官方已经宣布不再支持chrome的插件形式。虽然插件版本现在还能使用，可是毕竟相比Native版本，受限于chrome浏览器的功能，很多功能在插件版本中是欠缺的，比如cookie的内建支持，代理功能，控制台功能等等。所以此处就不再介绍插件版本的安装。\n本地版本的安装，其实也非常简单。从官网根据自己操作系统的类型选择相应的版本下载即可。 这里还有一点要注意下，在postman的官网，我们最好注册一个账号，后续在使用postman的时候很多高级功能需要用这个账号登录后才可以使用。\n安装完成，在桌面上出现Postman那个pose很帅的小人图标，则安装完成。\nPostman 主界面 打开Postman进入，首次会提示选择希望创建的任务类型。\n这里有六种任务类型，我们再下面的实战中都会详细讲解，这里先简单说明一下：\nRequest是Postman软件的基础和核心，也就是通过这个功能来创建request请求，完成接口测试的核心工作。 Collection其实是个集合，我们可以认为是一批Request请求的集合，或者说测试集。它也是Postman一些进阶功能的基本单位 Environment，字面理解就是环境，其实可以认为是一些配置变量的集合，实际应用中可以起到通过不同配置区分不同测试环境的效果 后面这三个都是Postman的高级功能 API documention，是通过我们调试通过的request来自动生成接口文档，便于团队的共享和接口的交付。 Mock server 在我们进行接口测试或开发的时候，很多时候是需要模拟对端的接口服务器的，Mock server就起到的模拟服务器端的作用。 Monitor 这是个监控功能，通过monitor我可以监控我的接口是不是正常。说白了，这其实就是个定时的接口执行功能。 大致了解下几种不同的任务类型，我们先关掉这个界面，我们再来看看主界面的功能区间 Banner 区域 首先是上面的菜单栏，对应功能区的各项功能，在菜单栏上都能找到对应的菜单。然后是下面的banner区域。 从左到右依次介绍：\n会打开启动时的创建窗口，用于创建六种类型的任务。\n按钮，可以用于导入外部文件，外部文件可以是postman的Collection格式文件，数据文件，以及其他的API定义文件\n则会启动Collection runner，它是一个运行器，用于运行已经建立的测试任务。我们后面会有详细介绍\n第四个按钮，可以新建tab，或者多开一个postman程序，或者runer程序。\n中间是选择使用的workspace，但这个需要账号登录，会同步云端的workspace设置。每个账号会有一个默认的workspace，workspace它是一个工作空间，大家可以理解成类似项目或者工程。\nbanner条右侧还有几个按钮\n第一个是同步，也是在有账号的情况下，可以在多个电脑间同步workspace内的相关接口测试设计。 第二个proxy，则类似前面介绍过的fiddler，提供代理抓取API功能。当然这个功能postman不像Fiddler那样丰富 第三个按钮包括setting以及文档指南。 setting里是软件的本地配置 第四个按钮是消息通知，很好理解，会显示一些提醒信息 然后是postman的twitter，在墙后面就不要去看了 最后是登录，可以用postman的账号的登录 Setting 设置 Postman 工具的使用属性和应用设置我们可以在Setting 中国进行设置。以下分别说明：\nGeneral Themes Shortcuts 工具快捷键 Data 工具数据导入导出 add-ons Newman 插件下载方法 Sync 同步设置 certificates 本地证书设置 Proxy 本地网络代理设置 update 升级设置 about 工具**关于\u0026hellip;**等版本信息 左侧边栏 filter筛选栏，筛选显示不同的消息 history是操作消息记录清单 collection如前面介绍，显示请求集合 底边状态栏 最左面，显示和关闭左侧边栏 然后是搜索功能，这个容易理解 第三个是控制台，可以在这里看到消息相互的详细信息 用户指南 调整功能区显示样式 快捷键清单参考 帮助相关的连接 主功能区 主要包括上下两部分，上面是request区，下面是response区。也可以分成左右显示。\nRequest区域 request部分默认开启了一个选项卡，可以新开多个选项卡便于同时编辑。\n默认使用的是GET方法，这也是使用最多的HTTP方法，下拉可以选择其他的方法，常用的还有哪些？ POST、PUT、Delete等。\nURL部分输入请求的地址。比如我们输入GithubAPI的根地址。\nparam是参数管理界面，在这里我们可以添加参数（有key-value，块编辑模式）。\nSend发送请求，小箭头下send and download，会在发送以后把响应消息导出成json保存。旁边的save，保存功能，其实是把这个request作为一个case保存到collection里。\n鉴权部分，虽然request编辑器已经足够强大可以处理鉴权消息，但是很多时候鉴权是个使用频率很高的功能，所以Postman单独把鉴权部分抽取出来，并且封装了目前的绝大部分鉴权方式\n继承，默认鉴权方式 不鉴权 bearer token鉴权，一般也叫Json web token，其实就是发送一个json格式的token令牌，服务端会针对token进行解密验证 Basic Auth基础验证，提供用户名密码验证，postman 会自动生成authorization，常用鉴权方式 digest auth，摘要式认证 在基本身份认证上面扩展了安全性，服务器为每一个连接生成一个唯一的随机数，客户端用这个随机数对密码进行MD5加密，然后返回服务器，服务器也用这个随机数对密码进行加密，然后和客户端传送过来的加密数据进行比较,如果一致就返回结果。 它是一个二次验证的过程，会有两次认证交互消息 客户端请求资源-\u0026gt;服务器返回认证标示-\u0026gt;客户端发送认证信息-\u0026gt;服务器查验认证 Oauth，一般用于第三方认证，有1,2两个版本，需要提供的信息不太一样。也是常用的鉴权方式 Hawk 认证，是另一种认证方案，采用的叫消息码认证算法，和Digest认证类似，它也是需要二次交互的 AWS签名认证，是针对亚马逊的AWS公有云用户签名的认证方式 NTLM是微软的局域网管理认证协议 大家有个基本了解即可，一般比较常用的就是basic以及OAuth2了。\nheader就是消息头管理，可以定义头部信息。\nBody，请求消息体。一般Post、put、patch等会更新内容的请求才会携带消息体，\n旁边pre-script，是指在请求发送前，可以做一些预处理的工作，类似junit等单元测试框架中的setup方法，支持js脚本语法\nTest则是在响应以后，对响应进行校验或其他处理的，类似junit框架中的teardown方法，同样支持js脚本语法\ncookie管理postman本地cookie信息\ncode是一个方便程序员的功能，可以自动将接口请求转化成相关语言编码，可以看到支持的语言非常丰富，基本涵盖了各种主流编程语言。\nResponse区域 响应消息右上角是状态码，悬停可以看到详细解释。另外是响应时间（从发出请求到返回客户端接收的时间），以及消息大小（含消息头和消息体）。\n响应body部分，即消息体。包括以下几个按钮\npretty，可以根据表现类型进行格式化显示，默认json，如果是其他格式类型，可以选择对应形式进行格式化。 Raw则是未格式化的形式 preview则是预览，就是在浏览器里渲染后呈现的样子，比如返回的是html就很直观。 旁边是自动换行按钮。 右边是拷贝到剪切板和查询按钮（正则，大小写敏感、全词匹配）\n其他的几个tab：\ncookie：响应消息的cookie信息 header：响应消息的header头部信息 Test Results：在请求中添加test Script后，这里会显示测试脚本的校验结果 Postman中完成Github鉴权 从Github API文档中，我们可以看到Github API支持多种鉴权方式\nBasic authentication 1 curl -u \u0026#34;username\u0026#34; https://api.github.com 这是基本鉴权方式\nOAuth2 token (sent in a header) 1 curl -H \u0026#34;Authorization: token OAUTH-TOKEN\u0026#34; https://api.github.com 也支持通过在Header中携带Oauth2的token进行鉴权。在github用户设置中可以生成这个token。\n个人设置 \u0026gt; Settings \u0026gt; Developer settings \u0026gt; Personal access tokens 生成后会获得一个token字串 OAuth2 token (sent as a parameter) 1 curl https://api.github.com/?access_token=OAUTH-TOKEN 或者通过在URL中携带token参数鉴权。\nPostman中，可以在Collection中设置鉴权 在具体的请求消息中，可以选择Inherit auth from parent，即继承上一层的鉴权。发送请求后，可以看到已经在header中携带了鉴权的token信息 根据Github API的定义，对于请求有访问限制，即未鉴权的请求限制访问为每分钟60次，对于已鉴权的请求访问每分钟5000次。\n我们从响应消息的消息头中可以看到这个设置，如：\n1 2 3 X-RateLimit-Limit →5000 X-RateLimit-Remaining →4999 X-RateLimit-Reset →1546528838 Postman实现基本HTTP方法 再来看如何在Postman中实现常用的HTTP方法。还是以GithubAPI为例：\nGET方法 - 获取Repo信息 GET /repos/:owner/:repo\n这里是获取Github上Repo信息的API，这里有两个路径参数，owner代表用户账号，repo指需要获取的repo信息。 如图是在postman中设置路径参数的方法。 POST方法 - 创建Repo 创建Repo的示例(https://developer.github.com/v3/repos/#create)\nPOST /user/repos\n这里是一个创建hello world的Repo的请求消息体示例\n1 2 3 4 5 6 7 8 9 { \u0026#34;name\u0026#34;: \u0026#34;Hello-World\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is your first repository\u0026#34;, \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com\u0026#34;, \u0026#34;private\u0026#34;: false, \u0026#34;has_issues\u0026#34;: true, \u0026#34;has_projects\u0026#34;: true, \u0026#34;has_wiki\u0026#34;: true } 这里name是必填字段，其他是repo的属性设置。 在Postman中如图提交，返回状态码201 created，即可创建一个Hello world的Repo 在Github中，可以看到账号下新增了一个hello world的repo，并且包含有已设置的issue、projects、wiki这几个栏目 PATCH方法 - 修改Repo GitHub可以通过PATCH方法来对Repo进行修改.PATCH方法和PUT方法都是update的修改方法，但PATCH方法更多用在部分修改的场景下，PUT方法则更多是整体替换。\nPATCH /repos/:owner/:repo\n比如上例中hello world这个repo修改Repo中的部分信息，可以去除projects和wiki这两个栏目 消息体：\n1 2 3 4 5 6 7 { \u0026#34;name\u0026#34;: \u0026#34;Hello-World\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is your first repository\u0026#34;, \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com\u0026#34;, \u0026#34;has_projects\u0026#34;: false, \u0026#34;has_wiki\u0026#34;: false } Postman中如图： 回到Github，可以看到Repo中对应的栏目已经不见了 PUT方法 - 设置或替换Topic Topic是Github上Repo的搜索关键字，便于用户进行repo查询。\nPUT /repos/:owner/:repo/topics\nGithub API设置topic的api是使用put方法提交一个topic数组，如\n1 2 3 4 5 6 7 { \u0026#34;names\u0026#34;: [ \u0026#34;restapi\u0026#34;, \u0026#34;atom\u0026#34;, \u0026#34;chengxiaqiucao\u0026#34; ] } 这时在Postman中提交，会发现有如下报错： 这是因为Github API要求设置topic时，需要在header中设置accept字段,取值：\napplication/vnd.github.mercy-preview+json\n正确设置后，则可以看到设置成功,返回200 OK 大家可能会发现一个小bug，当设置的topic存在大写字符时，会出现格式报错。比如大家参照官方示例设置\u0026quot;API\u0026quot;这样的topic，会发现设置不成功。大家可以尝试一下。\nDELETE方法 - 删除Repo Github API中，使用delete方法可以删除repo\nDELETE /repos/:owner/:repo\n删除成功后，返回204. 此时再查询账号，应该发现Hello-World这个repo已经被删除了\n结语及预告 至此，我们通过Github API中几个实际的例子，学习了如何通过Postman来完成一些基本的HTTP方法的请求发送和响应查看，通过查看结果状态码或响应内容来判断结果正确性。\n当然Postman的功能远不止于此，API接口测试中也还有很多复杂的场景需要特别处理。 欢迎大家继续关注 《玩转Postman - 进阶篇》。在进阶篇中我们将继续深入讲解Postman的进阶功能，并结合一些复杂的实例场景来学习：\nPostman 的变量类型及其作用域 环境与 Collection; Postman 如何通过内建脚本实现接口预处理 Postman 实现测试结果的脚本校验； 如何实现接口的关联测试 Postman 中的 JavaScript 扩展 附录 HTTP状态码详解（译自Wiki百科，目前所见最全面的解释） 1xx 消息 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。[4] 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。\n100 Continue 服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送Expect: 100-continue作为头部，并在发送正文之前接收100 Continue状态代码。响应代码417期望失败表示请求不应继续。\n101 Switching Protocols 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如WebSocket）以传送利用此类特性的资源。\n102 Processing（WebDAV；RFC 2518） WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。[6]这样可以防止客户端超时，并假设请求丢失。\n2xx 成功 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。\n200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。\n201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回'202 Accepted\u0026rsquo;。\n202 Accepted 服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。\n203 Non-Authoritative Information（自HTTP / 1.1起） 服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以200 OK状态码为起源，但回应了原始响应的修改版本。\n204 No Content 服务器成功处理了请求，没有返回任何内容。\n205 Reset Content 服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。\n206 Partial Content（RFC 7233） 服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\n207 Multi-Status（WebDAV；RFC 4918） 代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。\n208 Already Reported （WebDAV；RFC 5842） DAV绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。\n226 IM Used （RFC 3229） 服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。\n3xx 重定向 这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。\n当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。\n300 Multiple Choices 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。\n301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。\n302 Found 要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。\n303 See Other 对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。[23]这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。\n304 Not Modified 表示资源未被修改，因为请求头指定的版本If-Modified-Since或If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。\n305 Use Proxy 被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。许多HTTP客户端（像是Mozilla和Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。\n306 Switch Proxy 在最新版的规范中，306状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。\n307 Temporary Redirect 在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。\n308 Permanent Redirect (RFC 7538) 请求和所有将来的请求应该使用另一个URI重复。 307和308重复302和301的行为，但不允许HTTP方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。\n4xx 客户端错误 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。[30]\n如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。\n400 Bad Request 由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。\n401 Unauthorized（RFC 7235） 参见：HTTP基本认证、HTTP摘要认证 类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。 注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。\n402 Payment Required 该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。\n403 Forbidden 主条目：HTTP 403 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。\n404 Not Found 主条目：HTTP 404 请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。[35]没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。\n405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过POST呈现数据的表单上的GET请求，或只读资源上的PUT请求。 鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。\n406 Not Acceptable 参见：内容协商 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。[36] 除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。\n407 Proxy Authentication Required（RFC 2617） 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。[37]代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。\n408 Request Timeout 请求超时。根据HTTP规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。\n409 Conflict 表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。\n410 Gone 表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到410状态码后，用户应停止再次请求资源。但大多数服务端不会使用此状态码，而是直接使用404状态码。\n411 Length Required 服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。\n412 Precondition Failed（RFC 7232） 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。\n413 Request Entity Too Large（RFC 7231） 前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。\n414 Request-URI Too Long（RFC 7231） 前称“Request-URI Too Long”，表示请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为GET请求的查询字符串，在这种情况下，应将其转换为POST请求。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串过长。 重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回414状态码。\n415 Unsupported Media Type 对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为svg，但服务器要求图像使用上传格式为jpg。\n416 Requested Range Not Satisfiable（RFC 7233） 前称“Requested Range Not Satisfiable”。客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。\n417 Expectation Failed 在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。\n418 I\u0026rsquo;m a teapot（RFC 2324） 本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324超文本咖啡壶控制协议\u0026rsquo;中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的HTCPCP收到BREW或POST指令要求其煮咖啡时应当回传此错误。这个HTTP状态码在某些网站（包括Google.com）与项目（如Node.js、ASP.NET和Go语言）中用作彩蛋。\n420 Enhance Your Caim Twitter Search与Trends API在客户端被限速的情况下返回。\n421 Misdirected Request （RFC 7540） 该请求针对的是无法产生响应的服务器（例如因为连接重用）。\n422 Unprocessable Entity（WebDAV；RFC 4918 ） 请求格式正确，但是由于含有语义错误，无法响应。\n423 Locked（WebDAV；RFC 4918） 当前资源被锁定。\n424 Failed Dependency（WebDAV；RFC 4918） 由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。\n425 Unordered Collection 在WebDAV Advanced Collections Protocol中定义，但Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol中并不存在。\n426 Upgrade Required（RFC 2817） 客户端应当切换到TLS/1.0，并在HTTP/1.1 Upgrade header中给出。\n428 Precondition Required (RFC 6585) 原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”\n429 Too Many Requests （RFC 6585） 用户在给定的时间内发送了太多的请求。旨在用于网络限速。\n431 Request Header Fields Too Large （RFC 6585） 服务器不愿处理请求，因为一个或多个头字段过大。\n444 No Response Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。\n450 Blocked by Windows Parental Controls 这是一个由Windows家庭控制（Microsoft）HTTP阻止的450状态代码的示例，用于信息和测试。\n451 Unavailable For Legal Reasons 该访问因法律的要求而被拒绝，由IETF在2015核准后新增加。\n494 Request Header Too Large 在错误代码431提出之前Nginx上使用的扩展HTTP代码。\n5xx 服务器错误 表示服务器无法完成明显有效的请求。[56]这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。\n500 Internal Server Error 通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。\n501 Not Implemented 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务API的新功能）\n502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\n503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。\n504 Gateway Timeout 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误。\n505 HTTP Version Not Supported 服务器不支持，或者拒绝支持在请求中使用的HTTP版本。[63]这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。\n506 Variant Also Negotiates（RFC 2295） 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。\n507 Insufficient Storage（WebDAV；RFC 4918） 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。\n508 Loop Detected （WebDAV；RFC 5842） 服务器在处理请求时陷入死循环。 （可代替 208状态码）\n510 Not Extended（RFC 2774） 获取资源所需要的策略并没有被满足。\n511 Network Authentication Required （RFC 6585） 客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。（例如连接WiFi热点时的强制网络门户）\n秋草的公众号，秋草说测试， 欢迎关注\n","date":"2022-06-12T00:00:00Z","image":"https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png","permalink":"https://chengxiaqiucao.github.io/post/001-postman-basic/","title":"Postman基础篇"}]
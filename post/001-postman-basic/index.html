<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Postman的基本用法介绍"><title>Postman基础篇</title><link rel=canonical href=https://chengxiaqiucao.github.io/post/001-postman-basic/><link rel=stylesheet href=/scss/style.min.d6334826c849a420a2748e4872b915ae516105f86c3993d9bad2032725f784b8.css><meta property='og:title' content="Postman基础篇"><meta property='og:description' content="Postman的基本用法介绍"><meta property='og:url' content='https://chengxiaqiucao.github.io/post/001-postman-basic/'><meta property='og:site_name' content='秋 草 观 “测” 台'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Postman'><meta property='article:tag' content='接口测试'><meta property='article:published_time' content='2022-06-12T00:00:00+00:00'><meta property='article:modified_time' content='2022-06-12T00:00:00+00:00'><meta property='og:image' content='https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png'><meta name=twitter:title content="Postman基础篇"><meta name=twitter:description content="Postman的基本用法介绍"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png'></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/automnGrass_hu_5e44a092fd905642.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>秋 草 观 “测” 台</a></h1><h2 class=site-description>Testing is not just checking...</h2></div></header><ol class=menu-social><li><a href=https://github.com/chengxiaqiucao target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://space.bilibili.com/472272606 target=_blank title=Bilibili rel=me><!doctype html><svg t="1750732982440" class="icon" viewBox="0 0 1024 1024" p-id="4593" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M306.005333 117.632 444.330667 256h135.296l138.368-138.325333A42.666667 42.666667.0 01778.368 178.048L700.330667 256H789.333333A149.333333 149.333333.0 01938.666667 405.333333v341.333334A149.333333 149.333333.0 01789.333333 896H234.666667A149.333333 149.333333.0 0185.333333 746.666667V405.333333A149.333333 149.333333.0 01234.666667 256h88.96L245.632 177.962667a42.666667 42.666667.0 0160.373333-60.373334zm483.328 223.701333H234.666667a64 64 0 00-63.701334 57.856L170.666667 405.333333v341.333334a64 64 0 0057.856 63.701333L234.666667 810.666667h554.666666a64 64 0 0063.701334-57.856L853.333333 746.666667V405.333333a64 64 0 00-64-64zm-448 128A42.666667 42.666667.0 01384 512v85.333333a42.666667 42.666667.0 01-85.333333.0V512a42.666667 42.666667.0 0142.666666-42.666667zm341.333334.0A42.666667 42.666667.0 01725.333333 512v85.333333a42.666667 42.666667.0 01-85.333333.0V512a42.666667 42.666667.0 0142.666667-42.666667z" p-id="4594" fill="#8a8a8a"/></svg></a></li><li><a href=https://www.zhihu.com/people/qiucao target=_blank title=zhihu rel=me><!doctype html><svg t="1750733049138" class="icon" viewBox="0 0 1024 1024" p-id="5820" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M570.581333 806.272h61.952L652.928 876.117333 764.074667 806.272h130.986666V230.186667h-324.48V806.272zM636.501333 292.693333h192.64V743.68h-73.898666l-73.813334 46.378667L668.032 743.808l-31.530667-.128V292.736zM515.754667 493.738667H377.429333a2999.466667 2999.466667.0 005.802667-194.56h135.338667S523.776 239.445334 495.872 240.128H261.76c9.216-34.730667 20.821333-70.613333 34.688-107.690667.0.0-63.701333.0-85.333333 57.130667C202.112 213.12 176.128 303.786667 129.877333 396.416c15.573333-1.706667 67.114667-3.114667 97.450667-58.794667 5.589333-15.616 6.656-17.621333 13.568-38.485333h76.373333c0 27.776-3.157333 177.109333-4.437333 194.474667h-138.24c-31.104.0-41.173333 62.549333-41.173333 62.549333h173.482666C295.253333 688.256 232.789333 799.573333 119.466667 887.466667c54.186667 15.488 108.202667-2.432 134.912-26.197334.0.0 60.8-55.338667 94.122666-183.381333L491.264 849.834667s20.906667-71.168-3.285333-105.856c-20.053333-23.637333-74.24-87.552-97.322667-110.72l-38.698667 30.72c11.52-36.992 18.474667-72.96 20.821334-107.690667h163.072s-.213333-62.549333-20.053334-62.549333z" p-id="5821" fill="#8a8a8a"/></svg></a></li><li><a href=mailto:%20danmyw@qq.com target=_blank title=e-mail rel=me><!doctype html><svg t="1750733089669" class="icon" viewBox="0 0 1451 1024" p-id="6983" xmlns:xlink="http://www.w3.org/1999/xlink" width="283.3984375" height="200"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z" fill="#8a8a8a" p-id="6984"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/page/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>检索</span></a></li><li><a href=/page/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>链接</span></a></li><li><a href=/page/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/page/releases/><svg class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg>
<span>热门开源</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://chengxiaqiucao.github.io/en/>English</option><option value=https://chengxiaqiucao.github.io/ selected>中文</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><ol><li><a href=#前言>前言</a><ol><li><a href=#什么是接口>什么是接口？</a></li><li><a href=#接口测试>接口测试</a></li></ol></li><li><a href=#http协议基础>HTTP协议基础</a><ol><li><a href=#http消息组成>HTTP消息组成</a></li><li><a href=#http方法>HTTP方法</a></li><li><a href=#http状态码>HTTP状态码</a></li></ol></li><li><a href=#github-api>GitHub API</a><ol><li><a href=#github-中的一些主要概念>github 中的一些主要概念</a></li><li><a href=#github-主界面功能>github 主界面功能</a></li><li><a href=#github-api-1>Github API</a></li></ol></li><li><a href=#postman-基础>Postman 基础</a><ol><li><a href=#postman-的安装>Postman 的安装</a></li><li><a href=#postman-主界面>Postman 主界面</a></li><li><a href=#postman中完成github鉴权><strong>Postman中完成Github鉴权</strong></a></li><li><a href=#postman实现基本http方法>Postman实现基本HTTP方法</a></li><li><a href=#结语及预告>结语及预告</a></li></ol></li><li><a href=#附录>附录</a></li><li><a href=#1xx-消息-1>1xx 消息</a><ol><li></li><li><a href=#2xx-成功-1>2xx 成功</a></li><li><a href=#3xx-重定向-1>3xx 重定向</a></li><li><a href=#4xx-客户端错误-1>4xx 客户端错误</a></li><li><a href=#5xx-服务器错误-1>5xx 服务器错误</a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/001-postman-basic/><img src=https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png loading=lazy alt="Featured image of post Postman基础篇"></a></div><div class=article-details><header class=article-category><a href=/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/ style=background-color:#c6fad2;color:#000>测试工具</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/001-postman-basic/>Postman基础篇</a></h2><h3 class=article-subtitle>Postman的基本用法介绍</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 12, 2022</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 36 分钟</time></div></footer><footer class=article-translations><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><div><a href=https://chengxiaqiucao.github.io/en/post/001-postman-basic/ class=link>English</a></div></footer></div></header><section class=article-content><h3 id=前言>前言</h3><p>本教程将结合业界广为推崇和使用的RestAPI设计典范Github API，详细介绍Postman接口测试工具的使用方法和实战技巧。</p><p>在开始这个教程之前，先聊一下为什么接口测试在现软件行业如此重要？ 为什么我们要学习Postman？</p><p>现代软件行业已经从传统的万维网发展到移动互联网，云计算，如今更进入到万物互联时代。软件和网络会连接我们生活的方方面面，不同的设备，不同的软件系统之间存在各式各样的联系。而接口就是不同设备、系统之间联系的桥梁，所以接口在现今和未来的软硬件产业当中都具有越来越高的重要性和地位。</p><h4 id=什么是接口>什么是接口？</h4><p>IT行业从WWW<strong>万维网时代</strong>的C/S，B/S架构，到<strong>移动互联网时代</strong>的大前端时代，发展到<strong>云计算时代</strong>以IaaS（基础架构即服务），PaaS（平台即服务），SaaS（软件即服务）为代表的云端架构，如今更是进入到万物互联的<strong>物联网时代</strong>，网络连接着我们生活的方方面面，而承载这些连接的连接点，就是网络接口，<strong>接口是不同网络应用之间联系、交互、相互作用的入口和桥梁</strong>。</p><p>如下图，是接口在软件系统中所处位置的示意图
<img src=/frontEndDemo/images/20181222_160134.png loading=lazy alt=image>
这里UI接口和API接口分别代表用户交互接口和应用程序接口</p><h4 id=接口测试>接口测试</h4><p>了解了接口的概念，我们再看什么是接口测试？</p><p>以下是百度百科中给出的定义:</p><blockquote><p>接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。</p></blockquote><p>可以看到，针对接口定义阐述后，说明了接口测试的重点包括交互的数据、过程以及背后的业务逻辑。</p><p>再进一步看更常用的API测试的定义，这个百度没有收录，可以看下Wiki百科的定义：</p><blockquote><p>API testing is a type of software testing that involves testing application programming interfaces (APIs) directly and as part of integration testing to determine if they meet expectations for functionality, reliability, performance, and security.[1] Since APIs lack a GUI, API testing is performed at the message layer.[2] API testing is now considered critical for automating testing because APIs now serve as the primary interface to application logic and because GUI tests are difficult to maintain with the short release cycles and frequent changes commonly used with Agile software development and DevOps.[3][4]</p></blockquote><p>它是直接针对API进行测试的一类集成测试，注意wiki把接口测试归类在集成测试阶段。也就是说它更多是在系统集成时实施。然后也说明了接口测试不单纯是功能测试，还需考虑可靠性、安全、性能等。API接口测试和GUI测试不同，更多体现在消息层，并且因为GUI层在自动化测试上的先天劣势，API自动化目前是自动化测试领域以及敏捷、DevOps等研发模式的关键实践。</p><p>下图是著名的测试金字塔，它根据不同测试类型对软件测试进行了分层，底层是针对的代码层面的单元测试，中间是service服务测试，而现今的应用服务更多是API形式来体现，服务测试也可以理解为API的测试，上层则是针对用户界面的GUI测试。</p><p><img src=/frontEndDemo/images/20181222_161451.png loading=lazy alt=image></p><p>这个模型体现出在自动化测试中，越底层的自动化测试所占比重应该越大，才有更好的投入产出比。中间这一层的API测试它既不像UI层那样维护成本巨大，很难跟上快速迭代的要求，同时它又比单元测试更能在业务逻辑上进行质量验证。所以现在一般认为API测试是自动化测试实施上的优先选择</p><h3 id=http协议基础>HTTP协议基础</h3><p>在正式开始Postman的功能介绍前，首先还是要介绍Postman的测试对象。Postman主要是针对HTTP协议接口的测试工具，所以本章首先介绍一下HTTP协议的基础知识。</p><blockquote><p>HTTP，即超文本传输协议（HyperText Transfer Protocol)，是互联网上应用最为广泛的一种网络协议，目前主要使用的1.1版本，基于TCP/IP通信协议来传递数据(HTML，文件、数据、API接口消息等)</p></blockquote><p>http协议工作于客户端-服务器即C/S架构上
<img src=/frontEndDemo/images/20181222_163102.png loading=lazy alt=image></p><h4 id=http消息组成>HTTP消息组成</h4><p>客户端发送一个HTTP请求到服务器，请求消息包括以下格式：</p><p><strong>请求行（request line）、请求头部（header）、空行和请求数据</strong>四个部分。如图</p><p><img src=/frontEndDemo/images/20181222_163224.png loading=lazy alt=image></p><p>如下是一个请求百度首页的请求示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>GET https://www.baidu.com/ HTTP/1.1
</span></span><span class=line><span class=cl><span class=c1>#请求方法  URL HTTP协议版本</span>
</span></span><span class=line><span class=cl>Host: www.baidu.com
</span></span><span class=line><span class=cl><span class=c1>#请求服务器地址</span>
</span></span><span class=line><span class=cl><span class=c1>#以下是消息头内容</span>
</span></span><span class=line><span class=cl>Connection: keep-alive
</span></span><span class=line><span class=cl><span class=c1>#连接方式：长连接</span>
</span></span><span class=line><span class=cl>Cache-Control: max-age<span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl><span class=c1>#请求缓存控制，需确认请求内容是否有修改</span>
</span></span><span class=line><span class=cl>Upgrade-Insecure-Requests: <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1>#支持https协议</span>
</span></span><span class=line><span class=cl>User-Agent: Mozilla/5.0 <span class=o>(</span>Windows NT 10.0<span class=p>;</span> Win64<span class=p>;</span> x64<span class=o>)</span> AppleWebKit/537.36 <span class=o>(</span>KHTML, like Gecko<span class=o>)</span> Chrome/71.0.3578.98 Safari/537.36
</span></span><span class=line><span class=cl><span class=c1>#请求客户端，浏览器版本</span>
</span></span><span class=line><span class=cl>Accept: text/html,application/xhtml+xml,application/xml<span class=p>;</span><span class=nv>q</span><span class=o>=</span>0.9,image/webp,image/apng,*/*<span class=p>;</span><span class=nv>q</span><span class=o>=</span>0.8
</span></span><span class=line><span class=cl><span class=c1>#支持的响应内容类型</span>
</span></span><span class=line><span class=cl>Accept-Encoding: gzip, deflate, br
</span></span><span class=line><span class=cl><span class=c1>#支持的编码类型</span>
</span></span><span class=line><span class=cl>Accept-Language: zh-CN,zh<span class=p>;</span><span class=nv>q</span><span class=o>=</span>0.9,en<span class=p>;</span><span class=nv>q</span><span class=o>=</span>0.8
</span></span><span class=line><span class=cl><span class=c1>#支持的语言</span>
</span></span><span class=line><span class=cl>Cookie: <span class=nv>BAIDUID</span><span class=o>=</span>C0A2...
</span></span><span class=line><span class=cl><span class=c1>#携带的cookie信息</span>
</span></span><span class=line><span class=cl><span class=c1>#未携带请求消息体，body为空</span>
</span></span></code></pre></td></tr></table></div></div><p>服务器接收并处理客户端发过来的请求，返回一个HTTP的响应消息。也由四个部分组成，分别是：</p><p><strong>响应状态行、消息报头、空行和响应正文</strong>。 如图</p><p><img src=/frontEndDemo/images/20181222_163802.png loading=lazy alt=image></p><p>如下是百度首页的响应示例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>HTTP/1.1 <span class=m>200</span> OK
</span></span><span class=line><span class=cl><span class=c1>#协议版本 消息状态码 状态描述</span>
</span></span><span class=line><span class=cl>Bdpagetype: <span class=m>2</span>
</span></span><span class=line><span class=cl>Bdqid: 0x8707d7d80001f34e
</span></span><span class=line><span class=cl><span class=c1>#自定义消息头</span>
</span></span><span class=line><span class=cl>Cache-Control: private
</span></span><span class=line><span class=cl><span class=c1>#缓存控制策略</span>
</span></span><span class=line><span class=cl>Connection: Keep-Alive
</span></span><span class=line><span class=cl><span class=c1>#长连接</span>
</span></span><span class=line><span class=cl>Content-Type: text/html<span class=p>;</span><span class=nv>charset</span><span class=o>=</span>utf-8
</span></span><span class=line><span class=cl><span class=c1>#响应内容类型</span>
</span></span><span class=line><span class=cl>Date: Sat, <span class=m>22</span> Dec <span class=m>2018</span> 08:54:51 GMT
</span></span><span class=line><span class=cl><span class=c1>#响应时间</span>
</span></span><span class=line><span class=cl>Expires: Sat, <span class=m>22</span> Dec <span class=m>2018</span> 08:54:51 GMT
</span></span><span class=line><span class=cl><span class=c1>#过期失效时间</span>
</span></span><span class=line><span class=cl>Server: BWS/1.1
</span></span><span class=line><span class=cl><span class=c1>#服务器系统及版本</span>
</span></span><span class=line><span class=cl>Set-Cookie: <span class=nv>BDSVRTM</span><span class=o>=</span>372<span class=p>;</span> <span class=nv>path</span><span class=o>=</span>/
</span></span><span class=line><span class=cl>Set-Cookie: <span class=nv>BD_HOME</span><span class=o>=</span>1<span class=p>;</span> <span class=nv>path</span><span class=o>=</span>/
</span></span><span class=line><span class=cl>Set-Cookie: <span class=nv>path</span><span class=o>=</span>/<span class=p>;</span> <span class=nv>domain</span><span class=o>=</span>.baidu.com
</span></span><span class=line><span class=cl><span class=c1>#设置客户端cookie</span>
</span></span><span class=line><span class=cl>Strict-Transport-Security: max-age<span class=o>=</span><span class=m>172800</span>
</span></span><span class=line><span class=cl><span class=c1>#严格安全传输，有效时间</span>
</span></span><span class=line><span class=cl>X-Ua-Compatible: <span class=nv>IE</span><span class=o>=</span>Edge,chrome<span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1>#兼容浏览器版本</span>
</span></span><span class=line><span class=cl>Content-Length: <span class=m>191722</span>
</span></span><span class=line><span class=cl><span class=c1>#消息体长度</span>
</span></span><span class=line><span class=cl><span class=c1>#以下消息体内容</span>
</span></span><span class=line><span class=cl>&lt;!Doctype html&gt;
</span></span><span class=line><span class=cl>&lt;html <span class=nv>xmlns</span><span class=o>=</span>http://www.w3.org/1999/xhtml&gt;&lt;head&gt;
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><h4 id=http方法>HTTP方法</h4><p>HTTP方法是请求消息中携带的关键信息，告知服务器本次请求希望进行的操作类型。目前在HTTP1.1版本中常见以下方法</p><div class=table-wrapper><table><thead><tr><th style=text-align:center>No.</th><th style=text-align:center>方法</th><th>描述</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>GET</td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>HEAD</td><td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>DELETE</td><td>请求服务器删除指定的页面。</td></tr><tr><td style=text-align:center>6</td><td style=text-align:center>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td style=text-align:center>7</td><td style=text-align:center>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td style=text-align:center>8</td><td style=text-align:center>PATCH</td><td>从客户端向服务器传送数据，取代指定文档的部分内容</td></tr></tbody></table></div><h4 id=http状态码>HTTP状态码</h4><p>HTTP状态码定义了服务器端处理HTTP请求的结果信息，主要包含以下五类：</p><div class=table-wrapper><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>1XX</td><td>已接收，待处理</td></tr><tr><td>2XX</td><td>请求处理成功</td></tr><tr><td>3XX</td><td>重定向，资源位置发生变化</td></tr><tr><td>4XX</td><td>客户端请求信息错误</td></tr><tr><td>5XX</td><td>服务端处理发生错误</td></tr></tbody></table></div><h5 id=1xx-消息><strong>1xx 消息</strong></h5><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。[4] 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p><h5 id=2xx-成功><strong>2xx 成功</strong></h5><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p><h5 id=3xx-重定向><strong>3xx 重定向</strong></h5><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</p><h5 id=4xx-客户端错误><strong>4xx 客户端错误</strong></h5><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容</p><h5 id=5xx-服务器错误><strong>5xx 服务器错误</strong></h5><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。</p><p><em>详细的状态码清单可参见附录</em></p><h3 id=github-api>GitHub API</h3><p>本教程后续将主要使用Github API作为实战介绍API。 本章会简要介绍Github网站以及Github API。</p><p>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。也是目前全球最大的代码托管平台，可以说是程序员的圣地，号称全球最大的同性交友平台:joy:
(Github 国内有时会间歇性无法访问，可能需要科学上网)</p><h4 id=github-中的一些主要概念>github 中的一些主要概念</h4><ol><li><strong>提交（commit）</strong>：提交更改到仓库（本地Git仓库与GitHub仓库是两码事）。</li><li><strong>提交信息（commit message）</strong>：每次提交的时候，需要提供一个信息，描述这次提交都做了什么。</li><li><strong>分支（branch）</strong>：像树状图一样，每个独立的分支都是项目的一个版本，分支都可以与master合并。</li><li><strong>主分支（master branch）</strong>：所有的Git项目在最初创建时，都会默认创建出一个分支，这就是主分支。在开发中，写一个新功能的时候，都是先建立一个分支，在该分支上完成功能并测试，通过后由项目leader将该分支merge到master上。</li><li><strong>功能分支（feature branch）</strong>：没怎么用过</li><li><strong>发布分支（release branch）</strong>：如果有一个手动QA（质量管理）流程，或者必须要支持旧版本的软件时，需要一个发布分支来存放必要的补丁与更新记录。功能分支和发布分支没技术区别，只是在团队间讨论的时候，有助于区分类别。</li><li><strong>合并（merge）</strong>：merge可以将一个分支上的全部内容归并到另一个分支上，一般就是将分支merge到主分支。</li><li><strong>标签（tag）</strong>：常用于记录发布版本，在版本发布的时候，给一个tag，这样就能够记录该版本的代码是何时生成的。</li><li><strong>查看（check out）</strong>：一般就是查看某一个分支上操作的记录。</li><li><strong>拉取（pull request）</strong>：一般用来从远程仓库拉取分支中的代码到本地，也可以从本地仓库中拉取分支代码到当前工程中。</li><li><strong>提出问题（issue）</strong>：GitHub的提出问题的功能，一般遇到问题，可以将出现问题的场合，通过issue的方式记录。</li><li><strong>维基（WIKI）</strong>：一个轻量级的Web页面创建方式，创建的Web页面之间可以通过链接互相联系。GitHub中的项目通常使用WIKi进行文档记录。</li><li><strong>克隆（clone）</strong>：从GitHub上下载一个副本到本地，操作后可以pull上去。</li><li><strong>分叉（fork）</strong>：A复制一个B的项目到自己的账户下，修改后再提交，B能看到A修改的内容，但是B原本的项目是不会有变动的。</li></ol><h4 id=github-主界面功能>github 主界面功能</h4><p><img src=/frontEndDemo/images/20181225_203928.png loading=lazy alt=image>
<a class=link href=http://blog.csdn.net/android_zyf/article/details/64175941 target=_blank rel=noopener>图片转自george_zyf的博客</a></p><h4 id=github-api-1>Github API</h4><p>目前Github API最新的V4版本是基于GraphQL的API，但常用的还是V3的<a class=link href=https://developer.github.com/v3/ target=_blank rel=noopener>Restful API</a></p><h5 id=github-api中几类主要资源及对应操作><strong>github API中几类主要资源及对应操作</strong></h5><p>User 资源</p><p><img src=/frontEndDemo/images/20181225_200328.png loading=lazy alt=user></p><p>Repo 操作</p><p><img src=/frontEndDemo/images/20181225_200253.png loading=lazy alt=repos></p><p>issue 操作</p><p><img src=/frontEndDemo/images/20181225_200314.png loading=lazy alt=issues></p><p><em>图片来自<a class=link href=https://blog.csdn.net/woshinannan741/article/details/78541029 target=_blank rel=noopener>网络</a></em></p><h5 id=github-中的时间格式><strong>github 中的时间格式</strong></h5><p>github 中时间格式如下：</p><blockquote><p>YYYY-MM-DDTHH:MM:SSZ</p></blockquote><h5 id=github-限流规则><strong>github 限流规则</strong></h5><p>github 为包含服务端负载压力，会对请求流量进行限制。在每个 github 的响应消息头中都会携带 github 的限流设置。</p><div class=table-wrapper><table><thead><tr><th>头参数</th><th>含义</th></tr></thead><tbody><tr><td>X-RateLimit-Limit</td><td>当前每小时最大请求限制，一般未鉴权请求60次，鉴权请求5000次</td></tr><tr><td>X-RateLimit-Remaining</td><td>当前剩余请求次数</td></tr><tr><td>X-RateLimit-Reset</td><td>剩余限制重置时间，毫秒</td></tr></tbody></table></div><h5 id=请求参数与分页><strong>请求参数与分页</strong></h5><p>请求中可以携带参数，一般包含两种参数: <strong>路径参数</strong>和<strong>查询参数</strong>
<img src=/frontEndDemo/images/20190119_121133.png loading=lazy alt=image></p><p>github API中默认支持两个分页参数：</p><ul><li>page 当前显示页数</li><li>per_page 每页显示结果数</li></ul><h3 id=postman-基础>Postman 基础</h3><p>可以用于Rest接口测试的测试工具非常多，常见的有soapUI、Jmeter、fiddler等都经常用来做接口测试。但是目前在接口测试人员中最流行，最常见还是本章向大家介绍的Postman。</p><h4 id=postman-的安装>Postman 的安装</h4><p>Postman最早的版本，以及很长一段时间都是以Chrome插件的形式存在的。以至很多人甚至认为postman就是google的官方工具插件，我们目前能看到的大量资料也都是基于chrome的插件形式来进行介绍的。</p><p>但是目前Postman其实已经推出了独立的本地App程序，并且官方已经宣布不再支持chrome的插件形式。虽然插件版本现在还能使用，可是毕竟相比Native版本，受限于chrome浏览器的功能，很多功能在插件版本中是欠缺的，比如cookie的内建支持，代理功能，控制台功能等等。所以此处就不再介绍插件版本的安装。</p><p>本地版本的安装，其实也非常简单。从官网根据自己操作系统的类型选择相应的版本下载即可。
<img src=/frontEndDemo/images/20181225_210709.png loading=lazy alt=image></p><p>这里还有一点要注意下，在postman的官网，我们最好注册一个账号，后续在使用postman的时候很多高级功能需要用这个账号登录后才可以使用。</p><img src=https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210848.png width=320 height=450><p>安装完成，在桌面上出现Postman那个pose很帅的小人图标<img src=https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_211842.png width=30 height=33>，则安装完成。</p><h4 id=postman-主界面>Postman 主界面</h4><p>打开Postman进入，首次会提示选择希望创建的任务类型。</p><p><img src=/frontEndDemo/images/20181225_212729.png loading=lazy alt=image>
这里有六种任务类型，我们再下面的实战中都会详细讲解，这里先简单说明一下：</p><ul><li><strong>Request</strong>是Postman软件的基础和核心，也就是通过这个功能来创建request请求，完成接口测试的核心工作。</li><li><strong>Collection</strong>其实是个集合，我们可以认为是一批Request请求的集合，或者说测试集。它也是Postman一些进阶功能的基本单位</li><li><strong>Environment</strong>，字面理解就是环境，其实可以认为是一些配置变量的集合，实际应用中可以起到通过不同配置区分不同测试环境的效果
后面这三个都是Postman的高级功能</li><li><strong>API documention</strong>，是通过我们调试通过的request来自动生成接口文档，便于团队的共享和接口的交付。</li><li><strong>Mock server</strong>
在我们进行接口测试或开发的时候，很多时候是需要模拟对端的接口服务器的，Mock server就起到的模拟服务器端的作用。</li><li><strong>Monitor</strong>
这是个监控功能，通过monitor我可以监控我的接口是不是正常。说白了，这其实就是个定时的接口执行功能。</li></ul><p>大致了解下几种不同的任务类型，我们先关掉这个界面，我们再来看看主界面的功能区间
<img src=/frontEndDemo/images/20181225_221026.png loading=lazy alt=image></p><h5 id=banner-区域><strong>Banner 区域</strong></h5><p>首先是上面的菜单栏，对应功能区的各项功能，在菜单栏上都能找到对应的菜单。然后是下面的banner区域。
从左到右依次介绍：</p><p><img src=/frontEndDemo/images/20181225_213611.png loading=lazy alt=image>会打开启动时的创建窗口，用于创建六种类型的任务。</p><p><img src=/frontEndDemo/images/20181225_213722.png loading=lazy alt=image>按钮，可以用于导入外部文件，外部文件可以是postman的Collection格式文件，数据文件，以及其他的API定义文件</p><p><img src=/frontEndDemo/images/20181225_213808.png loading=lazy alt=image>则会启动Collection runner，它是一个运行器，用于运行已经建立的测试任务。我们后面会有详细介绍</p><p><img src=/frontEndDemo/images/20181225_213839.png loading=lazy alt=image>第四个按钮，可以新建tab，或者多开一个postman程序，或者runer程序。</p><p>中间<img src=/frontEndDemo/images/20181225_214059.png loading=lazy alt=image>是选择使用的workspace，但这个需要账号登录，会同步云端的workspace设置。每个账号会有一个默认的workspace，workspace它是一个工作空间，大家可以理解成类似项目或者工程。</p><p>banner条右侧还有几个按钮<img src=/frontEndDemo/images/20181225_214216.png loading=lazy alt=image></p><ul><li>第一个是同步，也是在有账号的情况下，可以在多个电脑间同步workspace内的相关接口测试设计。</li><li>第二个proxy，则类似前面介绍过的fiddler，提供代理抓取API功能。当然这个功能postman不像Fiddler那样丰富</li><li>第三个按钮包括setting以及文档指南。 setting里是软件的本地配置</li><li>第四个按钮是消息通知，很好理解，会显示一些提醒信息</li><li>然后是postman的twitter，在墙后面就不要去看了</li><li>最后是登录，可以用postman的账号的登录</li></ul><h5 id=setting-设置><strong>Setting 设置</strong></h5><p>Postman 工具的使用属性和应用设置我们可以在Setting 中国进行设置。以下分别说明：</p><h6 id=general><strong>General</strong></h6><p><img src=/frontEndDemo/images/20190119_113726.png loading=lazy alt=image></p><h6 id=themes><strong>Themes</strong></h6><p><img src=/frontEndDemo/images/20190119_113828.png loading=lazy alt=image></p><h6 id=shortcuts><strong>Shortcuts</strong></h6><p>工具快捷键
<img src=/frontEndDemo/images/20190119_113904.png loading=lazy alt=image></p><h6 id=data><strong>Data</strong></h6><p>工具数据导入导出
<img src=/frontEndDemo/images/20190119_114000.png loading=lazy alt=image></p><h6 id=add-ons><strong>add-ons</strong></h6><p>Newman 插件下载方法
<img src=/frontEndDemo/images/20190119_114231.png loading=lazy alt=image></p><h6 id=sync><strong>Sync</strong></h6><p>同步设置
<img src=/frontEndDemo/images/20190119_114249.png loading=lazy alt=image></p><h6 id=certificates><strong>certificates</strong></h6><p>本地证书设置
<img src=/frontEndDemo/images/20190119_114304.png loading=lazy alt=image></p><h6 id=proxy><strong>Proxy</strong></h6><p>本地网络代理设置
<img src=/frontEndDemo/images/20190119_114316.png loading=lazy alt=image></p><h6 id=update><strong>update</strong></h6><p>升级设置
<img src=/frontEndDemo/images/20190119_114330.png loading=lazy alt=image></p><h6 id=about><strong>about</strong></h6><p>工具**关于&mldr;**等版本信息
<img src=/frontEndDemo/images/20190119_114343.png loading=lazy alt=image></p><h5 id=左侧边栏><strong>左侧边栏</strong></h5><p><img src=/frontEndDemo/images/20181225_215120.png loading=lazy alt=image></p><ul><li>filter筛选栏，筛选显示不同的消息</li><li>history是操作消息记录清单</li><li>collection如前面介绍，显示请求集合</li></ul><h5 id=底边状态栏><strong>底边状态栏</strong></h5><p><img src=/frontEndDemo/images/20181225_215400.png loading=lazy alt=image></p><ul><li>最左面，显示和关闭左侧边栏</li><li>然后是搜索功能，这个容易理解</li><li>第三个是控制台，可以在这里看到消息相互的详细信息</li></ul><p><img src=/frontEndDemo/images/20181225_215445.png loading=lazy alt=image></p><ul><li>用户指南</li><li>调整功能区显示样式</li><li>快捷键清单参考</li><li>帮助相关的连接</li></ul><h5 id=主功能区><strong>主功能区</strong></h5><p><img src=/frontEndDemo/images/20181225_215313.png loading=lazy alt=image></p><p>主要包括上下两部分，上面是request区，下面是response区。也可以分成左右显示。</p><h6 id=request区域><strong>Request区域</strong></h6><p><img src=/frontEndDemo/images/20181225_221203.png loading=lazy alt=image></p><p>request部分默认开启了一个选项卡，可以新开多个选项卡便于同时编辑。</p><p><img src=/frontEndDemo/images/20181225_221316.png loading=lazy alt=image></p><p>默认使用的是GET方法，这也是使用最多的HTTP方法，下拉可以选择其他的方法，常用的还有哪些？ POST、PUT、Delete等。</p><p><img src=/frontEndDemo/images/20181225_221359.png loading=lazy alt=image>
URL部分输入请求的地址。比如我们输入GithubAPI的根地址。</p><p><img src=/frontEndDemo/images/20181225_221529.png loading=lazy alt=image>
param是参数管理界面，在这里我们可以添加参数（有key-value，块编辑模式）。</p><p><img src=/frontEndDemo/images/20181225_221557.png loading=lazy alt=image></p><p>Send发送请求，小箭头下send and download，会在发送以后把响应消息导出成json保存。旁边的save，保存功能，其实是把这个request作为一个case保存到collection里。</p><p><img src=/frontEndDemo/images/20181225_221704.png loading=lazy alt=image></p><p>鉴权部分，虽然request编辑器已经足够强大可以处理鉴权消息，但是很多时候鉴权是个使用频率很高的功能，所以Postman单独把鉴权部分抽取出来，并且封装了目前的绝大部分鉴权方式</p><ul><li><strong>继承</strong>，默认鉴权方式</li><li><strong>不鉴权</strong></li><li><strong>bearer token</strong>鉴权，一般也叫Json web token，其实就是发送一个json格式的token令牌，服务端会针对token进行解密验证</li><li><strong>Basic Auth</strong>基础验证，提供用户名密码验证，postman 会自动生成authorization，常用鉴权方式</li><li><strong>digest auth</strong>，摘要式认证
在基本身份认证上面扩展了安全性，服务器为每一个连接生成一个唯一的随机数，客户端用这个随机数对密码进行MD5加密，然后返回服务器，服务器也用这个随机数对密码进行加密，然后和客户端传送过来的加密数据进行比较,如果一致就返回结果。
它是一个二次验证的过程，会有两次认证交互消息
客户端请求资源->服务器返回认证标示->客户端发送认证信息->服务器查验认证</li><li><strong>Oauth</strong>，一般用于第三方认证，有1,2两个版本，需要提供的信息不太一样。也是常用的鉴权方式</li><li><strong>Hawk</strong> 认证，是另一种认证方案，采用的叫消息码认证算法，和Digest认证类似，它也是需要二次交互的</li><li><strong>AWS签名</strong>认证，是针对亚马逊的AWS公有云用户签名的认证方式</li><li><strong>NTLM</strong>是微软的局域网管理认证协议</li></ul><p>大家有个基本了解即可，一般比较常用的就是basic以及OAuth2了。</p><p><img src=/frontEndDemo/images/20181225_221901.png loading=lazy alt=image></p><p>header就是消息头管理，可以定义头部信息。</p><p><img src=/frontEndDemo/images/20181225_221935.png loading=lazy alt=image>
Body，请求消息体。一般Post、put、patch等会更新内容的请求才会携带消息体，</p><p><img src=/frontEndDemo/images/20181225_222023.png loading=lazy alt=image></p><p>旁边pre-script，是指在请求发送前，可以做一些预处理的工作，类似junit等单元测试框架中的setup方法，支持js脚本语法</p><p><img src=/frontEndDemo/images/20181225_222100.png loading=lazy alt=image>
Test则是在响应以后，对响应进行校验或其他处理的，类似junit框架中的teardown方法，同样支持js脚本语法</p><p><img src=/frontEndDemo/images/20181225_222148.png loading=lazy alt=image></p><p>cookie管理postman本地cookie信息</p><p><img src=/frontEndDemo/images/20181225_222218.png loading=lazy alt=image>
code是一个方便程序员的功能，可以自动将接口请求转化成相关语言编码，可以看到支持的语言非常丰富，基本涵盖了各种主流编程语言。</p><h6 id=response区域><strong>Response区域</strong></h6><p><img src=/frontEndDemo/images/20181225_222427.png loading=lazy alt=image></p><p>响应消息右上角是状态码，悬停可以看到详细解释。另外是响应时间（从发出请求到返回客户端接收的时间），以及消息大小（含消息头和消息体）。</p><p><img src=/frontEndDemo/images/20190102_203757.png loading=lazy alt=image>
响应body部分，即消息体。包括以下几个按钮</p><ul><li>pretty，可以根据表现类型进行格式化显示，默认json，如果是其他格式类型，可以选择对应形式进行格式化。</li><li>Raw则是未格式化的形式</li><li>preview则是预览，就是在浏览器里渲染后呈现的样子，比如返回的是html就很直观。</li><li>旁边是自动换行按钮。</li></ul><img src=https://chengxiaqiucao.github.io/frontEndDemo/images/20190102_203931.png width=300 height=83><p>右边是拷贝到剪切板和查询按钮（正则，大小写敏感、全词匹配）</p><p>其他的几个tab：</p><ul><li>cookie：响应消息的cookie信息</li><li>header：响应消息的header头部信息</li><li>Test Results：在请求中添加test Script后，这里会显示测试脚本的校验结果</li></ul><h4 id=postman中完成github鉴权><strong>Postman中完成Github鉴权</strong></h4><p>从Github API文档中，我们可以看到Github API支持多种鉴权方式</p><ul><li>Basic authentication</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>curl -u &#34;username&#34; https://api.github.com
</span></span></code></pre></td></tr></table></div></div><p>这是基本鉴权方式</p><ul><li>OAuth2 token (sent in a header)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>curl -H &#34;Authorization: token OAUTH-TOKEN&#34; https://api.github.com
</span></span></code></pre></td></tr></table></div></div><p>也支持通过在Header中携带Oauth2的token进行鉴权。在github用户设置中可以生成这个token。</p><p><strong>个人设置 > Settings > Developer settings > Personal access tokens</strong>
<img src=/frontEndDemo/images/20190103_221722.png loading=lazy alt=image>
生成后会获得一个token字串
<img src=/frontEndDemo/images/20190103_221844.png loading=lazy alt=image></p><ul><li>OAuth2 token (sent as a parameter)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>curl https://api.github.com/?access_token=OAUTH-TOKEN
</span></span></code></pre></td></tr></table></div></div><p>或者通过在URL中携带token参数鉴权。</p><p>Postman中，可以在Collection中设置鉴权
<img src=/frontEndDemo/images/20190103_222236.png loading=lazy alt=image>
在具体的请求消息中，可以选择<strong>Inherit auth from parent</strong>，即继承上一层的鉴权。发送请求后，可以看到已经在header中携带了鉴权的token信息
<img src=/frontEndDemo/images/20190103_222500.png loading=lazy alt=image></p><p>根据<a class=link href=https://developer.github.com/v3/#rate-limiting target=_blank rel=noopener>Github API的定义</a>，对于请求有访问限制，即未鉴权的请求限制访问为每分钟60次，对于已鉴权的请求访问每分钟5000次。</p><p>我们从响应消息的消息头中可以看到这个设置，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>X-RateLimit-Limit →5000
</span></span><span class=line><span class=cl>X-RateLimit-Remaining →4999
</span></span><span class=line><span class=cl>X-RateLimit-Reset →1546528838
</span></span></code></pre></td></tr></table></div></div><h4 id=postman实现基本http方法>Postman实现基本HTTP方法</h4><p>再来看如何在Postman中实现常用的HTTP方法。还是以GithubAPI为例：</p><h5 id=get方法---获取repo信息><strong>GET方法 - 获取Repo信息</strong></h5><blockquote><p>GET /repos/:owner/:repo</p></blockquote><p>这里是<a class=link href=https://developer.github.com/v3/repos/#get target=_blank rel=noopener>获取Github上Repo信息的API</a>，这里有两个路径参数，owner代表用户账号，repo指需要获取的repo信息。
如图是在postman中设置路径参数的方法。
<img src=/frontEndDemo/images/20190103_223645.png loading=lazy alt=image></p><h5 id=post方法---创建repo><strong>POST方法 - 创建Repo</strong></h5><p>创建Repo的示例(<a class=link href=https://developer.github.com/v3/repos/#create target=_blank rel=noopener>https://developer.github.com/v3/repos/#create</a>)</p><blockquote><p>POST /user/repos</p></blockquote><p>这里是一个创建hello world的Repo的请求消息体示例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;Hello-World&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;description&#34;</span><span class=p>:</span> <span class=s2>&#34;This is your first repository&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;homepage&#34;</span><span class=p>:</span> <span class=s2>&#34;https://github.com&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;private&#34;</span><span class=p>:</span> <span class=kc>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;has_issues&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;has_projects&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;has_wiki&#34;</span><span class=p>:</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里name是必填字段，其他是repo的属性设置。
在Postman中如图提交，返回状态码201 created，即可创建一个Hello world的Repo
<img src=/frontEndDemo/images/20190103_225411.png loading=lazy alt=image></p><p>在Github中，可以看到账号下新增了一个hello world的repo，并且包含有已设置的issue、projects、wiki这几个栏目
<img src=/frontEndDemo/images/20190103_225748.png loading=lazy alt=image></p><h5 id=patch方法---修改repo><strong>PATCH方法 - 修改Repo</strong></h5><p>GitHub可以<a class=link href=https://developer.github.com/v3/repos/#edit target=_blank rel=noopener>通过PATCH方法来对Repo进行修改</a>.PATCH方法和PUT方法都是update的修改方法，但PATCH方法更多用在部分修改的场景下，PUT方法则更多是整体替换。</p><blockquote><p>PATCH /repos/:owner/:repo</p></blockquote><p>比如上例中hello world这个repo修改Repo中的部分信息，可以去除projects和wiki这两个栏目
消息体：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;Hello-World&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;description&#34;</span><span class=p>:</span> <span class=s2>&#34;This is your first repository&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;homepage&#34;</span><span class=p>:</span> <span class=s2>&#34;https://github.com&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;has_projects&#34;</span><span class=p>:</span> <span class=kc>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;has_wiki&#34;</span><span class=p>:</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Postman中如图：
<img src=/frontEndDemo/images/20190103_230702.png loading=lazy alt=image></p><p>回到Github，可以看到Repo中对应的栏目已经不见了
<img src=/frontEndDemo/images/20190103_230752.png loading=lazy alt=image></p><h5 id=put方法---设置或替换topic><strong>PUT方法 - 设置或替换Topic</strong></h5><p>Topic是Github上Repo的搜索关键字，便于用户进行repo查询。</p><blockquote><p>PUT /repos/:owner/:repo/topics</p></blockquote><p>Github API设置topic的api是使用put方法提交一个topic数组，如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;names&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;restapi&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;atom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;chengxiaqiucao&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这时在Postman中提交，会发现有如下报错：
<img src=/frontEndDemo/images/20190106_151630.png loading=lazy alt=image></p><p>这是因为Github API要求设置topic时，需要在header中设置accept字段,取值：</p><blockquote><p>application/vnd.github.mercy-preview+json</p></blockquote><p>正确设置后，则可以看到设置成功,返回200 OK
<img src=/frontEndDemo/images/20190106_151935.png loading=lazy alt=image></p><p><img src=/frontEndDemo/images/20190106_152005.png loading=lazy alt=image></p><p>大家可能会发现一个小bug，当设置的topic存在大写字符时，会出现格式报错。比如大家参照官方示例设置"API"这样的topic，会发现设置不成功。大家可以尝试一下。</p><h5 id=delete方法---删除repo><strong>DELETE方法 - 删除Repo</strong></h5><p>Github API中，使用delete方法可以删除repo</p><blockquote><p>DELETE /repos/:owner/:repo</p></blockquote><p>删除成功后，返回204.
<img src=/frontEndDemo/images/20190106_152302.png loading=lazy alt=image>
此时再查询账号，应该发现Hello-World这个repo已经被删除了</p><h4 id=结语及预告>结语及预告</h4><p>至此，我们通过Github API中几个实际的例子，学习了如何通过Postman来完成一些基本的HTTP方法的请求发送和响应查看，通过查看结果状态码或响应内容来判断结果正确性。</p><p>当然Postman的功能远不止于此，API接口测试中也还有很多复杂的场景需要特别处理。
欢迎大家继续关注 <strong>《玩转Postman - 进阶篇》</strong>。在进阶篇中我们将继续深入讲解Postman的进阶功能，并结合一些复杂的实例场景来学习：</p><ul><li>Postman 的变量类型及其作用域</li><li>环境与 Collection;</li><li>Postman 如何通过内建脚本实现接口预处理</li><li>Postman 实现测试结果的脚本校验；</li><li>如何实现接口的关联测试</li><li>Postman 中的 JavaScript 扩展</li></ul><h3 id=附录>附录</h3><p>HTTP状态码详解（译自Wiki百科，目前所见最全面的解释）
<img src=C:/Backup/Dan/Blog/blog_images/20230617_090217.png loading=lazy alt=image></p><h3 id=1xx-消息-1>1xx 消息</h3><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。[4] 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p><h6 id=100-continue><strong>100 Continue</strong></h6><p>服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送Expect: 100-continue作为头部，并在发送正文之前接收100 Continue状态代码。响应代码417期望失败表示请求不应继续。</p><h5 id=101-switching-protocols><strong>101 Switching Protocols</strong></h5><p>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。
只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如WebSocket）以传送利用此类特性的资源。</p><h5 id=102-processingwebdavrfc-2518><strong>102 Processing（WebDAV；RFC 2518）</strong></h5><p>WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。[6]这样可以防止客户端超时，并假设请求丢失。</p><h4 id=2xx-成功-1>2xx 成功</h4><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p><h5 id=200-ok><strong>200 OK</strong></h5><p>请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。</p><h5 id=201-created><strong>201 Created</strong></h5><p>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回'202 Accepted&rsquo;。</p><h5 id=202-accepted><strong>202 Accepted</strong></h5><p>服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。</p><h5 id=203-non-authoritative-information自http--11起><strong>203 Non-Authoritative Information（自HTTP / 1.1起）</strong></h5><p>服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以200 OK状态码为起源，但回应了原始响应的修改版本。</p><h5 id=204-no-content><strong>204 No Content</strong></h5><p>服务器成功处理了请求，没有返回任何内容。</p><h5 id=205-reset-content><strong>205 Reset Content</strong></h5><p>服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。</p><h5 id=206-partial-contentrfc-7233><strong>206 Partial Content（RFC 7233）</strong></h5><p>服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p><h5 id=207-multi-statuswebdavrfc-4918><strong>207 Multi-Status（WebDAV；RFC 4918）</strong></h5><p>代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p><h5 id=208-already-reported-webdavrfc-5842><strong>208 Already Reported （WebDAV；RFC 5842）</strong></h5><p>DAV绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。</p><h5 id=226-im-used-rfc-3229><strong>226 IM Used （RFC 3229）</strong></h5><p>服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。</p><h4 id=3xx-重定向-1>3xx 重定向</h4><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</p><p>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。</p><h5 id=300-multiple-choices><strong>300 Multiple Choices</strong></h5><p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。
除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。
如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</p><h5 id=301-moved-permanently><strong>301 Moved Permanently</strong></h5><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。
如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</p><h5 id=302-found><strong>302 Found</strong></h5><p>要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。
如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p><h5 id=303-see-other><strong>303 See Other</strong></h5><p>对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。[23]这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。
新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。
注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p><h5 id=304-not-modified><strong>304 Not Modified</strong></h5><p>表示资源未被修改，因为请求头指定的版本If-Modified-Since或If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</p><h5 id=305-use-proxy><strong>305 Use Proxy</strong></h5><p>被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。许多HTTP客户端（像是Mozilla和Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。
注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</p><h5 id=306-switch-proxy><strong>306 Switch Proxy</strong></h5><p>在最新版的规范中，306状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。</p><h5 id=307-temporary-redirect><strong>307 Temporary Redirect</strong></h5><p>在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。</p><h5 id=308-permanent-redirect-rfc-7538><strong>308 Permanent Redirect (RFC 7538)</strong></h5><p>请求和所有将来的请求应该使用另一个URI重复。 307和308重复302和301的行为，但不允许HTTP方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。</p><h4 id=4xx-客户端错误-1>4xx 客户端错误</h4><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。[30]</p><p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p><h5 id=400-bad-request><strong>400 Bad Request</strong></h5><p>由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。</p><h5 id=401-unauthorizedrfc-7235><strong>401 Unauthorized（RFC 7235）</strong></h5><p>参见：HTTP基本认证、HTTP摘要认证
类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。
注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。</p><h5 id=402-payment-required><strong>402 Payment Required</strong></h5><p>该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。</p><h5 id=403-forbidden><strong>403 Forbidden</strong></h5><p>主条目：HTTP 403
服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</p><h5 id=404-not-found><strong>404 Not Found</strong></h5><p>主条目：HTTP 404
请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。[35]没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p><h5 id=405-method-not-allowed><strong>405 Method Not Allowed</strong></h5><p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过POST呈现数据的表单上的GET请求，或只读资源上的PUT请求。
鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p><h5 id=406-not-acceptable><strong>406 Not Acceptable</strong></h5><p>参见：内容协商
请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。[36]
除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p><h5 id=407-proxy-authentication-requiredrfc-2617><strong>407 Proxy Authentication Required（RFC 2617）</strong></h5><p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。[37]代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。</p><h5 id=408-request-timeout><strong>408 Request Timeout</strong></h5><p>请求超时。根据HTTP规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。</p><h5 id=409-conflict><strong>409 Conflict</strong></h5><p>表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。</p><h5 id=410-gone><strong>410 Gone</strong></h5><p>表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到410状态码后，用户应停止再次请求资源。但大多数服务端不会使用此状态码，而是直接使用404状态码。</p><h5 id=411-length-required><strong>411 Length Required</strong></h5><p>服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。</p><h5 id=412-precondition-failedrfc-7232><strong>412 Precondition Failed（RFC 7232）</strong></h5><p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p><h5 id=413-request-entity-too-largerfc-7231><strong>413 Request Entity Too Large（RFC 7231）</strong></h5><p>前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。
如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。</p><h5 id=414-request-uri-too-longrfc-7231><strong>414 Request-URI Too Long（RFC 7231）</strong></h5><p>前称“Request-URI Too Long”，表示请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为GET请求的查询字符串，在这种情况下，应将其转换为POST请求。这比较少见，通常的情况包括：
本应使用POST方法的表单提交变成了GET方法，导致查询字符串过长。
重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。
客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回414状态码。</p><h5 id=415-unsupported-media-type><strong>415 Unsupported Media Type</strong></h5><p>对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为svg，但服务器要求图像使用上传格式为jpg。</p><h5 id=416-requested-range-not-satisfiablerfc-7233><strong>416 Requested Range Not Satisfiable（RFC 7233）</strong></h5><p>前称“Requested Range Not Satisfiable”。客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。</p><h5 id=417-expectation-failed><strong>417 Expectation Failed</strong></h5><p>在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。</p><h5 id=418-i><strong>418 I&rsquo;m a teapot（RFC 2324）</strong></h5><p>本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324超文本咖啡壶控制协议&rsquo;中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的HTCPCP收到BREW或POST指令要求其煮咖啡时应当回传此错误。这个HTTP状态码在某些网站（包括Google.com）与项目（如Node.js、ASP.NET和Go语言）中用作彩蛋。</p><h5 id=420-enhance-your-caim><strong>420 Enhance Your Caim</strong></h5><p>Twitter Search与Trends API在客户端被限速的情况下返回。</p><h5 id=421-misdirected-request-rfc-7540><strong>421 Misdirected Request （RFC 7540）</strong></h5><p>该请求针对的是无法产生响应的服务器（例如因为连接重用）。</p><h5 id=422-unprocessable-entitywebdavrfc-4918-><strong>422 Unprocessable Entity（WebDAV；RFC 4918 ）</strong></h5><p>请求格式正确，但是由于含有语义错误，无法响应。</p><h5 id=423-lockedwebdavrfc-4918><strong>423 Locked（WebDAV；RFC 4918）</strong></h5><p>当前资源被锁定。</p><h5 id=424-failed-dependencywebdavrfc-4918><strong>424 Failed Dependency（WebDAV；RFC 4918）</strong></h5><p>由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。</p><h5 id=425-unordered-collection><strong>425 Unordered Collection</strong></h5><p>在WebDAV Advanced Collections Protocol中定义，但Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol中并不存在。</p><h5 id=426-upgrade-requiredrfc-2817><strong>426 Upgrade Required（RFC 2817）</strong></h5><p>客户端应当切换到TLS/1.0，并在HTTP/1.1 Upgrade header中给出。</p><h5 id=428-precondition-required-rfc-6585><strong>428 Precondition Required (RFC 6585)</strong></h5><p>原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”</p><h5 id=429-too-many-requests-rfc-6585><strong>429 Too Many Requests （RFC 6585）</strong></h5><p>用户在给定的时间内发送了太多的请求。旨在用于网络限速。</p><h5 id=431-request-header-fields-too-large-rfc-6585><strong>431 Request Header Fields Too Large （RFC 6585）</strong></h5><p>服务器不愿处理请求，因为一个或多个头字段过大。</p><h5 id=444-no-response><strong>444 No Response</strong></h5><p>Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。</p><h5 id=450-blocked-by-windows-parental-controls><strong>450 Blocked by Windows Parental Controls</strong></h5><p>这是一个由Windows家庭控制（Microsoft）HTTP阻止的450状态代码的示例，用于信息和测试。</p><h5 id=451-unavailable-for-legal-reasons><strong>451 Unavailable For Legal Reasons</strong></h5><p>该访问因法律的要求而被拒绝，由IETF在2015核准后新增加。</p><h5 id=494-request-header-too-large><strong>494 Request Header Too Large</strong></h5><p>在错误代码431提出之前Nginx上使用的扩展HTTP代码。</p><h4 id=5xx-服务器错误-1>5xx 服务器错误</h4><p>表示服务器无法完成明显有效的请求。[56]这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。</p><h5 id=500-internal-server-error><strong>500 Internal Server Error</strong></h5><p>通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。</p><h5 id=501-not-implemented><strong>501 Not Implemented</strong></h5><p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务API的新功能）</p><h5 id=502-bad-gateway><strong>502 Bad Gateway</strong></h5><p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p><h5 id=503-service-unavailable><strong>503 Service Unavailable</strong></h5><p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。</p><h5 id=504-gateway-timeout><strong>504 Gateway Timeout</strong></h5><p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。
注意：某些代理服务器在DNS查询超时时会返回400或者500错误。</p><h5 id=505-http-version-not-supported><strong>505 HTTP Version Not Supported</strong></h5><p>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。[63]这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p><h5 id=506-variant-also-negotiatesrfc-2295><strong>506 Variant Also Negotiates（RFC 2295）</strong></h5><p>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p><h5 id=507-insufficient-storagewebdavrfc-4918><strong>507 Insufficient Storage（WebDAV；RFC 4918）</strong></h5><p>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。</p><h5 id=508-loop-detected-webdavrfc-5842><strong>508 Loop Detected （WebDAV；RFC 5842）</strong></h5><p>服务器在处理请求时陷入死循环。 （可代替 208状态码）</p><h5 id=510-not-extendedrfc-2774><strong>510 Not Extended（RFC 2774）</strong></h5><p>获取资源所需要的策略并没有被满足。</p><h5 id=511-network-authentication-required-rfc-6585><strong>511 Network Authentication Required （RFC 6585）</strong></h5><p>客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。（例如连接WiFi热点时的强制网络门户）</p><hr><p>秋草的公众号，<strong>秋草说测试</strong>， 欢迎关注</p><p><img src=/post/001-postman-basic/qrcode.jpg width=258 height=258 srcset="/post/001-postman-basic/qrcode_hu_a56c1e278dd59a45.jpg 480w, /post/001-postman-basic/qrcode_hu_96f8d0ff02838f9f.jpg 1024w" loading=lazy alt=秋草说测试 class=gallery-image data-flex-grow=100 data-flex-basis=240px></p></section><footer class=article-footer><section class=article-tags><a href=/tags/postman/>Postman</a>
<a href=/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/>接口测试</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/088-bruno%E5%9F%BA%E7%A1%80/><div class=article-details><h2 class=article-title>Postman最佳平替, API测试工具Bruno实用教程(一)：基础篇</h2></div></a></article><article class=has-image><a href=/post/015-postmanv11%E6%9B%B4%E6%96%B0%E4%BE%BF%E8%A7%88/><div class=article-image><img src=/post/015-postmanv11%E6%9B%B4%E6%96%B0%E4%BE%BF%E8%A7%88/v11-Launch-Blog.a608c30644c420f9807534f7846be2b8_hu_90c53885421b2aff.jpg width=250 height=150 loading=lazy alt="Featured image of post PostmanV11更新便览" data-hash="md5-pgjDBkTEIPmAdTT3hGviuA=="></div><div class=article-details><h2 class=article-title>PostmanV11更新便览</h2></div></a></article><article class=has-image><a href=/post/004-postman-advanced/><div class=article-image><img src=https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png loading=lazy data-key data-hash=https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png></div><div class=article-details><h2 class=article-title>Postman高级篇</h2></div></a></article><article class=has-image><a href=/post/003-postman-automation/><div class=article-image><img src=https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png loading=lazy data-key data-hash=https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png></div><div class=article-details><h2 class=article-title>Postman自动化篇</h2></div></a></article><article class=has-image><a href=/post/002-postman-middle/><div class=article-image><img src=https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png loading=lazy data-key data-hash=https://chengxiaqiucao.github.io/frontEndDemo/images/20181225_210709.png></div><div class=article-details><h2 class=article-title>Postman进阶篇</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2023 -
2025 |by 城下秋草（公众号： 秋草说测试）</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>
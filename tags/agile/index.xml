<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Agile on 秋 草 观 “测” 台</title><link>https://chengxiaqiucao.github.io/tags/agile/</link><description>Recent content in Agile on 秋 草 观 “测” 台</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>|by 城下秋草（公众号： 秋草说测试）</copyright><lastBuildDate>Mon, 09 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://chengxiaqiucao.github.io/tags/agile/index.xml" rel="self" type="application/rss+xml"/><item><title>Scrum敏捷四会 回顾会</title><link>https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/</link><pubDate>Mon, 09 Dec 2024 00:00:00 +0000</pubDate><guid>https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/</guid><description>&lt;img src="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241201.png" alt="Featured image of post Scrum敏捷四会 回顾会" />&lt;p>在前面的分享中，我们已经梳理了计划会、每日站会和复盘会的召开要点，本篇我们再对Scrum敏捷四大仪式中的最后一个会议仪式 - &lt;strong>迭代回顾会&lt;/strong> 进行探讨&lt;/p>
&lt;h2 id="回顾会的目的和作用">回顾会的目的和作用
&lt;/h2>&lt;p>回顾会因为和复盘会一般都放在迭代的最后一天，而且通常安排是相邻在一起的会议，所以很多时候大家会错误地认为这两个会议是同一个敏捷仪式，把这两个会等同起来。&lt;/p>
&lt;p>这个其实是对复盘和回顾这两个不同仪式的错误认识。这两个会议，作用、目的，包括会议的参与人员其实都有明显不同，所以，不能因为这两个仪式时间上比较连贯，就想当然地认为它们是同一个会议。&lt;/p>
&lt;p>复盘会的主要目的是通过对迭代交付物的演示，及时收集产品干系人的反馈和意见，以便确认阶段交付符合预期并对后续迭代进行及时调整。 着眼点是&lt;strong>面向外部的反馈收集，针对产品本身&lt;/strong>&lt;/p>
&lt;p>而回顾会的着眼点在&lt;strong>团队内部的回顾总结，针对流程和团队协作&lt;/strong>。&lt;/p>
&lt;p>所以回顾会的目的是在迭代结束后，再回过头检视迭代的运作，从中总结经验，汲取教训。&lt;/p>
&lt;p>而通过召开回顾会，能产生以下作用：&lt;/p>
&lt;ul>
&lt;li>团队在通过多个迭代去实现产品愿景的同时，也会定期地检视迭代的运作，发现问题，总结经验，及时改进，持续提升。&lt;/li>
&lt;li>团队成员通过回顾会这个窗口，有一个相对正式和公开的平台，都可以提出对团队运作方式的建议或发现可能的问题。&lt;/li>
&lt;li>回顾会也是增进团队凝聚力的一个重要仪式，是团队成员间互相肯定或开诚布公交换意见的一个渠道。&lt;/li>
&lt;/ul>
&lt;p>总之，回顾会可以看作是团队内部的一个闭门会议，是团队自我更新和优化的一个仪式。&lt;/p>
&lt;h2 id="回顾会中的不同角色">回顾会中的不同角色
&lt;/h2>&lt;p>所以基于上面的目的，这个会议也不应该和复盘会作为同一个会议召开。&lt;/p>
&lt;p>不同角色参与会议的角色其实也都有所区别：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>必须参加&lt;/strong>：作为一个团队内部的总结会议，面向的是团队自身的改进，所以Dev Team和Scrum Master是必须要参与会议的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>尽量参加&lt;/strong>：PO虽然也是团队一份子，但PO的职责更多还是面向产品本身，而且基本不直接参与产品研发本身。所以PO在团队回顾这点上，不是必须要参加；但是作为团队的重要成员，很多情况下，有些意见和改进举措也是需要PO提出或参与的，因此PO是尽可能参加。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>避免参加&lt;/strong>：而把回顾会和复盘会分开的一个重要原因，其实就是作为团队内部的改进会议，为了让团队成员能够更直接地表达意见，参与复盘会议的一些利益干系人，比如用户、经理层等，最好是避免参会。当然有些特殊情况下，比如产生重大分歧、产品目标有重大风险等情况下，可能也会请关键的干系人参与回顾。（当然，老板非要参加一般也没法拒绝）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209.png"
width="899"
height="611"
srcset="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209_hu_cd6b023c8ae75d9.png 480w, https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209_hu_f4805339191698b3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="353px"
>&lt;/p>
&lt;h2 id="会议流程">会议流程
&lt;/h2>&lt;p>回顾会通常建议是尽可能线下召开，而因为团队都比较熟悉，又是迭代结束，气氛尽快可能营造得轻松些，准备些小零食，小礼品有助于帮助会议达到更好效果。&lt;/p>
&lt;p>会议大体流程如下：&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-1.png"
width="1719"
height="265"
srcset="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-1_hu_31b40120eddd15a5.png 480w, https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-1_hu_8da67b14dd9ecac0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="648"
data-flex-basis="1556px"
>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先当然还是Scrum Master来主持会议。在进行回顾之前，通常还要做些准备。比如收集迭代过程中的相关数据，比如burn-down燃尽图，团队的速率图。以及在以前迭代回顾会上的跟踪项，目前的状态，这些都在在召开会议开始阶段，让团队总体做个了解。当然然对于比较新的团队，还要介绍下回顾会的规则。要用到的配套工具比如卡片、投票贴纸等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下一个环节，是收集团队对迭代运作的建议，也就是团队成员各自把自己对当前迭代的观察结果写下来，哪些方面做得好，应该保持：哪些方面还不够好，可以改进，包括如果想单独感谢谁都可以写到不同颜色的贴纸上。大家都写完以后，将相关贴纸贴到准备好的白板上对应区域中，而在意见收集完以后，大家可以集中到白板前，由SM或者团队任意一个成员，大声地复述每一个贴纸卡片的内容。这个过程其实相当于团队一起重温迭代运作的过程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在读完大家所有的意见之后，会进入投票环节。比如每人都可以规定有3票，然后针对这些意见，每人投出自己觉得最值得在下一个迭代采取行动的3条意见。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>完成投票以后，统计得票最多的意见，比如每人三票，那么最后就选出得票最多的三条意见，作为需要在下一个迭代采取行动的待办项。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确定待办项后，团队还要共同针对对应的事项，讨论具体的措施内容，确定如何来进行改进和提升。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>上面讨论产生的结果，要明确到可实施的具体行动，指定对应的负责人。这些要作为下一个迭代的任务安排，纳入迭代看板进行任务跟踪。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>通过上面这个会议流程，达到团队自我持续更新和改进提升的目的。这里一个非常重要的核心就是成员应该开诚布公，需要大家真正从团队本身的提升为出发点来进行回顾。&lt;/p>
&lt;h2 id="常用回顾会工具">常用回顾会工具
&lt;/h2>&lt;p>回顾会的主要内容，其实就是收集大家对迭代运作观察和建议的改进事项。一般线下是通过不同验收的贴纸在白板上体现。&lt;/p>
&lt;p>不过现在很多团队可能是异地或居家办公，这种线上回顾会也可以利用一些线上的配套工具。&lt;/p>
&lt;p>比较常用的有：&lt;/p>
&lt;h3 id="ideaboardz">IdeaBoardZ
&lt;/h3>&lt;p>通过 &lt;a class="link" href="https://ideaboardz.com/" target="_blank" rel="noopener"
>https://ideaboardz.com/&lt;/a> 可以方便地建立一个回顾模板&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-3.png"
width="2105"
height="968"
srcset="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-3_hu_1e5569cb6509f46.png 480w, https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-3_hu_b852e1608cb979fd.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="217"
data-flex-basis="521px"
>&lt;/p>
&lt;p>按最基本的&lt;/p>
&lt;ul>
&lt;li>团队执行比较好的地方&lt;/li>
&lt;li>值得改进的地方&lt;/li>
&lt;li>需要采取的行动&lt;/li>
&lt;/ul>
&lt;p>从这几方面收集大家的意见&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-2.png"
width="1169"
height="445"
srcset="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-2_hu_b08e81f52492d1b3.png 480w, https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-2_hu_aab6830d5cbec2e4.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="262"
data-flex-basis="630px"
>&lt;/p>
&lt;h3 id="海星图">海星图
&lt;/h3>&lt;p>除了上面的基本模型外，有的团队还会利用&lt;strong>海星图&lt;/strong>对观察结果进行细分，划分出五个不同区域&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-4.png"
width="470"
height="456"
srcset="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-4_hu_8bbcd0febefd91c7.png 480w, https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-4_hu_264f7df08a26cf93.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="247px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>KEEP&lt;/strong>: 应该继续保持的行为&lt;/li>
&lt;li>&lt;strong>MORE&lt;/strong>: 应该更多执行的行为&lt;/li>
&lt;li>&lt;strong>LESS&lt;/strong>: 应该在后续迭代减少的行为&lt;/li>
&lt;li>&lt;strong>START&lt;/strong>: 应该在后续迭代开始实施的行为&lt;/li>
&lt;li>&lt;strong>STOP&lt;/strong>: 应该在后续迭代停止的行为&lt;/li>
&lt;/ul>
&lt;h3 id="帆船图">帆船图
&lt;/h3>&lt;p>类似的其实还有 &lt;strong>帆船图&lt;/strong> 这样的模型，目的基本相似，都是起到 回顾检视，后事之师的目的。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-5.png"
width="846"
height="644"
srcset="https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-5_hu_242f86d50d08f6d5.png 480w, https://chengxiaqiucao.github.io/post/034-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%9B%9E%E9%A1%BE%E4%BC%9A/Pasted-20241209-5_hu_674497bdf56e8645.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="315px"
>&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>以上就是关于 &lt;strong>Sprint 回顾会&lt;/strong> 的一些梳理。实际运作中，千万不要把回顾会开成抱怨、诉苦会或互相指责，不管运作过程中发现的问题多么严重，大家最终还是要立足团队发展，成员和团队共同得到提升才是目的。&lt;/p></description></item><item><title>细说敏捷：敏捷四会之复盘会</title><link>https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/</link><pubDate>Sun, 01 Dec 2024 00:00:00 +0000</pubDate><guid>https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/</guid><description>&lt;img src="https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201.png" alt="Featured image of post 细说敏捷：敏捷四会之复盘会" />&lt;p>前两篇文章，我们分享了敏捷四会中的计划会和每日站会，本文我们继续介绍在敏捷 Sprint 结束后会召开的敏捷复盘(Review)会议。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201.png"
width="1728"
height="959"
srcset="https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201_hu_3c6c2fbe5cce67cb.png 480w, https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201_hu_a6ff5a4100cd1a8d.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="180"
data-flex-basis="432px"
>&lt;/p>
&lt;h2 id="目的和作用">目的和作用
&lt;/h2>&lt;p>Sprint Review Meeting 作为一个Sprint迭代结束后召开的会议，主要目的其实是体现敏捷思想中的“和客户合作”，“快速反馈”，是敏捷小步快跑思想的重要体现。&lt;/p>
&lt;p>具体来说，这个会议的目的，是向产品的业务团队、用户和利益干系人来展示当前 Sprint 的工作成果，听取他们对产品的反馈，确认当前产品的输出 &lt;strong>增量（Increment）&lt;/strong> 是否符合预期，有无新的意见，便于后续 Sprint 的及时调整。&lt;/p>
&lt;p>这也是敏捷区别于传统研发模式的一个显著区别，也就是在一个短周期的Sprint，就会通过这个会议的展示，和最终需求方及时确认进展，而不是像传统流程那样，直到经过一个长周期的完整研发流程后，才会把最终产品交付给用户进行确认。&lt;/p>
&lt;p>所以，这个会议的作用，除了团队的成果交付，更主要的是通过对产品Increment的展示，获取外部业务方和其他干系人的反馈，便于及时调整。&lt;/p>
&lt;h2 id="误区">误区
&lt;/h2>&lt;p>很多人把这个会议看作是Sprint团队内部，跟PO的一个交付确认会议，其实是不正确的。&lt;/p>
&lt;p>它更多是基于和团队外部的沟通目的。&lt;/p>
&lt;p>也因此，有些特殊状况下，某些Sprint这个会议也是可以不召开。比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Sprint的 Increment 产出并无可直接展示的比较明显的业务变更，更多是一些技术调整，架构层面的变化时，并无多少需要业务方确认的内容。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关键的业务方或利益干系人无法参加，不能匹配当前 Sprint的节奏。Sprint的结束时间比较固定，但关键利益干系人的时间如果无法匹配，那么这个会议可能会取消。这种情况下，后续Sprint 的复盘会时会包含当前sprint的相关输出展示&lt;/p>
&lt;/li>
&lt;li>
&lt;p>团队本身评估Sprint Goal就没有达成，关键的产出达不到预期时，自然也不适合跟外部进行产品展示。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参会人员">参会人员
&lt;/h2>&lt;p>基于这个会议的目的，其实复盘会可能参与的人员会比较多，一般会包含下面这样一些角色：&lt;/p>
&lt;ul>
&lt;li>Scrum Team 当然都是应该参加的，包括PO、SM、Dev Team&lt;/li>
&lt;li>关键的利益干系人，通常指这个产品的投资人（产品总监/研发总监这样的角色）&lt;/li>
&lt;li>团队成员的相关汇报对象，开发经理、测试经理、UE经理等&lt;/li>
&lt;li>和Sprint产出相关的其他关键关联团队角色，比如有协作的其他Scrum团队关键成员（PO、SM），或者像安全、法务、质量、售后、售前、客服等。&lt;/li>
&lt;/ul>
&lt;p>复盘会一般都在Sprint结束的最后一天召开。而Scrum 团队中，PO作为和外部各种干系人的沟通渠道，会在会议召开前（通常提前1~2天）发出会议邀请，既告知相关人员当前Sprint的主要输入内容和范围，也便于确认会议与会人，并给团队预留一些复盘演示的必要准备时间。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201-2.png"
width="1075"
height="1054"
srcset="https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201-2_hu_43482dbbfe986f8a.png 480w, https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201-2_hu_8dbe488a6291c7f4.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="244px"
>&lt;/p>
&lt;h2 id="会议流程">会议流程
&lt;/h2>&lt;p>迭代最后一天，大家完成迭代工作，根据PO的会议邀请，参与Review Meeting。&lt;/p>
&lt;p>会议的流程大致如下：&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201-1.png"
width="1320"
height="222"
srcset="https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201-1_hu_d07cdd77c3adb380.png 480w, https://chengxiaqiucao.github.io/post/033-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E5%A4%8D%E7%9B%98%E4%BC%9A/Pasted-20241201-1_hu_a205db4f60f07bdd.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="594"
data-flex-basis="1427px"
>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Scrum Master主持会议，一般会在开始欢迎参会的相关干系人，并简单介绍下参会的成员，如果Scrum团队有新成员加入，可能还会让新成员做个简单的自我介绍。如果相关人员都比较熟悉，就是个简单的开场白。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来，会由 PO 说明下当前这个Sprint增量的主要内容，也是接下来演示的主要功能范围。如果是间隔了多个sprint才召开的Review，这里通常会包含多个Sprint的内容。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后就是演示环节，一般是PO 自己来进行演示说明，因为 PO 全程参与Sprint，对相关内容也比较熟悉。实际工作中，也可以是团队中比较熟悉相关功能的成员来进行演示，通常负责测试的同学执行这个演示会比较多。最好不要在演示过程中，频繁切换不同人员来进行演示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下面这个环节，其实通常也会贯穿在演示过程中，就是干系人对产品实现上的一些反馈沟通，基于产品的目标和价值，包括下一Sprint的预期，对产品会有一些疑问或改进意见，团队可以就这些问题，和干系人进行直接的沟通和讨论。这部分其实占用了这个会议最主要的时间，气氛或融洽或激烈，但最终都会对形成一些原有需求的修订或新增。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所以在上一个环节的输出其实会产生一个更新的PBI清单，而这也会是后续Sprint的主要输入，是会后PO需要进一步梳理精炼的素材。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，SM进行会议总结，通常会汇总下讨论结果，包括确认后续要跟踪落实的需求和其他事项，如相关技术的调研攻关等。当然，这里的总结，其实也会提醒干系人散会，但对团队来说，也是提醒后续回顾会的召开（回顾会通常紧接复盘会召开）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>复盘会一般控制在2小时内（针对2周的Sprint），SM在过程中要控制会议节奏，根据演示内容的多少，对一些过于发散和深入的讨论进行时间上的把控，比如另行预定专门的会议讨论等。&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>那么总结下复盘会的关键事项：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先这个会议是一个迭代结束后，获取迭代产出反馈的一个会议。是敏捷小步快跑思想的主要体现。但实际运作中，并不是一个必定会每个Sprint都会召开的一个会议。只是应尽可能不要间隔时间太长，给团队来根据干系人的反馈进行及时调整有灵活性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这个会议并不是一个验收会，它并不是用于向PO确认Sprint Goal有没有达成的一个会。沟通反馈才是主要目的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>会议的过程和产出，是敏捷迭代，产品演进的重要一环，是确定PBI，及时纠偏的重要过程，可以确保团队的工作和用户的期望是匹配的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，这个会议也是Sprint中Dev Team和相关干系人直接沟通，感受压力和直面用户或老板们真实想法的唯一一个正式的窗口。对于避免团队闭门造车、想当然或工程师思维有重要意义。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>以上就是关于Sprint Review Meeting相关召开要点的梳理和总结，欢迎关注秋草，持续带更多软件研发、测试、技术的深度梳理和思考。&lt;/p></description></item><item><title>细说敏捷之每日站会</title><link>https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/</link><pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate><guid>https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/</guid><description>&lt;img src="https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/standupMeeting.png" alt="Featured image of post 细说敏捷之每日站会" />&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/standupMeeting.png"
width="914"
height="472"
srcset="https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/standupMeeting_hu_f535eee33a620b62.png 480w, https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/standupMeeting_hu_6af6806b02b3b670.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="193"
data-flex-basis="464px"
>
上一篇文章中，我们讨论了 &lt;strong>敏捷四会&lt;/strong> 中 &lt;strong>冲刺计划会&lt;/strong> 的实施要点，本篇我们继续分享敏捷四会中实施最频繁，团队最容易实施但往往也最容易走形的第二个会议：&lt;strong>每日站会&lt;/strong>&lt;/p>
&lt;h2 id="关于每日站会的误区">关于每日站会的误区
&lt;/h2>&lt;p>站会是一个比较有标志性的仪式活动，大部分号称敏捷的团队，也都会实施站会这个实践，但其实对站会的理解上，其实还是有不少误区。&lt;/p>
&lt;ol>
&lt;li>很多人会认为站会是由Scurm Master负责的一个会议。把它理解成像传统项目一样，PM听取团队工作汇报目的的一个会议。&lt;/li>
&lt;/ol>
&lt;p>但在Scrum中，SM其实一个辅助性的角色，团队本身才是对各项具体工作负责的人。所以站会的Owner其实是团队。虽然通常也会由SM来主持，但SM的主要作用是协调和掌控节奏，会议本身主要还是为了完成团队内部自身的协作。&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>第二个误区，就是这个会议也不是一个状态更新会，它既不是用来向SM，也不是向PO汇报工作进展的。更新状态本身不是会议的目的，而主要是为了让团队成员对其他人的工作都有清晰的了解，便于当天工作的进一步协作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有一个误区，也是很多人会不自觉进入的误区。就是这个会议也不是用来解决问题的。它只是一个很简短的团队成员之间的同步会议。要保证会议效率，避免进入具体细节的长时间讨论。做到反映团队当前的进展、识别工作障碍就达到了目的。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="每日站会的作用">每日站会的作用
&lt;/h2>&lt;p>所以，澄清了以上误区，站会的作用也就比较清楚了：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>会议的负责人是团队本身。一个很成熟的Scrum团队，甚至也可以不需要SM来组织并主持站会的召开&lt;/p>
&lt;/li>
&lt;li>
&lt;p>会议的主要目的是用于团队进展的同步，成员间互相了解进展，使每个人都能知道团队目前处在完成 sprint 目标的一个什么位置，还有哪些需要调整的地方&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，通过站会，也可以识别出当前主要的困难和阻碍，便于进一步及时采取措施。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="站会的内容">站会的内容
&lt;/h2>&lt;p>而因为站会的主要作用是同步和协同，所以通常会放在一天工作的开始，站会就是团队当天工作的起点。 会议的召开流程，通常也是大家一起集中到看板前，每个团队成员轮流说明下三个问题：&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/standup-3question.png"
width="1328"
height="796"
srcset="https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/standup-3question_hu_39ee246cf55e6ec8.png 480w, https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/standup-3question_hu_e1aabb1be939ac6f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="166"
data-flex-basis="400px"
>&lt;/p>
&lt;ul>
&lt;li>前一天我完成了哪些工作？&lt;/li>
&lt;li>今天的工作计划是什么？&lt;/li>
&lt;li>有哪些遇到的困难或需要他人协作的事项？&lt;/li>
&lt;/ul>
&lt;p>每位成员都通过说明这三个问题，让团队其他人都能知道自己目前的工作进展，然后判断出当天各自要协作的对象是谁，还有哪些需要下一步尽快讨论的问题，说明需要的支持或者在别人需要支持时予以协助。&lt;/p>
&lt;p>正因为站会的作用就是同步信息，而且每天都会召开，会议的时长应严格控制，通常不应该超过15分钟。大家快速更新完各自的进展，任何需要进一步讨论的问题都应该放到会后，再单独和相关的伙伴就问题的细节或解决方案深入讨论。&lt;/p>
&lt;h2 id="站会中的不同角色">站会中的不同角色
&lt;/h2>&lt;p>而作为 Scurm 中的三种不同角色，每种角色参与站会的话应该做些什么？发挥什么作用呢？&lt;/p>
&lt;h3 id="scrum-master">Scrum Master
&lt;/h3>&lt;p>SM作为团队的组织者和支持者，参与站会最主要的作用其实就是维持站会的纪律，保证会议召开的效率，使会议符合敏捷精神。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在出现有问题可能需要深入讨论的时候，及时中断，并且把问题放入看板的&lt;code>停车场&lt;/code>部分中，站会后再安排继续讨论&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据团队成员同步的进展和工作内容情况，判断完成冲刺目标的进度风险，并提醒团队成员可能落后的进度，视情况协调其他成员参与协作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>成员提出的阻碍如果会上无法在团队内部立即解决，记录并在当天进行进展跟踪&lt;/p>
&lt;/li>
&lt;li>
&lt;p>会议结束前，SM 还可以快速地和团队分享下 sprint 的当前燃尽图和看板中主要条目的状态，使大家对当前的总体进展有一个整体的了解&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p> - 最后，SM应该控制会议时间，不超过15分钟结束&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/burnDown.png"
width="1283"
height="830"
srcset="https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/burnDown_hu_f468fe059180f86a.png 480w, https://chengxiaqiucao.github.io/post/032-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A/burnDown_hu_86aa574874b2a243.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="154"
data-flex-basis="370px"
>&lt;/p>
&lt;blockquote>
&lt;p>燃尽图是一个当前实际完成工作量和理想进度的拟合图，可以直观反映出团队当前进展是否符合预期&lt;/p>&lt;/blockquote>
&lt;h3 id="dev-team">Dev Team
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>准时参会，不要迟到。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最主要的当然是进度同步，说明清楚上面的三个问题&lt;/p>
&lt;/li>
&lt;li>
&lt;p>会议前，及时将自己的负责的任务状态更新到最新，保证看板的任务的状态信息是准确的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有任何阻碍或者需要协调、澄清的问题，站会上应该及时地提出来，这也是这个会议主要的目的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="po">PO
&lt;/h2>&lt;p>PO在 sprint 进行中，主要职责是澄清和确认需求，但站会的作用主要是团队的工作进展同步，所以PO 不一定必须参加这个会。但也不是不能参加，参与站会也有他的作用。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对PO自身，通过参与站会，可以知道团队当前的进展情况，能对 Sprint Goal 的达成有更加及时和清晰的判断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>站会如果有关于需求的疑问或者需要澄清的，简单一两句话就可以在会议上完成说明的就可以在会议上解决。对于比较复杂的，也可以及时地掌握情况，方便会后立即单独进行沟通。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有就是 Sprint 进行中，如果正在进行中的需求发生了调整或者优先级变化，就需要及时在站会上跟团队说明，方便团队进行相应的调整和应对&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有时团队识别的困难或阻碍是跟跟PO相关的，这时 PO 也可以及时跟进，包括对于之前反馈过的阻碍事项的解决进展也可以跟团队进行通报。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>总体说来，对于 Scrum 中三种角色参与站会的要求：&lt;/p>
&lt;ul>
&lt;li>SM - 非必须，但推荐参加&lt;/li>
&lt;li>Dev Team - 所有成员必须参加（包括远程电话参会），成员临时无法参与，最好也请其他成员代为说明。&lt;/li>
&lt;li>PO - 不要求，但可以参会&lt;/li>
&lt;/ul>
&lt;h2 id="召开注意事项">召开注意事项
&lt;/h2>&lt;p>最后，站会能否达到它的效果，也是很多敏捷团队实践走形的一些注意事项，总结如下：&lt;/p>
&lt;p>-  &lt;strong>会议应该定点，定时&lt;/strong>。站会每天都开，大家应该形成习惯，每天在固定的时间，固定的地点来参会，避免因为经常调整，浪费会议召集的时间。&lt;/p>
&lt;p>-  &lt;strong>简要&lt;/strong>。每个成员发言要清楚会议的目的就是进展同步，把三个相关问题说明清楚就可以了。而不是在这里探讨和解决问题。控制每个人的发言时间在1分钟左右。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>准时&lt;/strong>。站会要求Dev Team成员都应该参与，这样才能清楚了解其他人的进展，在需要协作的事项上可以及时进行协同。而且站会比较简单，所以准时参会就尤为重要，不能因为个人原因浪费团队的时间。&lt;/li>
&lt;/ul>
&lt;p>确实出现成员迟到的情况，通常也不会等待大家到齐。定时召开的时间要严格保证。（对于异地办公、或者远程的团队成员，可以通过视频会议、电话的方式拨入，但也要保证参会。如果有团队成员中途休假，通常也应该将自己的进展情况委托其他成员代为说明。）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>专注&lt;/strong>。这是个容易忽略的注意事项。道理和上面一样，因为站会的作用是协同，所以每个成员都应该是专注在会议上的，确保能清楚所有人的进展情况，而不应该出现在会议中处理其他工作事务、接电话、玩手机、或者开小会的情况。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>停车场&lt;/strong>。这个看板上的一块专门区域，通常是站会时不可避免遇到一些需要深入讨论的问题时，为了保证会议的效率，暂时把问题记录下来，所放置的一个单独区域。停车场的作用就是避免会议进入深入讨论，但会后可以由对应成员再针对停车场中的问题，继续深入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>站立会议&lt;/strong>。站会，顾名思义，就是希望所有人在会议期间是站立进行的。特别是对于在一个办公室办公的团队来说，站立可以有效避免会议时间拉得过长，而且对于有实物看板的团队来说，站立姿势来移动看板上的事项会更加方便，站着说话也能更容易让所有人都听清。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>站会是 Sprint 进行过程中，全体成员都会参加的一个例行的信息同步仪式。所以效率很重要，是团队自组织和高效协同的重要体现。掌握站会的目的和各个角色参与的要点和注意事项，可以帮助我们更好地把站会开好，真正发扬出敏捷精神。&lt;/p>
&lt;hr>
&lt;p>关注秋草的公众号，及时了解更新动态&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/001-postman%e5%9f%ba%e7%a1%80%e7%af%87/qrcode.jpg"
loading="lazy"
>&lt;/p></description></item><item><title>Scrum敏捷四会 计划会</title><link>https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/</link><pubDate>Mon, 18 Nov 2024 00:00:00 +0000</pubDate><guid>https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/</guid><description>&lt;img src="https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/sprint_planning.png" alt="Featured image of post Scrum敏捷四会 计划会" />&lt;p>在 Scrum 敏捷模型中，敏捷的落地，其实主要是通过 Scrum 定义的四个主要仪式，也就是我们通常说的 &lt;strong>敏捷四会&lt;/strong> 来完成的，本文我们探讨四会中 &lt;strong>Sprint Planning&lt;/strong> 会议的作用以及其实践要点。&lt;/p>
&lt;h2 id="planning会议的作用">Planning会议的作用
&lt;/h2>&lt;p>在每一个Sprint的开始，首先就会召开这个Sprint Planning会议，同时这个会议也标志着Sprint开始。&lt;/p>
&lt;p>这个会议的主要作用，当然如其名，就是制定当前Sprint运作的计划，确定团队在当前Sprint的工作内容和工作方向，形成Sprint的待办列表 SBI。&lt;/p>
&lt;h3 id="会议的输入">会议的输入
&lt;/h3>&lt;h4 id="pbi">PBI
&lt;/h4>&lt;p>Planning会议最主要的输入，是产品待办清单 PBI。&lt;/p>
&lt;p>会议中的主要讨论其实主要是围绕 PBI 展开的，也就是要从 PBI 中提取经过团队共同确认的待办项，纳入当前迭代，形成 SBI&lt;/p>
&lt;p>而作为会议输入的 PBI，应该是已经和团队一起经过梳理、提炼的需求。团队成员对需求本身也有了充分的理解，并完成对待办项工作量的估算。所有待办项也都有优先级的定义。&lt;/p>
&lt;p>这也是在召开Planning会议前，PBI最好是已经经过grooming会议做过了需求澄清和估算的主要原因。以提高planning会议的效率。 当然在Planning会议上，也会存在对需求的进一步澄清和确认过程，只是为了控制时间，这部分可以尽可能提前打好充分基础。&lt;/p>
&lt;h4 id="dordod">DOR/DOD
&lt;/h4>&lt;p>另外一个重要的输入是团队集体对DOR和DOD的定义，这个通常在sprint 0上确认。后续Sprint可以沿用，如果有修正再重新确认。&lt;/p>
&lt;p>关于DOR 和 DOD，我们介绍Sprint工件的时候有过说明，不再赘述。&lt;/p>
&lt;p>DOR 其实是可以进入Sprint的待处理需求的标准，符合DOR的需求才应该进入 Planning的讨论。
DOD 则是Sprint进行中，每个待办项可以认为完成的标准。&lt;/p>
&lt;p>Planning会议上应该确认大家对此有共识。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/Pasted-20241101-1.png"
width="788"
height="615"
srcset="https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/Pasted-20241101-1_hu_d0c607e0e790f3ad.png 480w, https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/Pasted-20241101-1_hu_26a8e5a54d372c6a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="128"
data-flex-basis="307px"
>&lt;/p>
&lt;h4 id="capacity产能">Capacity（产能）
&lt;/h4>&lt;p>这个体现的是团队的生产能力。每个 Sprint 团队成员的产能是不固定的，因为可能有成员休假，借调或者本来就不是全职投入的情况。因此在召开 Planning 会议前， Scrum Master应该提前收集掌握好当前Sprint团队整体的Capacity。&lt;/p>
&lt;h3 id="会议要解决的问题">会议要解决的问题
&lt;/h3>&lt;p>在Planning会议上其实主要就是要解决三个问题： Why？ What？ How？&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Why？&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>为什么我们要进行这个sprint？ 团队要理解这个sprint中的工作带给产品的价值是什么。 PO需要向大家说明他希望达成的价值目标，要能够回答团队为什么我们要做这些需求？为什么这些需求应该要放到当前这个sprint？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>What？&lt;/strong>
Sprint中具体要做的是什么？如果需求已经经过了grooming的梳理和提炼，这里就会节省很多时间。但如果需求还没有充分澄清，或者会议中产生了新的一些思路，PO和团队这里要完成对需求细节的梳理，识别相关的风险和依赖，并达成理解一致。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>How？&lt;/strong>
这部分更多是开发团队成员的讨论内容，就是确定具体如何纳入Sprint的需求实现？并将需求Story再拆分成不同的工作任务，匹配到人，Scrum Master会和团队一起，完成任务的分配和团队Capacity的平衡。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="会议的输出">会议的输出
&lt;/h3>&lt;p>Planning会议最主要的输出，当然就是SBI，包含当前迭代中需要完成的所有任务项。&lt;/p>
&lt;p>此外，还有一个我们之前介绍过的工件，Sprint Goal。 这个阐明了团队和PO共同达成的迭代应该要力争完成的目标摘要。&lt;/p>
&lt;h3 id="会议时长">会议时长
&lt;/h3>&lt;p>敏捷组织的经验数据是根据sprint的长度，每周对应2小时，也就是如果sprint是1周的话，sprint计划会大概要开2h，而通常sprint一般是2周的长度，这时sprint计划会则需要4个小时。&lt;/p>
&lt;p>当然这只是经验数据，不同团队根据团队规模、成熟度和工作的复杂程度会有所不同。&lt;/p>
&lt;h2 id="不同角色应如何参与">不同角色应如何参与
&lt;/h2>&lt;p>Planning会议主要是团队内部会议，参与人包括团队全体成员。极少数的情况下，会邀请主要的利益干系人（直接老板）。在需要他们给出一些决策输入时，可能需要邀请参加。对于比较大的项目，存在多个Scrum团队合作的情况，可能也会邀请到其他团队的关键工程师，来参与一些重要的技术评估。但总体来说，这个会主要还是团队内部的讨论为主，参与人是PO、SM和Dev Team。&lt;/p>
&lt;h3 id="po">PO
&lt;/h3>&lt;p>PO在计划会前，要完成PBI的优先级排列，并和团队提前完成需求的grooming。&lt;/p>
&lt;p>在会议进行中，则主要是要解答Why和What的问题，并提出期望的sprint goal，确认Scope。&lt;/p>
&lt;p>会议最后，要团队一起确认会议输出：sprint Goal和SBI。&lt;/p>
&lt;h3 id="sm">SM
&lt;/h3>&lt;p>Scrum Master在会前要预定会议，收集团队的投入产能，有那些人需要休假，每位成员在Sprint中的投入时间。&lt;/p>
&lt;p>会议中，SM负责主持，要组织会议流程，协助团队进行任务的分解和工作分配，确保scope中的所有任务都有对应的owner负责人。&lt;/p>
&lt;p>在任务分配和认领过程中，要随时检查团队成员的任务和个人可投入时间的匹配情况，避免出现过度认领。还包括在一些互相依赖任务上进行协调的工作。&lt;/p>
&lt;p>最后，SM要负责汇总出SBI，并和团队一起确认goal。一般还会有一个收集大家对完成Sprint goal的信息指数环节。&lt;/p>
&lt;p>在会后，SM还一应该准备好sprint看板，把相关任务设置到初始状态，并发出会议纪要。&lt;/p>
&lt;h3 id="dev-team">Dev Team
&lt;/h3>&lt;p>会前，团队成员应该将个人在当前迭代的投入时间告知SM，提前参与PO的grooming，充分了解PBI中的相关需求细节。&lt;/p>
&lt;p>在会议召开过程中，确保自己理解了sprint的目标，另外如果有需求需要进一步说明，积极参与梳理，理解需求，完成估算，主动提出并讨论识别到的风险、依赖。 然后和团队一起，根据自己迭代中的Capacity认领任务，承诺产出）。&lt;/p>
&lt;p>最后大家一起确认sprint goal，给出自己对sprint完成goal的信心指数。完成sprint的启动&lt;/p>
&lt;h2 id="会议流程">会议流程
&lt;/h2>&lt;p>再总体梳理下会议进行的流程&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/Pasted-20241118.png"
width="1363"
height="336"
srcset="https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/Pasted-20241118_hu_49098a62f5ea414e.png 480w, https://chengxiaqiucao.github.io/post/031-scrum%E6%95%8F%E6%8D%B7%E5%9B%9B%E4%BC%9A-%E8%AE%A1%E5%88%92%E4%BC%9A/Pasted-20241118_hu_44f4dc53606e4284.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="405"
data-flex-basis="973px"
>&lt;/p>
&lt;p>SM 召集会议后，&lt;/p>
&lt;ol>
&lt;li>
&lt;p>PO首先说明期望的sprint目标和当前Sprint的工作范围。并给出相关的理由，对产品的价值说明。团队一起就这部分完成讨论，初步确定scope和goal&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来针对Scope中的需求逐一进行澄清，对照DOR，如果没有进行过groom的需求，这时完成梳理澄清和工作量估算。同时识别可能的风险和依赖，并讨论应对措施。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这两个阶段是Planning会议的上半场，也是PO的主场&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>接下来的下半场是开发团队的主场，针对已经理解的需求，再进行任务的拆分，具体分配到人。SM根据任务认领情况，要同步观察Capacity的匹配情况，确保没有遗漏任务和过度认领。这个环节视情况，PO不是必须参加。即使参加，也主要是回答一些讨论中出现的对需求的疑问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，所有团队成员共同确认达成一致的sprint goal，输出SBI。也代表团队对目标和范围的承诺。最后，团队全体可以对成功完成sprint给i出一个信心指数（0~5）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>会议全程，SM负责主持，应该控制会议节奏，注意进度和时间。&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>通过上面的说明，大家应该可以看到，sprint planning会议是敏捷运作中非常关键的一个会议：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过计划会，产生了一个明确的sprint目标&lt;/p>
&lt;/li>
&lt;li>
&lt;p>团队正式开始Sprint前，通过计划会完成了充分沟通，整体工作范围、目标对所有成员透明化，增进了理解&lt;/p>
&lt;/li>
&lt;li>
&lt;p>尽可能准确地匹配了团队的产能和纳入迭代中的工作任务&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每项待办需求经过拆分和认领，都有了明确的负责人&lt;/p>
&lt;/li>
&lt;li>
&lt;p>团队集体完成了SBI和目标，加强了互相之间的合作。也为完成迭代奠定了信心&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>关注秋草的公众号，及时了解更新动态&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/qrcode_for_gh_e12c318badb4_258%20%281%29.jpg"
loading="lazy"
>&lt;/p></description></item><item><title>敏捷中的三大工件</title><link>https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/</link><pubDate>Sun, 03 Nov 2024 00:00:00 +0000</pubDate><guid>https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/</guid><description>&lt;p>之前的系列，我们介绍了 Scrum 敏捷中的三大主要角色。而具体实施 Scrum，还牵涉一些具体的工作对象或产出物，这些材料在 Scrum 中叫做 工件 &lt;strong>（Artifacts）&lt;/strong>。&lt;/p>
&lt;h2 id="工件">工件
&lt;/h2>&lt;p>在 Scrum 中，常说的工件其实主要指三大核心工件：产品待办清单PBI、Sprint迭代待办清单SBI、产品增量Increment。但除了这三种核心工件外，其实还定义有和这三大工件相关的其他的几种工件。&lt;/p>
&lt;p>在敏捷中，工件作为我们的工作对象，产出物。应该是整个Scrum团队集体共同工作和维护的，并且应该对所有人透明，也就是这些工件，对团队中的所有人都是可视化的。这也是敏捷的原则，强化团队对事物的一致理解和沟通，大家应该工作在同一个频道上，透明、可视、随时可查阅极为关键。&lt;/p>
&lt;h2 id="产品待办清单-product-backlogpbi">产品待办清单 Product Backlog（PBI）
&lt;/h2>&lt;p>第一个核心工件是&lt;strong>Product Backlog Items （PBI）&lt;/strong>， PBI 是一个有序列表，包含有产品的所有待完成的未尽事项，包括产品需求、未修复的bug、技术优化、内部改进、工作任务等等各种需要团队后续处理的、和产品相关的事务。&lt;/p>
&lt;p>PBI应该具备以下几个重要特征，或者说DEEP原则：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Detailed&lt;/strong>：细节描述。对待办的事项有清晰，无歧义的说明，团队成员可以充分了解待办事项的必要信息。这也是Scrum中需求精炼的的必要性，越是优先级高的，细节描述应该越充分。&lt;/li>
&lt;li>&lt;strong>Emergent&lt;/strong>：涌现式的。PBI是一个动态列表，可以根据需要随时进行插入和调整。&lt;/li>
&lt;li>&lt;strong>Estimated&lt;/strong>：有估算。待办条目在需要落实之前，应该要完成工作量以及对产品价值的估算，估算是否准确，是团队实际生产力的基础。&lt;/li>
&lt;li>&lt;strong>Prirotized&lt;/strong>：有优先级的。PBI中的待办事项，应该是有优先次序的，在PBI中，不存在两个优先级完全相同的条目。这也是列表的优点，列表先天就是有排列顺序的，PBI列表中，排在前面的项优先级更高。团队在从PBI中提取迭代任务的时候，也会按照优先级来依次提取。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241102.png"
width="736"
height="521"
srcset="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241102_hu_e3f4c7de233c4941.png 480w, https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241102_hu_8343c01209ab85af.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="339px"
>&lt;/p>
&lt;p>和其他工件一样，PBI虽然也是需要团队共同维护的一个产出物，但 PBI 的owner，是&lt;strong>PO（产品负责人）&lt;/strong>，其他成员虽然也会参与到PBI的细节补充、方案完善，包括PBI的工作量估算也是需要团队给出，但最终对 PBI 负责的只有PO，PO对PBI有最终解释和优先级的决定权。&lt;/p>
&lt;p>PBI的生成和维护过程中，通常是PO会尽可能把相关的Feature、Story、Enhancement（优化）纳入PBI中，作为后续工作的基础。再经过和团队的充分沟通，一般会通过产品的需求精炼会议(grooming)，对需求进行细化和实现方案的讨论，团队还会分解出具体的技术任务并对需要的工作量进行估算。&lt;/p>
&lt;p>所以 PBI 它其实就是Scrum敏捷研发的源头，相当于是传统研发中，需求分解阶段的主要产出PRD的作用。PBI是启动 Sprint 的基础，也是 SBI 的来源。&lt;/p>
&lt;h3 id="产品愿景-product-vision">产品愿景 Product Vision
&lt;/h3>&lt;p>和PBI 配套的，其实还有一个辅助工件，或者Scrum定义中也叫做 PBI 的commitment（承诺产出物）。就是产品愿景Product Vision。&lt;/p>
&lt;p>Product Vision是一个在产品早期就应该完成定义的东西，主要是总体上概括产品要实现什么目标，大家共同做的这个东西到底是为了达到什么目的，对用户有什么价值。也就是让整个团队直到自己在为什么工作。&lt;/p>
&lt;p>是一个比较长远的对整个产品蓝图的描述。&lt;/p>
&lt;h2 id="sprint待办清单-sprint-backlog-sbi">Sprint待办清单 Sprint Backlog （SBI）
&lt;/h2>&lt;p>&lt;strong>Sprint&lt;/strong> 是冲刺的意思。Scrum中定义的一个短周期的时间窗，在这个较短的周期内团队可以完成一些可交付的产品功能。并基于已完成的功能获取相关干系人的反馈，以便及时地调整整个产品的演进路线。是敏捷“小步快跑”思想的具体体现。&lt;/p>
&lt;p>而SBI，就是在Sprint这个周期中，团队需要完成的所有待办事项的清单。因此 SBI 其实是从 PBI中提取出来的，分布到不同 Sprint 中的团队需要完成的工作。&lt;/p>
&lt;p>通常在Sprint 正式启动前的Sprint Planning会议上，依据PBI的优先级和团队的生产力(Capacity)，由团队共同完成 SBI 的提取。&lt;/p>
&lt;p>SBI在计划会确定以后，一般是尽可能维持不变的。但现实总有各种意外情况发生，而且敏捷提倡拥抱变化，所以并不意味 SBI 确定以后会在 Sprint 中一定是恒定的。PO 根据优先级的调整，在和团队达成一致后，SBI 也是可以进行增删改的，但前提是要团队达成共识。&lt;/p>
&lt;p>通常SBI 调整意味着工作量的浪费，因此在 Sprint 周期内，应该尽可能维持稳定。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241102-1.png"
width="2112"
height="1224"
srcset="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241102-1_hu_98b94d7384164be7.png 480w, https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241102-1_hu_b5a8fb8a10cae01a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="172"
data-flex-basis="414px"
>&lt;/p>
&lt;p>如图，是常用敏捷管理软件 Jira 中，已经纳入到 Sprint 中的 SBI。Sprint 开始以后，则会通过 Scrum 的迭代看板来实时反映 Sprint 的进展情况。&lt;/p>
&lt;h3 id="sprint-goal">Sprint Goal
&lt;/h3>&lt;p>类似的，和 SBI 配套的也有一个辅助工件或commitment，就是 Sprint 目标。这个工件通常由PO定义，整体上概述整个Sprint应该达成的核心目标。在和团队确认并达成一致后，Sprint Goal 其实也代表了团队整体在这个周期中承诺的产出。&lt;/p>
&lt;p>对于未参与迭代的各种干系人，通过 Sprint Goal 也可以了解当前产品进展的总体情况。&lt;/p>
&lt;h2 id="增量-increment">增量 Increment
&lt;/h2>&lt;p>&lt;strong>Increment&lt;/strong>，增量的意思。在敏捷中，因为提倡小步快跑，每个迭代的工作成果其实都是面向产品愿景，是在原有基础上的增强，不仅是一个累积的过程，也是不断向用户交付价值的过程。&lt;/p>
&lt;p>基于敏捷原则，Increment 应该是可工作的软件，可以呈现出产品的价值。也就是 Increment和之前 Sprint产出的叠加， 应该总是一个面向未来的、最小的可用软件 MVP（&lt;em>Minimum Viable Product&lt;/em>）&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241103.png"
width="450"
height="288"
srcset="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241103_hu_efb67444719fc8c7.png 480w, https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241103_hu_c3fbaee2dae0461a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="156"
data-flex-basis="375px"
>&lt;/p>
&lt;p>Sprint 是否达到了 Sprint Goal，通常是在Sprint评审会上通过演示Increment的功能效果，来向相关干系人进行展示，并获取反馈。&lt;/p>
&lt;h3 id="dod完成定义-definition-of-done">DOD（完成定义 Definition of Done）
&lt;/h3>&lt;p>和 Increment 相关的commitment， 其实就是SBI中每个待办项的完成情况。那这里怎么定义这个&lt;strong>完成&lt;/strong>，在 Scrum 中，对应的就是 &lt;strong>DOD&lt;/strong>。DOD 是关于主要待办项类型的一些共性定义。&lt;/p>
&lt;p>其实除了 DOD 外，还有 DOR，DOR 是定义一个待办项在什么情况下可以定义为&lt;strong>就绪&lt;/strong>。只有就绪的待办项才应该纳入SBI&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/031-Scrum%e6%95%8f%e6%8d%b7%e5%9b%9b%e4%bc%9a-%e8%ae%a1%e5%88%92%e4%bc%9a/Pasted-20241101-1.png"
loading="lazy"
alt="Jira中关于DOD、DOR的定义"
>&lt;/p>
&lt;h2 id="其他工件">其他工件
&lt;/h2>&lt;p>除了 Scrum 中定义的这三种核心工件以及辅助的 commitment 工件，还定义了反映迭代进展状态的工件&lt;/p>
&lt;h3 id="燃尽图-burndown-chart">燃尽图 Burndown Chart
&lt;/h3>&lt;p>&lt;strong>燃尽图&lt;/strong>是一种能够及时反映出 Sprint 进展状况的可视化图形。&lt;/p>
&lt;p>X轴：迭代的进行时间
Y轴：迭代的工作量，通常通过SBI中估算的故事点（Story Point）反映完成这个这个迭代的预估总工作量。&lt;/p>
&lt;p>基于工作量和时间的关系，先绘制一条线性的故事点的理想燃尽线，再根据迭代进行中，实际每天完成的工作量，绘制一条实际燃尽线。 这两条线的匹配度，其实能反映迭代当前进度是否正常。是Scrum Master和团队每日站会时应该随时关注的一个迭代关键状态图。&lt;/p>
&lt;p>因此通常会将燃尽图也作为 Scrum中的一个重要工件来看待。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241101.png"
width="933"
height="569"
srcset="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241101_hu_a9c82f2783072c64.png 480w, https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241101_hu_a5e4ee4f0a5a9067.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="393px"
>&lt;/p>
&lt;p>除了燃尽图外，其实还有很多其他的图形可以用来分析迭代当前进展，比如常用的还有：&lt;/p>
&lt;p>&lt;strong>累积流图 (Cumulative flow diagram）&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241103-1.png"
width="1375"
height="737"
srcset="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241103-1_hu_cd6138de5ca1625c.png 480w, https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241103-1_hu_dc93cedf5ae29426.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="447px"
>&lt;/p>
&lt;p>通过累积流图，可以看出 Sprint 中，总体需求在不同状态间变化的趋势，往往在识别团队瓶颈、平衡成员间工作量时发挥重要作用。&lt;/p>
&lt;p>&lt;strong>速度表（Velocity）&lt;/strong>&lt;/p>
&lt;p>另一个常用的图还有 Velocity，这个图更多是通过对多个Sprint 完成工作量的跟踪，来观察团队的生产力是否稳定，进而对团队成熟度有个基本的判断。&lt;/p>
&lt;p>越是稳定的敏捷团队，每个迭代的产出应该是比较恒定的。而如果差别波动较大，则代表团队在任务平衡、估算、应对干扰等方面还存在较多问题。是一个观察指标&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241103-2.png"
width="875"
height="601"
srcset="https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241103-2_hu_d008b08a67479d8c.png 480w, https://chengxiaqiucao.github.io/post/044-%E6%95%8F%E6%8D%B7%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E4%BB%B6/Pasted-20241103-2_hu_c3f0c4e62f0c4e39.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;hr>
&lt;p>以上就是关于Scrum敏捷中，团队工作对象和产出，工件的介绍。 欢迎大家继续关注这个系列，持续更新中&amp;hellip;.&lt;/p></description></item><item><title>敏捷Scrum中三大角色</title><link>https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/</link><pubDate>Fri, 25 Oct 2024 00:00:00 +0000</pubDate><guid>https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/</guid><description>&lt;img src="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/agile_dev_team.png" alt="Featured image of post 敏捷Scrum中三大角色" />&lt;p>在本系列的前几篇，我们梳理了敏捷的起源和目前的主要落地框架。其中 Scrum 框架是敏捷实践的绝对主流，几乎是团队级敏捷实践的事实标准。而规模敏捷框架也大多是在 Scrum 的基础上来进行扩展。因此我们后续的总结将以 Scrum 为基础，探讨敏捷在软件研发过程中落地实践的主要做法运作方式。&lt;/p>
&lt;p>本篇我们将从探讨 Scrum 框架的角色组成来谈起。&lt;/p>
&lt;h2 id="scrum-团队">Scrum 团队
&lt;/h2>&lt;p>在 Scrum 中，Scrum 团队只面向一个目的，就是&lt;strong>每次&lt;/strong>都是为了完成产品的&lt;strong>一个有价值的目标&lt;/strong>而存在。Scrum团队作为敏捷组织中有凝聚力的最小生产力单位，Scrum团队内不再有层级结构。团队由&lt;strong>跨职能&lt;/strong>的专业人员组成，团队成员应该具备完成产品目标的&lt;strong>所有技能&lt;/strong>。&lt;/p>
&lt;p>在运作中，Scrum团队会负责所有与产品目标相关的活动，包括同利益相关者的协作、验证、维护、操作、实验、研究和开发，以及其他任何可能需要的活动。Scrum团队是自组织并自我驱动的，以一种可持续的节奏，保持专注并不断交付价值。&lt;/p>
&lt;p>虽然在团队规模上没有明确约束，但通常一个 Scrum 团队的理想规模应该限制在 &lt;strong>10人以内&lt;/strong>。小型团队会有更好的沟通效率，更高的单位生产力。&lt;/p>
&lt;p>在每个迭代（Sprint）中，交付有价值的增量（Increment）是整个团队的职责所在。Scrum 针对这个目标，定义了团队中的三种不同角色：开发团队（Developers）、产品负责人（Product Owner）和 Scrum 教练（Scrum Master）&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/Pasted-20241025.png"
width="604"
height="512"
srcset="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/Pasted-20241025_hu_de3c28b81641624e.png 480w, https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/Pasted-20241025_hu_aa7971a45125946a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="117"
data-flex-basis="283px"
>&lt;/p>
&lt;h2 id="产品负责人-product-owner">产品负责人 Product Owner
&lt;/h2>&lt;p>PO这个角色，从命名也可以看出，是团队工作产物-产品 的拥有者。产品最终要做成什么样子，PO有决定权。
在团队中，他是最终用户的代言人，是需求的来源方、定义者和最终决策人。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/Pasted-20241025-1.png"
width="951"
height="774"
srcset="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/Pasted-20241025-1_hu_8fff9f50c7be9602.png 480w, https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/Pasted-20241025-1_hu_15bfa9afe6a17c18.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="122"
data-flex-basis="294px"
>&lt;/p>
&lt;p>所以PO的职责，包括以下几方面：&lt;/p>
&lt;h3 id="1-定义需求管理产品待办清单">1. 定义需求，管理产品待办清单
&lt;/h3>&lt;p>作为PO最主要的职责，也就是定义需求。需求是团队工作的源头，也是基础。需求的定义和确定，虽然并不完全是PO独立完成的工作，团队成员也会参与到需求的讨论、梳理和完善中，但PO会是需求最终的决策拍板者。完成定义的需求，也就是产品待办清单&lt;strong>PBI(Product Backlog Item)&lt;/strong>, PO 是PBI的管理人和负责人，即便团队也会参与到需求条目的维护和一些技术细节的细化工作中，但PO会对PBI中的每一个条目负责。&lt;/p>
&lt;p>PBI中包含的需求，是所有未实现的需求清单，包括当期和远期的需求，所以在管理 PBI时，PBI的一个重要属性就是它的&lt;strong>优先级&lt;/strong>，定义 PBI 的优先级是PO的职责。PO要根据需求对产品的价值，以及团队的反馈，综合风险和收益，确定每一个需求的优先排列顺序。&lt;/p>
&lt;p>这也是 PBI 以列表形式存在的一个先天优势，每一条需求在列表中都会有一个唯一的位置，这个位置就代表优先级。列表中越排得靠前，代表优先级越高。PO管理待办清单，重要的一点就是要管理好每条需求对应的排列顺序。有效管理的 PBI 是后续迭代启动的基础。&lt;/p>
&lt;h3 id="2-向团队澄清需求及时反馈">2. 向团队澄清需求，及时反馈
&lt;/h3>&lt;p>而对于敏捷团队而言，既然需求是工作的输入，所以 PO 还有一个重要的职责就是向团队解释需求的定义，澄清可能存在的误解或不够清晰明确的描述。&lt;/p>
&lt;p>这个过程是持续贯穿在研发活动中的，既包括前期，在迭代计划会之前的需求梳理精炼会（grooming meeting），也包括在迭代进行中，当成员对需求有疑问或需要决策的时候，能够及时给出反馈和说明。这也是为什么说 Scrum 团队是应该要大家一起工作，保持沟通效率的重要因素。&lt;/p>
&lt;h3 id="3-维系和利益干系人的关系">3. 维系和利益干系人的关系
&lt;/h3>&lt;p>Scrum 团队在工作中，必然会牵涉各种利益干系人，包括投资人（各产品各相关部门的主管），客户，终端用户、内部关联部门（销售、售后、客服、法务合规、安全、审计、质量等等）都会有一些和产品的关联，这些不同渠道的意见、声音和反馈可能都会影响到产品相关需求、实现的定义，所以PO是维系这些渠道，和这些不同干系人进行沟通和协调的责任人。这也是为什么作为PO这个角色的成员，应该是一个具备很好沟通能力和协作能力的人。&lt;/p>
&lt;h3 id="4-工作产出increment的成果确认人">4. 工作产出（Increment）的成果确认人
&lt;/h3>&lt;p>作为产品的Owner，团队每个迭代的工作成果，是否符合要求，能否达到预期的产品要求，是由PO来进行确认的。&lt;/p>
&lt;p>Scrum中虽然没有定义单独的测试角色，但测试这个工作其实是包含在开发团队中的，对产品的验收确认，虽然最终是PO拍板，但并不是说 PO会负责这里的测试工作。更多还是根据测试成员的评估或者迭代的演示评审会上的反馈，来判断产品目标是否达成。&lt;/p>
&lt;hr>
&lt;p>总而言之，PO 作为Scrum团队中一个非常核心的角色，极为关键。 专人专职其实很有必要，在有的敏捷项目中，PO可能身兼数职，游离于团队之外，其实都是没搞清楚这个角色的重要性。&lt;/p>
&lt;h2 id="scrum大师教练-scrum-master">Scrum大师（教练） Scrum Master
&lt;/h2>&lt;p>在有些似是而非的敏捷项目中，会把SM和传统的项目经理PM混为一谈，认为Scrum Master的工作就是传统PM的作用。这是完全错误的理解。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/scrum-master.png"
width="942"
height="899"
srcset="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/scrum-master_hu_643da106519a9996.png 480w, https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/scrum-master_hu_c29b252f9aa2ebdb.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="251px"
>&lt;/p>
&lt;h3 id="1-并不是团队成员的上级">1. 并不是团队成员的上级
&lt;/h3>&lt;p>传统项目中，PM是一个项目的负责人，需要对项目的成功负责。同时PM也会具备相应的项目管理权，对项目成员的工作分配权，对成员的工作成果的考核权，和项目成员是不同层级的关系。&lt;/p>
&lt;p>但是在Scrum中，SM和团队成员是平级的关系，更没有考核、评估权。SM的主要职责是保证团队工作的顺利开展，是作为协调人，以自己对敏捷的专业理解和实践经验，引领团队尽可能高效地完成迭代工作。其实定位是一个服务者的角色。在sprint执行过程中，通过观察和监测迭代运作情况，及时消除阻碍，并鼓舞大家的干劲，必要时给大家打打鸡血。&lt;/p>
&lt;h3 id="2-敏捷价值观和敏捷实践的推行">2. 敏捷价值观和敏捷实践的推行
&lt;/h3>&lt;p>作为Scurm大师，敏捷教练。SM的职责是贯彻敏捷的价值观，并把这个价值观传递给所有成员，并以自己的实践经验让团队的运作符合敏捷的原则。&lt;/p>
&lt;p>作为Scrum团队的牵头人，SM会需要负责迭代中的一些主要活动的组织，最主要的就是Scrum中的四大仪式会议。当然还会包括一些其他的需要协调组织的活动，比如一些紧急事项的讨论，重要的澄清、评审等等。在这些活动中，SM通常需要作为主持者，保证活动的效果，避免跑偏。&lt;/p>
&lt;h3 id="3-团队的防火墙">3. 团队的防火墙
&lt;/h3>&lt;p>SM职责中很关键的一点就是，SM需要作为团队的防火墙。这也是作为SM非常有挑战的地方。对一个迭代来说，迭代目标的达成是团队在sprint周期中最重要的事项，迭代过程中的工作都应该围绕这个目标展开。&lt;/p>
&lt;p>但在任何组织中，都难免可能出现一些干扰到团队成员工作的地方。比如一些领导会临时交办一些额外的任务，做临时的人员抽调等等。这时SM需要起到防火墙的作用，要能够将这些任务顶回去或者通过协调，寻求外部支持等保证当前的迭代目标不受到影响。一切以完成sprint的既定目标、保持团队战斗力为目的。而不是让团队成员直接被各种外部事务干涉，影响到当前迭代任务的完成。&lt;/p>
&lt;h2 id="开发团队-developers">开发团队 Developers
&lt;/h2>&lt;p>Scrum团队的主体其实就是开发者团队Developers Team。但这里的开发者，并不应该理解成传统理解的程序员。Scrum团队的定义，是团队应该具备完成产品目标的所有技能，所以这里的开发者团队，其实是一个笼统的概念。除了程序员，还会包含测试人员、视觉设计，可能还会有架构师、DBA、配置管理等等多种传统项目中不同的角色，但在Scrum中，都统称为Developers。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/agile_dev_team.png"
width="526"
height="525"
srcset="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/agile_dev_team_hu_13aa36aaf343a68a.png 480w, https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/agile_dev_team_hu_422feab2dceb9fcf.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>&lt;/p>
&lt;h3 id="1-具备各种完成目标的技能">1. 具备各种完成目标的技能
&lt;/h3>&lt;p>所以对于开发者团队来说，首要的职责，就是要具备完成产品目标的各项技能。包括设计、开发、测试、部署、配置等等。但这些工作，是被看作一个整体，不会明确对应到具体的单个成员。也就是团队中成员的技能可能会是综合的，一专多才，不会将团队整体能力建立在对个别成员的依赖上。&lt;/p>
&lt;p>相对传统研发，Scrum的开发团队成员，应该是跨职能的，每个成员都会有承担不同任务类型的技能要求和对应能力。简单来说，这里的开发者团队，每个成员的技能会有侧重点，会承担对应的任务类型，但不绝对，也有可能会要承担非主技能范畴的工作，一切以完成迭代工作目标为目的。&lt;/p>
&lt;h3 id="2-待办清单和需求的评估">2. 待办清单和需求的评估
&lt;/h3>&lt;p>开发团队的另一项职责是要评估PBI中的待办项。&lt;/p>
&lt;p>PBI中需求的实现终归还是开发团队负责，实现的方案、技术、团队的能力成熟度都会对完成每一条需求的实现工作量产生影响。&lt;/p>
&lt;p>而实现需求的工作量，又直接影响需求的完成和交付，所以在敏捷中，对需求的估算是一个重要的事项。&lt;/p>
&lt;p>这里的估算就是开发团队的主要职责之一。在Scrum中估算一般会发生在需求澄清会或者计划会时完成。可以通过经验估算法或者按计划扑克法尽可能客观地评估出每个需求的实现复杂度和工作量。&lt;/p>
&lt;p>估算的准确度会直接影响迭代目标的完成情况和迭代运作的健康水平。也是开发团队成熟度的一个指标。&lt;/p>
&lt;h3 id="3-目标分解和任务认领">3. 目标分解和任务认领
&lt;/h3>&lt;p>在PBI中，需求主要是业务层面的要求。但其具体的实现方案和实施，通常还需要拆分成不同的任务，比如前端任务、设计任务、后端任务、测试任务等等。这些都需要开发团队来完成任务的分解和通过自组织的认领、分配。这个工作一般会在计划会上，团队集体完成分派和认领。&lt;/p>
&lt;h3 id="4-完成承诺交付价值">4. 完成承诺，交付价值
&lt;/h3>&lt;p>最后就是完成迭代的承诺并交付产品增量，提供产品价值。保质保量地完成迭代计划时承诺的既定目标，是开发团队整体工作的核心。迭代的承诺达成率是一个Scrum团队是否成熟，Scrum敏捷落地是否成功，最直接的一个观察指标。&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>以上就是对Scrum框架中三大角色，其各自职责和要求的分享。用三句话提炼总结就是：&lt;/p>
&lt;ul>
&lt;li>PO负责让大家做对的事&lt;/li>
&lt;li>开发团队负责把事做成&lt;/li>
&lt;li>SM负责让团队把事做好&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/Pasted-20241025-3.png"
width="802"
height="461"
srcset="https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/Pasted-20241025-3_hu_cb425e019a29e02d.png 480w, https://chengxiaqiucao.github.io/post/039-%E6%95%8F%E6%8D%B7scrum%E4%B8%AD%E4%B8%89%E5%A4%A7%E8%A7%92%E8%89%B2/Pasted-20241025-3_hu_48e928fb088435c2.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="173"
data-flex-basis="417px"
>&lt;/p></description></item><item><title>敏捷研发模型知多少</title><link>https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/</link><pubDate>Fri, 18 Oct 2024 16:04:07 +0800</pubDate><guid>https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/</guid><description>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/scrum.png" alt="Featured image of post 敏捷研发模型知多少" />&lt;h2 id="前言">前言
&lt;/h2>&lt;p>在本系列上一篇博文 &lt;a class="link" href="https://chengxiaqiucao.github.io/post/37-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/" target="_blank" rel="noopener"
>《敏捷Agile概述，何为敏捷？》&lt;/a> 中，我们初步介绍了何为敏捷，敏捷提出的背景和为什么目前得到了广泛的应用。&lt;/p>
&lt;p>但敏捷本身，更多只是一种价值观，是一个思想层面的指引。在组织中实际应用，还是需要借助一些具体的实践模型来进行落地。随着敏捷的发展，其实涌现出非常多不同的实践模型，基于这些模型来组织我们的研发过程，都可以称之为&lt;code>敏捷研发&lt;/code>。&lt;/p>
&lt;p>下面，我们将重点梳理下，在敏捷研发实践中，比较常见的一些模型以及它们的优缺点。&lt;/p>
&lt;h2 id="团队级敏捷">团队级敏捷
&lt;/h2>&lt;p>敏捷从提出之初，更多是首先从开发者的个人视角出发，在软件开发、协作过程中，希望建立的合作关系和开发理念，这种合作，通常是团队内部的开发协作。所以敏捷初期的主要实践模型，主要还是面向团队级别的实践。&lt;/p>
&lt;h3 id="scrum">Scrum
&lt;/h3>&lt;p>Scrum其实提出得比较早，1995年，Jeff Sutherland和Ken Schwaber在他们的论文《Scrum_软件开发过程》中首次提出了Scrum框架。这两位也都参与了敏捷宣言的签署。&lt;/p>
&lt;p>随着敏捷的推广，Scrum被广为采用。根据最新版的敏捷状态报告(17th)，&lt;strong>&lt;code>Scrum&lt;/code>&lt;/strong> 依然是目前最流行的团队级敏捷框架，调查的团队中使用率超过6成。所以完全可以说，Scrum就代表了敏捷的主流实践。&lt;/p>
&lt;p>我们这个系列后续的敏捷实践分享，也将主要以 Scrum 为准来进行探讨。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018.png"
width="1525"
height="306"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018_hu_c535da9891895b11.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018_hu_a7541a9f2c7489d7.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="498"
data-flex-basis="1196px"
>&lt;/p>
&lt;p>Scrum 模型框架的的构成：&lt;/p>
&lt;ul>
&lt;li>核心过程：以Sprint 为固定研发周期&lt;/li>
&lt;li>三大角色定义：PO、Scrum Master、Dev Team&lt;/li>
&lt;li>三大工件： PBI（产品待办清单）、SBI（Sprint 待办清单）、Increment（产品增量）&lt;/li>
&lt;li>四大工作仪式：计划会、站会、评审会、回顾会&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/scrum.png"
width="1278"
height="550"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/scrum_hu_6a6082a0359cb0b3.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/scrum_hu_ffcc481533b75ec8.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="232"
data-flex-basis="557px"
>&lt;/p>
&lt;p>Scrum框架强调以一个固定的短研发周期（sprint），定期地交付产品的增量，通过四种不同的工作仪式来跟踪、协作日常工作，强调团队自组织和紧密、机动的合作关系。&lt;/p>
&lt;h3 id="kanban">Kanban
&lt;/h3>&lt;p>Kanban 其实起源更早，来源于上世纪四十年代丰田汽车的生产管理理论。强调的是用一种可视化的方式来提高工作效率，同时便于工作流的调整和优化。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-1.png"
width="1306"
height="834"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-1_hu_a35f1d4b21617708.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-1_hu_ed894e1a9f9bc70.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="156"
data-flex-basis="375px"
>&lt;/p>
&lt;p>Kanban的核心原则是通过可视化的看板向所有成员清晰地展示项目进度和工作分配情况，限制在制品的数量避免过载和积压导致资源浪费，在看板上定义并区分出清晰的工作流程，如任务的创建、分派、执行、测试和完成等。 强调持续集成，通过定期回顾来进行持续改进。&lt;/p>
&lt;h3 id="极限编程xp">极限编程（XP）
&lt;/h3>&lt;p>极限编程（Extreame Programming）简称 XP，是Kent Beck在1996年提出并在自己参与的C3项目中进行了实践。&lt;/p>
&lt;blockquote>
&lt;p>Kent Beck 进行 XP 实践的C3项目，是克莱斯勒公司的一个薪酬管理系统，项目参与人包括多位后来敏捷运动的重要人物，如敏捷宣言的另两位签署人Ron Jeffries， Ward Cunningham也都参与过该项目。但该项目其实并不成功，延期多个月才交付，并且在运作了一段时间后因为存在严重性能问题，之后被彻底关闭。还是比较讽刺的。&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-4.png"
width="1368"
height="1004"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-4_hu_1c56dd46f938dff6.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-4_hu_942a87eedb650fc1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="327px"
>&lt;/p>
&lt;p>XP 主要从团队运作、研发过程和开发技术实践三个维度， 定义了13种实践原则，包括持续集成、结对编程、测试驱动开发、客户验收等等，对后续敏捷宣言以及敏捷的12条原则有重要影响。&lt;/p>
&lt;h3 id="精益研发lean">精益研发（Lean）
&lt;/h3>&lt;p>Lean Development，精益研发，其实也是脱胎于丰田的精益生产管理理论。&lt;/p>
&lt;p>后来发展到软件领域，主要包括以下7大核心：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>消除浪费：Eliminate Waste&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内嵌质量：Build Quality In&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创造知识：Create Knowledage&lt;/p>
&lt;/li>
&lt;li>
&lt;p>延迟决策：Defer Commitment&lt;/p>
&lt;/li>
&lt;li>
&lt;p>快速交付：Deliver Fast&lt;/p>
&lt;/li>
&lt;li>
&lt;p>尊重他人：Respect People&lt;/p>
&lt;/li>
&lt;li>
&lt;p>整体优化：Optimize Whole&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>精益更强调在向用户交付价值的同时尽可能消除浪费，并从更整体的业务环境来看待研发。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-2.png"
width="1297"
height="961"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-2_hu_7c1207c538bfecd4.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-2_hu_2e9089947fcea824.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="323px"
>&lt;/p>
&lt;h3 id="水晶方法crystal">水晶方法（Crystal）
&lt;/h3>&lt;p>水晶法是Alistair Cockburn于 1991 年为 IBM 开发的一种团队协作和沟通制定指导方针，Alistair Cockburn被认为是敏捷早期的普及者，敏捷宣言发表后，包括Crystal在内的方法开始走入大家的视野。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-3.png"
width="1216"
height="614"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-3_hu_a95d7dfc8b8a79f8.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/Pasted-20241018-3_hu_977463797ad11c97.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="475px"
>&lt;/p>
&lt;p>水晶方法可细化为&lt;strong>透明水晶方法&lt;/strong>（Crystal Clear）、&lt;strong>黄色水晶方法&lt;/strong>（Crystal Yellow）、&lt;strong>橙色水晶方法&lt;/strong>（Crystal Orange）以及&lt;strong>红色水晶方法&lt;/strong>（Crystal Red）。这几种水晶方法论按照项目重要程度以及参加人员规模进行划分。&lt;/p>
&lt;ul>
&lt;li>Crystal Clear ： 6人左右的团队&lt;/li>
&lt;li>Crystal Yellow：20人左右&lt;/li>
&lt;li>Crystal Orange：40人左右&lt;/li>
&lt;li>Crystal Red：80人左右&lt;/li>
&lt;/ul>
&lt;p>Crystal方法中同样也强调了7大主要特征：&lt;/p>
&lt;p>&lt;strong>1. 经常交付&lt;/strong>&lt;/p>
&lt;p>&lt;strong>2. 反思改进&lt;/strong>&lt;/p>
&lt;p>&lt;strong>3. 渗透式交流&lt;/strong>&lt;/p>
&lt;p>&lt;strong>4. 个人安全&lt;/strong>&lt;/p>
&lt;p>&lt;strong>5. 焦点&lt;/strong>&lt;/p>
&lt;p>&lt;strong>6. 与专家、用户建立方便的联系&lt;/strong>&lt;/p>
&lt;p>&lt;strong>7. 自动化测试、配置管理和经常集成的技术环境&lt;/strong>&lt;/p>
&lt;p>相比于XP、Scrum等，Crystal纪律性较弱，它的主要原则依据团队规模不同会动态变化，所以实际中被应用得并不多。&lt;/p>
&lt;hr>
&lt;p>除了以上5种常见的团队敏捷框架外，还有类似DSM、FDD等团队级别的敏捷实践模型，但目前应用最广的其实主要还是Scrum。&lt;/p>
&lt;p>敏捷模型虽然多种多样，实际应用其实也并没有非此即彼的排斥性，因为它们更多还是敏捷思想的落地，我们理解这些模型定义背后的出发点，取长补短应该才是更加务实地去进行敏捷实践的方式。&lt;/p>
&lt;p>当然，现代软件的规模其实越来越庞大，仅仅依赖一个小型团队，并不能完成软件产品的系统级研发，这些基于团队级别的敏捷框架，如果应用到大型的软件系统，在组织级别的敏捷，通常并不适用，因此针对这种级别的敏捷，又出现了 &lt;strong>大规模敏捷框架&lt;/strong>， 下一篇我们会继续分享敏捷框架中的这部分框架介绍&lt;/p>
&lt;hr>
&lt;h2 id="大规模敏捷">大规模敏捷
&lt;/h2>&lt;p>以上敏捷模型，是基于敏捷提出之初的一些理念发展而来，主要是面向小规模团队的敏捷实践。但是现代软件规模其实越来越庞大，仅仅依赖一个小型团队，并不能完成软件产品的系统级研发。所以为了整合多个通过的小型团队，敏捷组织又提出了多种不同的大规模敏捷模型。&lt;/p>
&lt;p>相比 Scrum 在团队级别敏捷中绝对优势的主流地位，大规模敏捷框架则显得百花齐放，并没有某种模型占据绝对主流。下面我们介绍其中比较知名的几种规模敏捷框架。&lt;/p>
&lt;h3 id="safe">SAFe
&lt;/h3>&lt;p>基于最新的敏捷状态报告，SAFe是目前应用最多的大规模敏捷框架，但也只有 22% 左右的占有率。&lt;/p>
&lt;p>SAFe是 Sacled Agile Framework 的缩写， 诞生于2011年，到目前已经更新到 6.0 版本。&lt;/p>
&lt;p>它提供了一整套结构化的方式来对敏捷实践进行扩展，并提供了四种不同的配置以适应不同级别，分别是：&lt;/p>
&lt;ul>
&lt;li>Essentail：团队级别（中小型项目）&lt;/li>
&lt;li>Large Solution：大型解决方案级别（大型项目）&lt;/li>
&lt;li>Portfolio：投资组合级别（产品线）&lt;/li>
&lt;li>Full：组织级别（企业级）&lt;/li>
&lt;/ul>
&lt;p>SAFe 框架中，在Scrum 迭代（Sprint）的基础上，引入了PI（Program Increment）和敏捷发布火车（ART）的概念，以一个包含数个 Sprint 的周期，构成PI，通过多个不同Scrum团队的合作，来共同致力完成一个较大规模的产品增量。&lt;/p>
&lt;p>在 Scrum 定义的三大角色PO、Scrum Master、Dev Team之外，SAFe中又定义了产品经理PM（product manager）、发布列车工程师RTE（release train engineer）、方案架构师SA（Solution Architect）、业务负责人BO（Business Owner）等新角色，以管理多个团队和更大规模的产品路线图、技术架构以及跨部门的协调。&lt;/p>
&lt;p>SAFe强调的四个核心价值观：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>一致性（Alignment）&lt;/strong>：确保组织中的每个人都朝着相同的方向努力，清晰的目标和愿景是关键。&lt;/li>
&lt;li>&lt;strong>内置质量（Built-in Quality）&lt;/strong>：从一开始就关注质量，避免后期修复，确保产品在每个开发阶段都符合高质量标准。&lt;/li>
&lt;li>&lt;strong>透明度（Transparency）&lt;/strong>：创建一个开放、透明的工作环境，鼓励团队成员间的沟通和反馈。&lt;/li>
&lt;li>&lt;strong>程序执行（Program Execution）&lt;/strong>：通过一致的开发和交付节奏来确保程序和产品的顺利交付。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/SAFe.png"
width="1512"
height="816"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/SAFe_hu_3d8edc8b78a95858.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/SAFe_hu_c6d0437558eac366.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="185"
data-flex-basis="444px"
>&lt;/p>
&lt;p>SAFe 以其比较完备的、适应不同规模组织的实践方法论，以及广泛的认证推广，目前在规模敏捷领域，得到越来越多的应用。&lt;/p>
&lt;h3 id="sos">SoS
&lt;/h3>&lt;p>SoS （Scrum of Scrums）其实是一个非常早的规模敏捷模型。2001年（敏捷宣言发布那一年）就由Scrum创建者 Jeff Sutherland提出，并在GE的项目实践中进行了应用。&lt;/p>
&lt;p>这个框架其实理解比较简单。&lt;/p>
&lt;p>本质上是一个同步机制，每个Scrum团队派出一个成员，通常称为&lt;strong>大使&lt;/strong>，这些人再组成一个Scurm，也就是SoS。这个团队同样参照Scrum的原则来运作，有Sprint，站会，backlog等。但SoS的主要关注事项是跨团队的进展、障碍和协调。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/SoS.png"
width="789"
height="567"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/SoS_hu_7a4cf1050dd08e0c.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/SoS_hu_da1168e87222c7ec.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="139"
data-flex-basis="333px"
>&lt;/p>
&lt;p>SoS也是目前规模化敏捷中采用比较多的方式，但是它的规模一般也不会太大，5~7个Scrum小组的规模。在其之上还扩展出SoSoS，但这个复杂度就进一步上升，运作起来容易混乱。&lt;/p>
&lt;h3 id="nexus">NEXUS
&lt;/h3>&lt;p>另一个规模框架Nexus， 是由scrum的另一个提出者，scrum之父Ken Schewaber创建，然后通过&lt;a class="link" href="https://scrum.org" target="_blank" rel="noopener"
>scrum.org &lt;/a> 于2015年推出的，可以说属于Scrum半官方性质的规模敏捷框架。它的提出时间较晚，目前应用得很少，敏捷状态报告中看到只有约 1% 的应用率，推广不利。&lt;/p>
&lt;p>Nexus主要是在Scrum的基础上，针对更大范围的团队合作进行了少量改进。框架上本身没有太大的变化，也是主要有几点不同：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>它的主要工作会在跨团队层面完成，包括sprint计划、复盘、回顾， 但站会是分小组来开。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由3-9个Scrum team组成Nexus team。 规模更大就会难以组织。这些不同 scrum小组会在同一个迭代周期来运作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Nexus引入了一个Nexus 集成团队。这个集成团队，职能和SoS差不多，主要负责不同scrum团队间的工作协调，进展同步。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Nexus 共享同一份产品backlog，只有一个PO角色，在召开计划前，会召开跨团队的需求提炼会。 而工作成果也是同一个increment&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/nexus.png"
width="2118"
height="902"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/nexus_hu_5893539621207498.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/nexus_hu_a6d516e1861395c3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="234"
data-flex-basis="563px"
>&lt;/p>
&lt;p>这个框架对团队间的协同要求非常高，而且很多事项是多个Scrum小组共同参与完成并同步，所以效率上较难保证，这可能也是这个框架难以得到更多应用的主要原因。&lt;/p>
&lt;h2 id="less">LeSS
&lt;/h2>&lt;p>LeSS（Large-Scale Scrum）是一种轻量级的敏捷框架，旨在将Scrum扩展到多个团队，同时保持Scrum的核心原则和简单性，于2005年提出。也是比较早的一个框架&lt;/p>
&lt;p>和NeXus类似， LeSS敏捷框架采用同一个产品列表，所有敏捷团队在同一个Sprint中工作，各团队协同完成这个冲刺。&lt;/p>
&lt;p>但在 LeSS 中，Sprint开始时有2个 Sprint 计划会，第一个冲刺计划会中由各团队派人参加讨论和管理彼此间的依赖及协作工作。第二个 Sprint 才是Scrum团队自己的冲刺。在 Sprint 结束时，同样有2个回顾会，一个是敏捷团队内部的回顾会，一个是整个大型敏捷项目的回顾会。&lt;/p>
&lt;p>LeSS灵活度比较高，相比Scrum来说，保留了Scrum的所有角色并且没有引入新的角色，更加依赖团队的自组织能力。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/LeSS.png"
width="1449"
height="684"
srcset="https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/LeSS_hu_5d591f5439e8456f.png 480w, https://chengxiaqiucao.github.io/post/038-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/LeSS_hu_91bb8d69937a3abb.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="508px"
>&lt;/p>
&lt;p>相比SAFe等其他框架，LeSS不会引入额外的角色或过多的其他流程，而是通过简化结构来扩展敏捷，但也造成了落地时可操作性上的困难。目前最新的敏捷状态报告中，应用率在2%&lt;/p>
&lt;hr>
&lt;p>以上就是关于敏捷各种实践模型的梳理和总结。帮助大家可以对敏捷的应用和当前的发展状态，有一个整体上的认知。&lt;/p>
&lt;p>欢迎继续关注这个系列，努力持续更新中~&lt;/p></description></item><item><title>敏捷Agile概述，何为敏捷？</title><link>https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/</link><pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate><guid>https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/</guid><description>&lt;img src="https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_principle.png" alt="Featured image of post 敏捷Agile概述，何为敏捷？" />&lt;p>Agile 敏捷研发可能是现今 IT行业最为流行，也是被广为应用的研发模型。但实际运作中，似乎和预期总有不少的偏差。所以开一个系列来详细梳理下和 Agile 敏捷研发相关的知识并谈一谈自己的 Agile 的理解。&lt;/p>
&lt;h2 id="敏捷的起源">敏捷的起源
&lt;/h2>&lt;p>要谈敏捷，首先我们还是要看看它被提出的背景是什么。&lt;/p>
&lt;h3 id="软件危机">软件危机
&lt;/h3>&lt;p>我们知道，在上世纪70年代到90年代，计算机逐渐开始成为普通消费品，开始进入千家万户。以此为契机，计算机软件行业也开始高速蓬勃发展。但同时，随着软件应用规模的增大，其复杂性也急剧增强，这个阶段发生了大量因为软件导致的问题，也就是现在称为的“软件危机”时期。&lt;/p>
&lt;p>软件危机主要表现为：&lt;/p>
&lt;ul>
&lt;li>超预算&lt;/li>
&lt;li>超时&lt;/li>
&lt;li>低效&lt;/li>
&lt;li>低质量&lt;/li>
&lt;li>不满足需求&lt;/li>
&lt;li>无法管理、难以维护代码&lt;/li>
&lt;li>永远无法交付&lt;/li>
&lt;/ul>
&lt;p>而为了应对上面&lt;code>软件危机&lt;/code> 中产生的问题，&lt;code>软件工程&lt;/code> 开始作为一个学科，快速发展，针对软件研发的各种理论、论文开始涌现。这其中，从制造业的工程管理转化而来的 &lt;code>瀑布模型&lt;/code> 以及其衍生而来的 &lt;code>V模型&lt;/code>, &lt;code>W模型&lt;/code> 占据了主流，影响直到今天&lt;/p>
&lt;h3 id="瀑布模型">瀑布模型
&lt;/h3>&lt;p>但是瀑布模型也存在很明显的缺点，也就是它是一种线性的研发流程，一些影响发布的问题往往要到后期才能暴露。而且这种模型，对风险控制的要求很高，看重计划和流程，所以文档、规范要求非常严格，各种繁文缛节也造成了很大的效率问题。使用瀑布模型，但软件项目失败的例子也依然层出不穷。&lt;/p>
&lt;h3 id="互联网兴起">互联网兴起
&lt;/h3>&lt;p>另外一个背景，就是90年代互联网的兴起。基于互联网的应用，和传统的桌面应用不同，软件发布即送达，且用户群极为庞大。另外互联网的免费策略，使得用户切换同类产品的成本极低，所以互联网应用先天就是一个需求变化极为频繁，对于产品的迭代、更新有极高要求的行业。传统重流程的瀑布模型已经很难适应互联网产品的这种高速的要求。&lt;/p>
&lt;p>正是在以上背景下，敏捷模型应运而生。&lt;/p>
&lt;h2 id="敏捷的历史">敏捷的历史
&lt;/h2>&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_history.png"
width="1002"
height="354"
srcset="https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_history_hu_12ec5f95eaca2ba8.png 480w, https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_history_hu_ddd98d31a54daa40.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="283"
data-flex-basis="679px"
>
&lt;a class="link" href="https://www.smartsheet.com/content/agile-methodologies" target="_blank" rel="noopener"
>图源自smartSheet&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>早在上世纪40年代，丰田在它的汽车生产管理上，就采取过不少现在敏捷研发中推崇的理念。最典型的就是kanban。这个kanban的主要作用就是通过可视化的方式管理生产过程和物料，让生产根据需求而不是早期的计划来推动。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>到90年代了，互联网开始兴起。1991年，Crystal水晶方法提出，1994年 动态系统开发方法（dynamic system develop methodology）DSDM被提出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>1995年, Scrum正式作为一种研发模式被提出，由Scrum之父 ken schwaber 和 Jeff Sutherland共同发表。这也是现在敏捷研发中应用最广泛的一种模式，几乎是敏捷的代名词。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>1996年，XP极限编程 发表，作者是Kent Beck。他也是后面发表的敏捷宣言中排名第一的牛人。敏捷中的很多原则其实都来源于极限编程。题外话，Kent还是著名自动化测试框架&lt;code>Junit&lt;/code>的作者。可以说后世的很多自动化框架都受Junit的重要影响。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2001年，敏捷宣言发表，包括ken，Jeff，kent，还有marting fowler等17个软件开发领域的专家，在美国犹他的雪鸟滑雪胜地共同签署发表。也从此，敏捷开始逐渐走向主流。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2005， 大型敏捷框架LeSS( large scale scrum) 框架被提出&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2006年， 第一届敏捷中国大会召开，由著名的咨询公司ThoughtWorks牵头。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2009年，敏捷认证体系DA (Disciplined Agile) 建立&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2011年，大规模敏捷框架 SAFe(Scaled Agile Framework) 被提出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2018年， BizDevOps被提出，旨在打通业务到研发的通路.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>发展到现在，敏捷依然在全球范围内广泛传播，但同时，敏捷也暴露了一些本身的问题，所以 Agile 2.0 也已经开始被提及和讨论。&lt;/p>
&lt;h2 id="敏捷宣言">敏捷宣言
&lt;/h2>&lt;p>在敏捷的发展中，敏捷宣言的发表是一个里程碑的事件。 从此 敏捷开始逐步走入实践领域并逐步得到广泛应用&lt;/p>
&lt;p>&lt;a class="link" href="https://agilemanifesto.org/" target="_blank" rel="noopener"
>敏捷宣言官网&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_mani_sign.png.png"
width="1077"
height="1027"
srcset="https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_mani_sign.png_hu_9e2093298f7f66f7.png 480w, https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_mani_sign.png_hu_e27be009a6c26d10.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="251px"
>&lt;/p>
&lt;p>&lt;strong>个体和互动高于流程和工具&lt;/strong>： 敏捷更加强调个体的作用，强调个体的主观能动性比靠流程和工具能更加高效和有用&lt;/p>
&lt;p>&lt;strong>工作的软件高于文档&lt;/strong>：这里说详尽的文档，就是指的是很重的僵化的文档，写出来也没多少人真的去看的繁文缛节。而工作的软件，是指能实际运行的软件，&amp;ldquo;百闻不如一见&amp;rdquo;&lt;/p>
&lt;p>&lt;strong>客户合作高于合同谈判&lt;/strong>： 强调的是沟通，开发者是软件生产者，客户是使用者，二者更多直接的沟通才能更好地去确定做的东西和你要的东西是不是一样的，而不是提前靠所谓的合同来约定&lt;/p>
&lt;p>&lt;strong>响应变化高于遵循计划&lt;/strong>，就是变化是肯定存在的，一个好的软件开发过程应该去适应这种变化，而不是按部就班一条道走到黑。&lt;/p>
&lt;p>&lt;em>&lt;strong>签署敏捷宣言的17位签署人，都是在其领域内有很高成就和声望的专家，这也为敏捷的广泛传播打下了良好的基础。 但是这17人主要都是软件开发领域的专家，对于整个软件产品的生命周期而言，其他角色的缺位，也为敏捷本身的适应性埋下了局限性上的不足。&lt;/strong>&lt;/em>&lt;/p>
&lt;h2 id="敏捷-12-原则">敏捷 12 原则
&lt;/h2>&lt;p>除了敏捷宣言外，敏捷还针对实际的应用提出了12项基本原则&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_principle.png"
width="1125"
height="698"
srcset="https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_principle_hu_917db489f0bf6dd5.png 480w, https://chengxiaqiucao.github.io/post/037-%E6%95%8F%E6%8D%B7%E6%A6%82%E8%BF%B0/agile_principle_hu_d972b3b1d6f1aacf.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="386px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>客户满意&lt;/strong> ： 以用户的价值位导向。客户满意意味着软件的价值得到体现，软件体现出价值是我们研发软件的最终目标。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>拥抱变化&lt;/strong>： 变化是一定存在的，与其控制变化，不如接受变化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>频繁交付&lt;/strong>： 小步快跑，快速交付，快速得到反馈，方便及时纠偏&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>相互合作（业务和研发）&lt;/strong>： 业务的需求方，用户代表和生产者、开发团队应该一起工作。及时确认&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>积极的团队&lt;/strong>：自我激励的团队，团队本身是积极主动的，没有内耗&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>面对面&lt;/strong>：及时沟通，百闻不如一见&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可工作的软件&lt;/strong>：所见即所得&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>稳定的节奏&lt;/strong>：固定的节奏能更好地形成默契&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>好的设计（技术卓越）&lt;/strong>：强调软件开发的内功，通过的更好的设计解决问题，降低风险。强调技术卓越&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>简单即美&lt;/strong>：软件不应该过度开发，逐步满足用户的需求&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>自组织&lt;/strong>：研发过程的控制权要在开发者自己手中，不要有各种行政命令。  Scrum之父ken 曾经明确表明过，敏捷的目的就是要干掉经理这个职位。😂😂&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>反思和调整&lt;/strong>: 这条是自我组织的补充，敏捷运作过程种，不可避免也会出现各种失败或者运作不畅的地方，这时要及时回顾和反思，及时调整补救。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="笔者对敏捷的看法">笔者对敏捷的看法
&lt;/h2>&lt;p>敏捷虽然如今在业界广为应用，但也并不是银弹，我们依然要辩证地看待敏捷，天底下没有放诸四海而皆准的理论和方法。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>它提出的理念和发展出的一些原则和实践出发点是极好的，但并不是所有的情况都适用，应用敏捷依然要根据产品、项目的实际情况来确定应用方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从敏捷宣言和原则中其实也看出来，敏捷本身更多传递的是一种价值观，是软件研发理想的方向，而不是一套方法论。它不是一个指导项目如何运作的执行层面的方法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>敏捷的提出，更多是从软件开发角度来思考的，是这些开发大牛们基于软件开发视角出发得出的思考结论。但敏捷应用在产品领域，很多做法是过于理想化的，比如和客户一起工作，自组织团队等等，特别在一起传统企业，会面临极大阻力。非组织层面的根本性转变是不可能进行推进的。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>所以，敏捷本身不是银弹，它也不是方法论。而是一种文化层面的思想，真正理想地得到应用，是需要组织层面的变革方可推进，并不是一个可以从十数人的小团队自下而上推行就可以成功应用的实践。&lt;/p>
&lt;hr>
&lt;p>关于敏捷实际应用，后续还会针对 Scurm 框架进行更多分享。敬请关注。&lt;/p>
&lt;p>秋草观“测”台，观察测试业。（公众号：秋草说测试）&lt;/p></description></item><item><title>软件分支策略和集成模式梳理</title><link>https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</link><pubDate>Fri, 27 Sep 2024 00:00:00 +0000</pubDate><guid>https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</guid><description>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/branch.png" alt="Featured image of post 软件分支策略和集成模式梳理" />&lt;h2 id="前言">前言
&lt;/h2>&lt;p>软件代码是任何一个软件研发团队的核心资产。而软件的分支管理就是团队中多人合作时，如何协调处理不同人员的代码同步、集成并解决冲突的主要方式。&lt;/p>
&lt;p>本文根据软件大牛Martin Flower的分支模型阅读笔记整理&lt;/p>
&lt;h2 id="基础模式">基础模式
&lt;/h2>&lt;h3 id="源分支">源分支
&lt;/h3>&lt;p>所有修改都记录到同一分支&lt;/p>
&lt;p>分支的定义：
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927.png"
width="701"
height="259"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927_hu_d4d3068e3f2598bc.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927_hu_a8449443230e7ad4.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="270"
data-flex-basis="649px"
>
创建分支：
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-1.png"
width="916"
height="590"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-1_hu_6098059e69a69708.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-1_hu_76295e80e62f86e2.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;p>不同的两个开发者基于主分支拉去各自的开发分支：
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-2.png"
width="872"
height="439"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-2_hu_f52032f3cbeccd64.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-2_hu_a4a8cfd6c8cb1d23.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;p>Jonny LeRoy 指出我们绘制分支线时，其实忽略了随着时间，导致的复杂度提升
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-3.png"
width="883"
height="521"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-3_hu_3f48b100679b4356.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-3_hu_b114d269317d2d1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="406px"
>&lt;/p>
&lt;h4 id="主干的定义">主干的定义：
&lt;/h4>&lt;p>&lt;strong>Master、Trunk&lt;/strong>&lt;/p>
&lt;p>是反映产品当前实际状态的唯一公用分支&lt;/p>
&lt;p>可以随时获得当前产品版本状态，并基于此进行开发&lt;/p>
&lt;h4 id="健康分支">健康分支：
&lt;/h4>&lt;p>为每一次提交进行自动化构建、测试，确保没有在当前分支引入故障（可工作的无故障分支）&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ol>
&lt;li>健康的公用分支，可以避免从这个分支上拉取的新分支工作在错误的基础上&lt;/li>
&lt;li>健康分支更易入直接发布到产品&lt;/li>
&lt;li>随时保持一个健康分支能极大降低集成的工作量并减少潜在风险。&lt;/li>
&lt;li>便于进行差异调试。（可以将调试失败的commit去除，仅保留健康的commit）&lt;/li>
&lt;li>在集成到主干时如果出现问题，就可以非常明确地确认是冲突导致而非代码错误&lt;/li>
&lt;/ol>
&lt;p>可能是公用分支、也可以是自己的分支。
自测代码是健康分支的核心，自测应可以快速得到结果（分钟级）&lt;/p>
&lt;h2 id="集成模式">集成模式
&lt;/h2>&lt;h3 id="主线集成">主线集成
&lt;/h3>&lt;p>开发从主干拉取代码进行开发，集成，并将健康的更改推送回主干
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-4.png"
width="1086"
height="253"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-4_hu_13469664a5d85941.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-4_hu_e78cbd5209ceaec2.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="429"
data-flex-basis="1030px"
>
从主干拉取分支到本地，并在本地分支上进行开发&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-5.png"
width="1058"
height="302"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-5_hu_2e852c5d48edaa74.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-5_hu_95b356c339ee0ff5.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="350"
data-flex-basis="840px"
>
开发过程中，其他开发已经提交了变更到主干分支
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-6.png"
width="1021"
height="313"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-6_hu_1c0b4402c038b960.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-6_hu_9c1d222d40356939.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="326"
data-flex-basis="782px"
>
此时如需向主干提交，则首先需要合入其他的变更
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-7.png"
width="1067"
height="334"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-7_hu_71458497204245e0.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-7_hu_73d9f4f1fb973746.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="319"
data-flex-basis="766px"
>
有时，本地的修改和已经提交的变更会有冲突，此时需要先解决冲突
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-8.png"
width="1055"
height="322"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-8_hu_4e9aad39450c55f7.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-8_hu_aafa4ba988541945.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="327"
data-flex-basis="786px"
>
再重新将修改并自测后的健康代码提交到主干分支&lt;/p>
&lt;p>使用主干时，意味着我们会实行&lt;strong>主干集成模式&lt;/strong>&lt;/p>
&lt;h3 id="特性分支">特性分支
&lt;/h3>&lt;p>为每一个功能特性拉取它独立的分支，并在feture完成后集成回主干&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-9.png"
width="933"
height="366"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-9_hu_74b95c7ee6bcc59d.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-9_hu_32c0ddbd05ee967a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="254"
data-flex-basis="611px"
>
从主干拉取不同的特性分支并分别进行开发
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927175324.png"
width="952"
height="350"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927175324_hu_12d1719d35d77f7d.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927175324_hu_afcf5cdf5e2a68df.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="652px"
>
开发过程中会持续从主干拉取最新代码，如果有其他功能变更，要及时进行集成解决冲突（本地）。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-10.png"
width="885"
height="360"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-10_hu_20dd7f755d09ae7a.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-10_hu_f29cffe845a9b55e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="245"
data-flex-basis="590px"
>
特性完成开发后，集成回主干。（受影响的冲突已在本地解决，所有其他特性分支上直接拉取变更，不会存在冲突需要解决）&lt;/p>
&lt;h3 id="低频集成">低频集成
&lt;/h3>&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-11.png"
width="1063"
height="335"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-11_hu_a05c68bed305ab44.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-11_hu_9daf312ea04c227f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="317"
data-flex-basis="761px"
>&lt;/p>
&lt;p>两条独立的开发分支上分别进行了几次本地提交，但没有向主干推送
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-12.png"
width="1015"
height="333"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-12_hu_26b3824f0bf7a0e8.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-12_hu_13f0a04d517dcf1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="304"
data-flex-basis="731px"
>
主干上合入了变更&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-13.png"
width="1064"
height="338"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-13_hu_78ae884a57bcb222.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-13_hu_ed2fa66bb5a8fc68.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="314"
data-flex-basis="755px"
>
开发分支需要拉取变更并合入到本地分支（解决冲突）&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-14.png"
width="1067"
height="342"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-14_hu_d54a092c550a112e.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-14_hu_819f06a28caca5af.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="311"
data-flex-basis="748px"
>
分支A上继续完成了4，5两个提交，然后推送大主干
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-15.png"
width="1052"
height="321"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-15_hu_450e64d3035717ed.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-15_hu_11fe33b1a4c666ee.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="327"
data-flex-basis="786px"
>
分支B上完成了4，5，6几个提交后，需要在本地合入主干上A的提交，集成后推送到主干。（本地合入的大小代表工作量）&lt;/p>
&lt;h3 id="高频集成">高频集成
&lt;/h3>&lt;p>每次提交都向主干进行集成和推送呢？
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-16.png"
width="1057"
height="312"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-16_hu_af2461a8a4eeb452.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-16_hu_c2915e7288889683.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="338"
data-flex-basis="813px"
>
V完成第1次提交后就推送回主干&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-17.png"
width="1025"
height="324"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-17_hu_3bd84e894d966406.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-17_hu_5e73f50ccccec7f2.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="316"
data-flex-basis="759px"
>
S在完成第1次提交后就进行本地合入，并推送回主干
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-18.png"
width="1036"
height="327"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-18_hu_81fb63d9bcbd438c.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-18_hu_a427bc1c01c61ba7.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="316"
data-flex-basis="760px"
>
S的第2次推送，主干没有变更，没有本地合入工作
V完成第2次提交和本地合入，推送
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-19.png"
width="1074"
height="323"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-19_hu_3b84f8f85861beda.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-19_hu_711e4f940a79bb3e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="332"
data-flex-basis="798px"
>
S的第3次提交，需要本地合入，推送
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-20.png"
width="1078"
height="345"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-20_hu_92be6eb77101a99a.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-20_hu_3e1c6ae613104a6.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="312"
data-flex-basis="749px"
>
如此，每次本地的提交，都会向主干进行推送&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-21.png"
width="1021"
height="401"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-21_hu_d27d5d59cebb2a27.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-21_hu_e4a65e5ebd0a4c1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="254"
data-flex-basis="611px"
>&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-22.png"
width="1053"
height="429"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-22_hu_f963bcda7ec114e5.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-22_hu_9b20a62829346550.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="245"
data-flex-basis="589px"
>&lt;/p>
&lt;p>比较二者，高频集成会有更多的本地集成工作，但这些集成的工作量比低频集成低得多。
同时，比工作量减少更重要的是，这样做减少了风险。（虽然大多情况下，进行大的合入也能顺利完成，但有时却会有严重的冲突问题难以解决。这种情况，偶发的巨大问题比常规的小问题更糟糕）
如果每次常规集成10分钟，但50次集成合在一起要6小时，看起来6小时比500分钟还是要少，但是这会导致&lt;em>集成恐惧&lt;/em>（if it hurt，do it more often）&lt;/p>
&lt;p>而且高频集成模式下，可以更早发现代码间的冲突情况，并避免在冲突代码在后期才发现而导致中间持续产生了很多本不应该存在的更多冲突代码。&lt;/p>
&lt;p>源码控制系统其实更多是一个沟通平台，可以意识到其他团队成员的工作&lt;/p>
&lt;h3 id="持续集成">持续集成
&lt;/h3>&lt;p>开发者一旦完成一个健康的提交，就会尽快完成主干集成，一般不超过1天。&lt;/p>
&lt;p>（如果高频集成更有效率且可实施，但使用特性分支，意味着限制了变更不能比一个特性更小，那么集成频次就成了问题？）&lt;/p>
&lt;p>持续集成-只要特性上的开发是有进展并且是健康的，就可以向主干集成。唯一的原则就是每天都要进行集成（甚至更短）&lt;/p>
&lt;p>开发团队需要习惯在主干上存在未完成特性的情况并考虑如何在产品中不暴露这些特性。（通过隐藏入口、配置控制），有时我们还可以实现灰度发布。&lt;/p>
&lt;p>在持续集成模式下，开发着往往不需要创建自己的特性分支，只要在本地的主干分支上工作即可。&lt;/p>
&lt;p>特性分支和持续集成的区别不在于是否有特性分支存在，而在于何时向主干集成。&lt;/p>
&lt;p>两者的比较：&lt;/p>
&lt;p>两种模式的差异更多取决于特性的大小，如果特性足够小（一天以内可以完成），就可以同时实行特性分支和持续集成。&lt;/p>
&lt;p>特性分支最明显的问题在于合并的工作量和不确定性，然而更大的问题是它可能阻止重构。重构是软件优化最有效的途径，但是重构会产生冲突，当解决冲突工作量太大时，重构往往需要极大的勇气。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>功能分支&lt;/th>
&lt;th>持续集成&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>- 可以将某个功能中的所有代码作为一个单元进行质量评估&lt;br>- 功能完成后才将功能代码添加到产品中&lt;br>- 合并频率较低&lt;/td>
&lt;td>- 支持比特征长度更高的频率集成&lt;br>- 减少发现冲突的时间&lt;br>- 规模较小的合并&lt;br>- 鼓励重构&lt;br>- 需要致力于健康的分支（从而实现自我测试代码）&lt;br>- 科学证据表明它有助于提高软件交付性能&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="特性分支和开源软件">特性分支和开源软件
&lt;/h4>&lt;p>github的特性分支？pull request模式
上下文不同：分散、不定时、团队成员不了解 vs 全职、熟悉的团队成员、可靠&lt;/p>
&lt;p>提交的审核review&lt;/p>
&lt;ul>
&lt;li>代码审核·&lt;/li>
&lt;li>集成受阻&lt;/li>
&lt;li>模块化的重要性&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="发布模式">发布模式
&lt;/h2>&lt;p>主干分支是活动分支，代码持续在其上开发。如果能保持主干的健康状态，任何人都可以从一个稳定的基础开始自己的工作。
而且足够健康的话，也可以直接从主干分支进行产品的发布&lt;/p>
&lt;p>&lt;img src="https://i-blog.csdnimg.cn/blog_migrate/b1dee5579befaf2a2e007af2dbb2c29f.png#pic_center"
loading="lazy"
alt="在这里插入图片描述"
>
对于实施CI/CD的团队，一个常用的实践是通过打Tag标记来跟踪每一个发布的版本。但不实践CD的团队，则需要其他的发布模式&lt;/p>
&lt;h3 id="release-branch-发布分支">Release Branch 发布分支
&lt;/h3>&lt;p>预备发布的分支，只接受以版本稳定和交付为目标的提交 （一般系统测试阶段）
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-23.png"
width="716"
height="287"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-23_hu_81382339d9d451f8.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-23_hu_7bf94c3181911e26.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="249"
data-flex-basis="598px"
>&lt;/p>
&lt;p>Release分支从主干分支中拉取，不再接受任何新feature的合入。工作在release分支上的开发工作主要是修复发现的bug或影响交付的功能。所有的修改最终还需要合并回主干。
&lt;img src="https://i-blog.csdnimg.cn/blog_migrate/4e7655a86c338d8ce135fc704ded3f97.png#pic_center"
loading="lazy"
alt="cherry-pick 到release分支"
>
尽管release分支上的工作往往比新feature的开发工作量更小，但是如果在其上的开发时间过长依然会导致合并回主干非常困难（主干上的提交越多，合入就越困难）&lt;/p>
&lt;p>实际工作中，因为release分支的存在，合并回主干的操作往往容易被忽视，特别是有困难的冲突需要解决并且存在发布压力的情况下。&lt;/p>
&lt;p>所以有的开发会采用另一种方式，继续在主干上开发，然后通过cherry-pick将只和发布相关的提交合入到release分支。这种方式的缺点是很多时候chrry-pick有时也很困难（对之前的commit有依赖的情况），在实际发布之前对release分支往往有一些重做工作。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-24.png"
width="1000"
height="430"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-24_hu_2d6097156d59f34e.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-24_hu_4afd22e582bedc82.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="232"
data-flex-basis="558px"
>
对于只有一个产品版本的团队来说，使用单一的release分支就好。但很多情况下，会存在需要支持多个产品版本的情况，比如客户本地部署的软件，可能会长时间运行在一个历史版本上，但是又需要继续做一些bug fix或者一些特别的需求，此时就需要维护多个不同的release 分支，并定期保持和主干同步&lt;/p>
&lt;p>对开发团队这明显是大大增加了维护难度和工作量，但这更多是产品策略带来的成本。唯一可以做的就是鼓励客户更及时地升级到最近版本（保持产品稳定非常关键，一旦产品不稳定导致问题，会使客户更倾向不再升级）&lt;/p>
&lt;p>Release分支对于难以保持主干分支持续在健康状态的团队非常有必要，团队可以关注在产品发布的功能验证上。但对于单一产品的团队，release分支并不必要，使用主干分支并保持健康状态即可（发布的版本进行Tag标记）
另外，对于发布流程存在很多阻塞的团队，relase分支也是必要的（比如有比较缓慢的审核流程，在应用商店上线的时间窗、安全、法务、合规等的审核等）&lt;/p>
&lt;h3 id="成熟分支">成熟分支
&lt;/h3>&lt;p>分支的head总是标记为最近版本的成熟代码基线&lt;/p>
&lt;p>根据团队对产品成熟度的不同定义，拉取出的对应的成熟分支。比如QA分支（提测）、Staging分支（预发）、production分支（上线）&lt;/p>
&lt;p>但很多情况下，使用清晰定义的Tag机制就可以代替成熟分支的作用。比如“成熟级别-内部版本号”，“qa-233”，“prod-445”
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-25.png"
width="808"
height="418"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-25_hu_384ca6b5a8e6e3fb.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-25_hu_5bc1629d3f4c0e2.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="193"
data-flex-basis="463px"
>&lt;/p>
&lt;h3 id="长期发布分支">长期发布分支
&lt;/h3>&lt;p>release分支一般在产品发布后就可以删除，但我们也可以维持一个长期的发布分支。它的作用可以看作是发布分支和成熟分支的集合。这个分支上进行release前的fix工作并合并回主线，并在实际发布时打上发布Tag，然后进入下一个版本的发布准备。
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-26.png"
width="940"
height="304"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-26_hu_9c8e0e55cb8f7a79.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-26_hu_53dfcd4c2a28453e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="309"
data-flex-basis="742px"
>&lt;/p>
&lt;h3 id="环境分支">环境分支
&lt;/h3>&lt;p>通过不同的提交来配置代码的运行环境
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-27.png"
width="825"
height="467"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-27_hu_fecd763b06fd168d.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-27_hu_ddb2fac8f5b9c999.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="423px"
>&lt;/p>
&lt;p>不同的产品运行环境往往会有不同的配置代码（测试环境、开发环境、性能验证、安全验证环境、预发环境、产品环境等），环境分支会包含这些配置的变更提交并触发对应的构建、部署。&lt;/p>
&lt;p>环境分支一般也用作成熟分支，比如QA的成熟分支，会包含QA环境的配置变更。&lt;/p>
&lt;p>但是环境分支并不是好的实践，不同的环境需要不同的编译代码会引入风险。如果产品程序在不同的环境上有不同的行为表现会使问题的修复、定位变得极其困难。所以最好保证不同环境下运行的可执行代码都是相同的，环境的配置都通过显式的配置文件或变量来控制。环境变更导致的任何更改都不应包含在源码控制系统中&lt;/p>
&lt;p>环境分支只应是缺乏这种环境切换控制机制团队的应急机制存在。&lt;/p>
&lt;h3 id="hotfix">Hotfix
&lt;/h3>&lt;p>用于进行紧急产品故障修复的分支&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-28.png"
width="908"
height="310"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-28_hu_acc30d14bafe8983.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-28_hu_d0d781cb2c1c3797.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="292"
data-flex-basis="702px"
>
从主线分支对应的release版本拉取hotfix分支，并在完成后合入回主线（如果release时间比较久，合并工作可能会比较大）
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-29.png"
width="819"
height="289"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-29_hu_de9c76df8a7edc9a.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-29_hu_5c98c8fddd3a9342.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="283"
data-flex-basis="680px"
>
对使用release 分支的团队，也可以直接在release分支上进行hotfix，此时相当于将原release分支转变为hotfix分支
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-30.png"
width="785"
height="293"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-30_hu_855c768ad01d0c1f.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-30_hu_f596bdaa59685590.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="267"
data-flex-basis="643px"
>
对于实践CD的团队，甚至可以直接在主干上完成hotfix（还是会拉取hotfix分支，但会从最新的提交拉取），因为一般团队已经具备了不公开未发布特性的能力。而且在hotfix过程中，不允许向主线进行任何新的提交。（hotfix优先）&lt;/p>
&lt;p>如何定义hotfix？对于可以发布频率较高的团队，一般可以将问题纳入日常发布节奏而不需要进行hotfix。取决于团队发布频率和对业务的实际影响&lt;/p>
&lt;h3 id="release-train">release train
&lt;/h3>&lt;p>象火车发车一样有定期的发布间隔，特性完成后选择放入哪一次发布（和SAFe的Agile release train不是一个概念，那更多是组织层面的实践）
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-31.png"
width="789"
height="361"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-31_hu_1167bd31713427f4.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-31_hu_8fd7313e73bea9d4.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="218"
data-flex-basis="524px"
>
团队定义定期的发布计划，并确定每列发布列车上的功能，据此承诺、安排各自的工作任务。一旦火车发车，当前分支就转化为release分支，只会接受bug fix。发布列车一般会和feature分支一起使用。对于发布流程中存在较多阻塞的团队来说，release train是非常有用的，不会因为这些阻塞而影响后续功能的研发。
但比较明显的缺点是，如果一个功能很早就完成，也需要等到发车时间才能上线。&lt;/p>
&lt;p>release train可以看作是团队release流程的一个提升手段，对与很难进行稳定发布的团队，实施CD往往不够现实 ，此时release train会是一个好选择。&lt;/p>
&lt;h4 id="loading-future-trains">loading future trains
&lt;/h4>&lt;p>和旧列车发车后再向新的列车上装载需求不同，可以使用这种模式的变种。如果一些功能不能确定是否能在预定发车前完成，可以同时开启两列train（预期发车时间不同），在三月列车上完成的开发工作同时向4月列车上提交并在三月列车发车后继续在4月列车上完成剩余工作。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-32.png"
width="895"
height="304"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-32_hu_d04c6c121bd084fa.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-32_hu_aeb573cbb9964815.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="294"
data-flex-basis="706px"
>
这种模式可以让4月列车上的工作不影响三月列车，但缺点是如果4月列车上的变更影响到3月的功能，会是后续的合并工作更加复杂。&lt;/p>
&lt;h4 id="和主线发布比较">和主线发布比较
&lt;/h4>&lt;p>release train的主要好处是可以有一个定期的产品发布日历，但是多个分支依然会引入复杂性。
其实使用主线模式也可以如此工作，在主线上开发，到发布日期后增加一个对应的发布分支即可。
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-33.png"
width="820"
height="445"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-33_hu_e9c39230173121cc.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-33_hu_8505908c388c8ec1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;h3 id="预发布主线">预发布主线
&lt;/h3>&lt;p>确保主线是绝对健康状态，并且主线的head永远能被直接发布到产品环境。（每个提交都具备直接发布的健康状态，但是只有实际发布的提交才需要加上tag）
&lt;img src="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-34.png"
width="796"
height="265"
srcset="https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-34_hu_58a256d1b3e13f3a.png 480w, https://chengxiaqiucao.github.io/post/020-%E7%90%86%E8%A7%A3%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/Pasted-20240927-34_hu_51c51264bf398328.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="300"
data-flex-basis="720px"
>&lt;/p>
&lt;h2 id="其他发布模式">其他发布模式
&lt;/h2>&lt;h3 id="实验分支">实验分支
&lt;/h3>&lt;p>在代码基线上收集用于实验的工作，这些功能不会被直接合入产品环境&lt;/p>
&lt;p>实验性的点子
功能的不同实现方式&lt;/p>
&lt;h3 id="未来分支">未来分支
&lt;/h3>&lt;p>一个用于对其他分支侵入性太大的变更分支&lt;/p>
&lt;p>较少使用的模式，只会从主线pull而不会merge回其他分支。一旦使用，意味着团队中存在一个独立的代码特区。应尽可能缩短这个分支存在的时间。&lt;/p>
&lt;h3 id="合作分支">合作分支
&lt;/h3>&lt;p>用于开发者之间协同工作，但不需要进行正式的集成的情况。&lt;/p>
&lt;h3 id="团队集成分支">团队集成分支
&lt;/h3>&lt;p>在向主线集成前，允许子团队间先进行互相集成。（大型项目）&lt;/p>
&lt;hr>
&lt;p>原文参考Martin的博客 &lt;a class="link" href="https://martinfowler.com/articles/branching-patterns.html" target="_blank" rel="noopener"
>Branch Patterns&lt;/a>&lt;/p></description></item><item><title>理解敏捷宣言背后的文化逻辑</title><link>https://chengxiaqiucao.github.io/post/008-%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91/</link><pubDate>Sun, 01 Sep 2024 14:32:39 +0800</pubDate><guid>https://chengxiaqiucao.github.io/post/008-%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91/</guid><description>&lt;img src="https://chengxiaqiucao.github.io/post/008-%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91/agile_mani.png" alt="Featured image of post 理解敏捷宣言背后的文化逻辑" />&lt;p>敏捷是现今被广泛应用的一种研发理念和思想。著名的敏捷宣言也广为流传，被翻译为了60多种语言。&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/008-%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91/agile_mani.png"
width="2147"
height="882"
srcset="https://chengxiaqiucao.github.io/post/008-%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91/agile_mani_hu_e7cc042f16d0b9d7.png 480w, https://chengxiaqiucao.github.io/post/008-%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91/agile_mani_hu_678312c338d5826e.png 1024w"
loading="lazy"
alt="敏捷宣言"
class="gallery-image"
data-flex-grow="243"
data-flex-basis="584px"
>&lt;/p>
&lt;p>这个宣言其实更多是提出了软件研发中的一些被这些先驱者们认为更重要的价值观，传递的是一种不同于传统研发的新理念。&lt;/p>
&lt;p>但提出这些理念背后的逻辑，又是什么呢？&lt;/p>
&lt;p>我们还是应该搞清楚为什么有这样的一个宣言，否则大家虽然都号称在施行敏捷，但又有点似是而非，甚至因为敏捷又搞出很多流程、仪式和各种敏捷工具，兜兜转转又回到原点。&lt;/p>
&lt;p>这里笔者尝试理解下敏捷宣言的背后逻辑和真正作用，抓住这个核心，其实就理解了敏捷的本质。&lt;/p>
&lt;h2 id="敏捷的核心是文化">敏捷的核心是文化
&lt;/h2>&lt;p>敏捷宣言中提倡的个体和互动、可工作的软件、客户合作、响应变化，其实都不是一些具体的实践，说是价值观可能更合适。&lt;/p>
&lt;p>而价值观，其实就是建立文化的重要要素。&lt;/p>
&lt;p>任何组织，发展到一定阶段，都会开始强调文化的重要性。&lt;/p>
&lt;p>因为成熟的组织，在经过规范化的发展，有成熟的制度体系后，会发现依然有很多事情是无法依靠制度就能很好解决的。这时，冀望解决的途径就是依靠文化的力量。&lt;/p>
&lt;p>敏捷正是在传统严重依赖流程、制度的研发流程基础上，针对大量无法依靠流程、规范来成功完成软件研发的经验教训，而提出的从文化层面上去指导大家建立正确的软件研发文化，去主动改进而不是否定原有流程、规范的作用。&lt;/p>
&lt;p>所以，这里思考的结论就是：&lt;/p>
&lt;blockquote>
&lt;p>敏捷其实是一种思想转变，是建立软件研发正确行为方式的一种价值观。实现途径可能千差万别，本质就是强调建立正确的研发价值观，比具体的流程、规范更为重要。&lt;/p>&lt;/blockquote>
&lt;h2 id="文化是制度的升华">文化是制度的升华
&lt;/h2>&lt;p>所以这里把敏捷理解为建立文化的行为，也就理解了敏捷各种实践、提倡做法的背后逻辑。&lt;/p>
&lt;p>文化和制度是一个组织发展的支撑。它们都是为了指导组织成员去正确地做事&lt;/p>
&lt;ul>
&lt;li>&lt;strong>制度&lt;/strong>通过各种明文规定、流程指引成员。遵守制度做事，是被动地正确行事&lt;/li>
&lt;li>&lt;strong>文化&lt;/strong>则是通过潜移默化，组织中大家拥有共同的使命、愿景、价值观，体现到成员的行为方式上。是主动地正确行事。&lt;/li>
&lt;/ul>
&lt;h2 id="文化是什么">文化是什么？
&lt;/h2>&lt;p>文化其实是实际中，组织成员的行为方式。&lt;/p>
&lt;p>了解企业文化，也会包括使命、价值观、愿景、战略这些文化的要素。&lt;/p>
&lt;p>它们的关系可以用下面这个图概括&lt;/p>
&lt;p>&lt;img src="https://chengxiaqiucao.github.io/post/008-%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91/Pasted-20240902.png"
width="1276"
height="636"
srcset="https://chengxiaqiucao.github.io/post/008-%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91/Pasted-20240902_hu_96e600d6cb869aa3.png 480w, https://chengxiaqiucao.github.io/post/008-%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91/Pasted-20240902_hu_6c1995aba6ace70f.png 1024w"
loading="lazy"
alt="culture"
class="gallery-image"
data-flex-grow="200"
data-flex-basis="481px"
>&lt;/p>
&lt;p>回到敏捷：&lt;/p>
&lt;p>敏捷宣言 其实是价值观
敏捷的12原则 其实是实施战略
敏捷的愿景 其实和所有产品一样，向用户交付价值&lt;/p>
&lt;p>最终，敏捷冀望达成的，就是建立起一种面向软件研发的新文化&lt;/p>
&lt;p>水无常形， 兵无常势。敏捷也不存在所谓的标准做法，符合敏捷价值观，达成共识并进行实践的团队，就是敏捷团队。&lt;/p>
&lt;hr>
&lt;p>推广下我的测试课程，感兴趣的小伙伴可以通过以下链接了解下哦&lt;/p>
&lt;p>❤️❤️❤️❤️ &lt;a class="link" href="https://coding.imooc.com/class/chapter/885.html#Anchor" target="_blank" rel="noopener"
>城下秋草的测试职业进阶提升课&lt;/a> ❤️❤️❤️❤️&lt;/p></description></item></channel></rss>